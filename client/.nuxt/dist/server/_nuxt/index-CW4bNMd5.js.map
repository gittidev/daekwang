{"version":3,"file":"index-CW4bNMd5.js","sources":["../../../../lib/noise.ts","../../../../components/FloatingPaths.vue","../../../../node_modules/@tresjs/core/node_modules/@vueuse/shared/index.mjs","../../../../node_modules/@tresjs/core/node_modules/@vueuse/core/index.mjs","../../../../node_modules/@tresjs/core/dist/tres.js","../../../../node_modules/@tresjs/cientos/dist/trescientos.js","../../../../components/model/PipeModel.vue","../../../../pages/index.vue"],"sourcesContent":["// src/lib/noise.ts\r\n\r\nclass Grad {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n\r\n  constructor(x: number, y: number, z: number) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n  }\r\n\r\n  dot2(x: number, y: number): number {\r\n    return this.x * x + this.y * y;\r\n  }\r\n}\r\n\r\nexport class Noise {\r\n  private grad3: Grad[];\r\n  private p: number[];\r\n  private perm: number[];\r\n  private gradP: Grad[];\r\n\r\n  constructor(seed = 0) {\r\n    this.grad3 = [\r\n      new Grad(1, 1, 0),\r\n      new Grad(-1, 1, 0),\r\n      new Grad(1, -1, 0),\r\n      new Grad(-1, -1, 0),\r\n      new Grad(1, 0, 1),\r\n      new Grad(-1, 0, 1),\r\n      new Grad(1, 0, -1),\r\n      new Grad(-1, 0, -1),\r\n      new Grad(0, 1, 1),\r\n      new Grad(0, -1, 1),\r\n      new Grad(0, 1, -1),\r\n      new Grad(0, -1, -1),\r\n    ];\r\n\r\n    this.p = [\r\n      151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,\r\n      140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247,\r\n      120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177,\r\n      33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165,\r\n      71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,\r\n      133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25,\r\n      63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\r\n      135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217,\r\n      226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,\r\n      59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248,\r\n      152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\r\n      39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218,\r\n      246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,\r\n      81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,\r\n      184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,\r\n      222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,\r\n    ];\r\n\r\n    this.perm = new Array(512);\r\n    this.gradP = new Array(512);\r\n    this.seed(seed);\r\n  }\r\n\r\n  seed(seed: number) {\r\n    if (seed > 0 && seed < 1) seed *= 65536;\r\n    seed = Math.floor(seed);\r\n    if (seed < 256) seed |= seed << 8;\r\n\r\n    for (let i = 0; i < 256; i++) {\r\n      const v =\r\n        i & 1 ? this.p[i] ^ (seed & 255) : this.p[i] ^ ((seed >> 8) & 255);\r\n      this.perm[i] = this.perm[i + 256] = v;\r\n      this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];\r\n    }\r\n  }\r\n\r\n  fade(t: number) {\r\n    return t * t * t * (t * (t * 6 - 15) + 10);\r\n  }\r\n\r\n  lerp(a: number, b: number, t: number) {\r\n    return (1 - t) * a + t * b;\r\n  }\r\n\r\n  perlin2(x: number, y: number) {\r\n    let X = Math.floor(x),\r\n      Y = Math.floor(y);\r\n    x -= X;\r\n    y -= Y;\r\n    X &= 255;\r\n    Y &= 255;\r\n\r\n    const n00 = this.gradP[X + this.perm[Y]].dot2(x, y);\r\n    const n01 = this.gradP[X + this.perm[Y + 1]].dot2(x, y - 1);\r\n    const n10 = this.gradP[X + 1 + this.perm[Y]].dot2(x - 1, y);\r\n    const n11 = this.gradP[X + 1 + this.perm[Y + 1]].dot2(x - 1, y - 1);\r\n\r\n    const u = this.fade(x);\r\n    const v = this.fade(y);\r\n\r\n    return this.lerp(this.lerp(n00, n10, u), this.lerp(n01, n11, u), v);\r\n  }\r\n}\r\n","<template>\r\n  <div\r\n    ref=\"containerRef\"\r\n    class=\"absolute top-0 left-0 w-full h-full overflow-hidden\"\r\n    :style=\"{ backgroundColor }\"\r\n  >\r\n    <div\r\n      class=\"absolute top-0 left-0 rounded-full w-2 h-2 bg-foreground/10\"\r\n      :style=\"cursorStyle\"\r\n    />\r\n    <canvas ref=\"canvasRef\" class=\"block w-full h-full\" />\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { ref, onMounted, onUnmounted, watchEffect } from \"vue\";\r\nimport { Noise } from \"@/lib/noise\";\r\nimport { computed } from \"vue\";\r\n\r\nconst props = defineProps({\r\n  lineColor: { type: String, default: \"hsl(var(--foreground))\" },\r\n  backgroundColor: { type: String, default: \"transparent\" },\r\n  waveSpeedX: { type: Number, default: 0.0125 },\r\n  waveSpeedY: { type: Number, default: 0.005 },\r\n  waveAmpX: { type: Number, default: 32 },\r\n  waveAmpY: { type: Number, default: 16 },\r\n  xGap: { type: Number, default: 30 },\r\n  yGap: { type: Number, default: 48 },\r\n  friction: { type: Number, default: 0.925 },\r\n  tension: { type: Number, default: 0.005 },\r\n  maxCursorMove: { type: Number, default: 100 },\r\n  className: String,\r\n});\r\n\r\nconst containerRef = ref<HTMLElement | null>(null);\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\r\nconst ctxRef = ref<CanvasRenderingContext2D | null>(null);\r\nconst boundingRef = ref({ width: 0, height: 0, left: 0, top: 0 });\r\n\r\nconst linesRef = ref<any[][]>([]);\r\nconst noiseRef = ref(new Noise(Math.random()));\r\nconst mouseRef = ref({\r\n  x: -10,\r\n  y: 0,\r\n  lx: 0,\r\n  ly: 0,\r\n  sx: 0,\r\n  sy: 0,\r\n  v: 0,\r\n  vs: 0,\r\n  a: 0,\r\n  set: false,\r\n});\r\n\r\nlet animationFrame: number;\r\n\r\nconst cursorStyle = computed(() => ({\r\n  transform: `translate3d(calc(${mouseRef.value.sx}px - 50%), calc(${mouseRef.value.sy}px - 50%), 0)`,\r\n  willChange: \"transform\",\r\n}));\r\n\r\nfunction setSize() {\r\n  const container = containerRef.value;\r\n  const canvas = canvasRef.value;\r\n  if (!container || !canvas) return;\r\n  const bounds = container.getBoundingClientRect();\r\n  boundingRef.value = bounds;\r\n  canvas.width = bounds.width;\r\n  canvas.height = bounds.height;\r\n}\r\n\r\nfunction setLines() {\r\n  const { width, height } = boundingRef.value;\r\n  const oWidth = width + 200,\r\n    oHeight = height + 30;\r\n  const totalLines = Math.ceil(oWidth / props.xGap);\r\n  const totalPoints = Math.ceil(oHeight / props.yGap);\r\n  const xStart = (width - props.xGap * totalLines) / 2;\r\n  const yStart = (height - props.yGap * totalPoints) / 2;\r\n\r\n  linesRef.value = [];\r\n  for (let i = 0; i <= totalLines; i++) {\r\n    const pts = [];\r\n    for (let j = 0; j <= totalPoints; j++) {\r\n      pts.push({\r\n        x: xStart + props.xGap * i,\r\n        y: yStart + props.yGap * j,\r\n        wave: { x: 0, y: 0 },\r\n        cursor: { x: 0, y: 0, vx: 0, vy: 0 },\r\n        depth: 0,\r\n      });\r\n    }\r\n    linesRef.value.push(pts);\r\n  }\r\n}\r\n\r\nfunction updateMouse(x: number, y: number) {\r\n  const bounds = boundingRef.value;\r\n  const m = mouseRef.value;\r\n  m.x = x - bounds.left;\r\n  m.y = y - bounds.top + window.scrollY;\r\n  if (!m.set) {\r\n    m.sx = m.x;\r\n    m.sy = m.y;\r\n    m.lx = m.x;\r\n    m.ly = m.y;\r\n    m.set = true;\r\n  }\r\n}\r\n\r\nfunction movePoints(time: number) {\r\n  const mouse = mouseRef.value;\r\n  const lines = linesRef.value;\r\n  const noise = noiseRef.value;\r\n\r\n  lines.forEach((pts) => {\r\n    pts.forEach((p) => {\r\n      const move =\r\n        noise.perlin2(\r\n          (p.x + time * props.waveSpeedX) * 0.002,\r\n          (p.y + time * props.waveSpeedY) * 0.0015\r\n        ) * 12;\r\n      p.wave.x = Math.cos(move) * props.waveAmpX;\r\n      p.wave.y = Math.sin(move) * props.waveAmpY;\r\n\r\n      const dx = p.x - mouse.sx;\r\n      const dy = p.y - mouse.sy;\r\n      const dist = Math.hypot(dx, dy);\r\n      const l = Math.max(175, mouse.vs);\r\n\r\n      if (dist < l) {\r\n        const s = 1 - dist / l;\r\n        const f = Math.cos(dist * 0.001) * s;\r\n        //ë§ˆìš°ìŠ¤ ì˜í–¥ ì •ë„\r\n        p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00025;\r\n        p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00025;\r\n      }\r\n\r\n      p.cursor.vx += (0 - p.cursor.x) * props.tension;\r\n      p.cursor.vy += (0 - p.cursor.y) * props.tension;\r\n      p.cursor.vx *= props.friction;\r\n      p.cursor.vy *= props.friction;\r\n      p.cursor.x += p.cursor.vx * 2;\r\n      p.cursor.y += p.cursor.vy * 2;\r\n\r\n      p.cursor.x = Math.max(\r\n        -props.maxCursorMove,\r\n        Math.min(props.maxCursorMove, p.cursor.x)\r\n      );\r\n      p.cursor.y = Math.max(\r\n        -props.maxCursorMove,\r\n        Math.min(props.maxCursorMove, p.cursor.y)\r\n      );\r\n    });\r\n  });\r\n}\r\n\r\nfunction drawLines() {\r\n  const { width, height } = boundingRef.value;\r\n  const ctx = ctxRef.value;\r\n  if (!ctx) return;\r\n\r\n  ctx.clearRect(0, 0, width, height);\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = props.lineColor;\r\n\r\n  linesRef.value.forEach((points) => {\r\n    let p1 = moved(points[0], false);\r\n    ctx.moveTo(p1.x, p1.y);\r\n    points.forEach((p, idx) => {\r\n      if (p.depth < -5) {\r\n        ctx.shadowColor = \"rgba(0,0,0,0.15)\";\r\n        ctx.shadowBlur = 10;\r\n        ctx.shadowOffsetY = 3;\r\n      } else {\r\n        ctx.shadowColor = \"transparent\";\r\n        ctx.shadowBlur = 0;\r\n        ctx.shadowOffsetY = 0;\r\n      }\r\n      const isLast = idx === points.length - 1;\r\n      p1 = moved(p, !isLast);\r\n      const p2 = moved(points[idx + 1] || points[points.length - 1], !isLast);\r\n      ctx.lineTo(p1.x, p1.y);\r\n      if (isLast) ctx.moveTo(p2.x, p2.y);\r\n    });\r\n  });\r\n\r\n  ctx.stroke();\r\n}\r\n\r\nfunction moved(p: any, withCursor = true) {\r\n  const x = p.x + p.wave.x + (withCursor ? p.cursor.x : 0);\r\n  const y = p.y + p.wave.y + (withCursor ? p.cursor.y : 0) + p.depth;\r\n  return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };\r\n}\r\n\r\nfunction tick(time: number) {\r\n  const m = mouseRef.value;\r\n  m.sx += (m.x - m.sx) * 0.1;\r\n  m.sy += (m.y - m.sy) * 0.1;\r\n\r\n  const dx = m.x - m.lx;\r\n  const dy = m.y - m.ly;\r\n  const d = Math.hypot(dx, dy);\r\n  m.v = d;\r\n  m.vs += (d - m.vs) * 0.1;\r\n  m.vs = Math.min(100, m.vs);\r\n  m.lx = m.x;\r\n  m.ly = m.y;\r\n  m.a = Math.atan2(dy, dx);\r\n\r\n  // ðŸ‘‡ ê¹Šì´ ë³µì› ë¡œì§ ì¶”ê°€\r\n  linesRef.value.forEach((line) => {\r\n    line.forEach((p) => {\r\n      p.depth += (0 - p.depth) * 0.05; // easing ë³µì›\r\n    });\r\n  });\r\n\r\n  movePoints(time);\r\n  drawLines();\r\n  animationFrame = requestAnimationFrame(tick);\r\n}\r\n\r\nonMounted(() => {\r\n  const canvas = canvasRef.value;\r\n  ctxRef.value = canvas?.getContext(\"2d\") ?? null;\r\n\r\n  setSize();\r\n  setLines();\r\n  requestAnimationFrame(tick);\r\n\r\n  window.addEventListener(\"resize\", setSize);\r\n  window.addEventListener(\"mousemove\", (e) => updateMouse(e.pageX, e.pageY));\r\n\r\n  window.addEventListener(\"click\", (e) => {\r\n    updateMouse(e.pageX, e.pageY);\r\n\r\n    const { sx, sy } = mouseRef.value;\r\n\r\n    linesRef.value.forEach((line) => {\r\n      line.forEach((p) => {\r\n        const dx = p.x - sx;\r\n        const dy = p.y - sy;\r\n        const dist = Math.hypot(dx, dy);\r\n        if (dist < 150) {\r\n          const impact = 1 - dist / 150;\r\n          p.depth = -40 * impact;\r\n        }\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\nonUnmounted(() => {\r\n  cancelAnimationFrame(animationFrame);\r\n  window.removeEventListener(\"resize\", setSize);\r\n  window.removeEventListener(\"mousemove\", (e) => updateMouse(e.pageX, e.pageY));\r\n  window.removeEventListener(\"click\", (e) => {\r\n    updateMouse(e.pageX, e.pageY);\r\n  });\r\n});\r\n</script>\r\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, inject, provide, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get(v);\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!scope) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue(args[0]()) : toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(toValue(options.locales), { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(toValue(options.locales), { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    if (isActive.value)\n      timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, camelize, toValue, isClient, isObject, tryOnScopeDispose, isIOS, tryOnMounted, notNullish, objectOmit, promiseTimeout, until, increaseWithUnit, objectEntries, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, toRefs, useIntervalFn, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, tryOnUnmounted, clamp, syncRef, objectPick, watchWithFilter, tryOnBeforeUnmount, identity, isDef, whenever, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, isVue2, readonly, reactive, toRaw, nextTick, markRaw, unref, getCurrentScope, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return noop;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return toValue(ignore).some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  function hasMultipleRoots(target2) {\n    const vm = toValue(target2);\n    return vm && vm.$.subTree.shapeFlag === 16;\n  }\n  function checkMultipleRoots(target2, event) {\n    const vm = toValue(target2);\n    const children = vm.$.subTree && vm.$.subTree.children;\n    if (children == null || !Array.isArray(children))\n      return false;\n    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));\n  }\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (event.target == null)\n      return;\n    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))\n      return;\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  let isProcessingClick = false;\n  const cleanup = [\n    useEventListener(window, \"click\", (event) => {\n      if (!isProcessingClick) {\n        isProcessingClick = true;\n        setTimeout(() => {\n          isProcessingClick = false;\n        }, 0);\n        listener(event);\n      }\n    }, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    if (!isFocusedElementEditable() && isTypedCharValid(event)) {\n      callback(event);\n    }\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, isVue2 ? void 0 : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true,\n    triggerOnRemoval = false\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = ref();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      trigger();\n    }, true);\n    useEventListener(window, \"focus\", trigger, true);\n  }\n  if (triggerOnRemoval) {\n    useMutationObserver(document, (mutations) => {\n      mutations.filter((m) => m.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node) => {\n        if (node === activeElement.value)\n          trigger();\n      });\n    }, {\n      childList: true,\n      subtree: true\n    });\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    if (!animate.value)\n      update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    if (el)\n      update();\n  });\n  watch(() => keyframes, (value) => {\n    if (animate.value)\n      update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => update(true), false);\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  useEventListener(animate, \"finish\", () => {\n    var _a;\n    if (commitStyles)\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\n  });\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        if (activeIndex.value === tasks.length - 1)\n          onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\nconst breakpointsElement = {\n  xs: 0,\n  sm: 768,\n  md: 992,\n  lg: 1200,\n  xl: 1920\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\" } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(-1));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  const permissionStatus = shallowRef();\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = shallowRef();\n  const update = () => {\n    var _a, _b;\n    state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : \"prompt\";\n  };\n  useEventListener(permissionStatus, \"change\", update);\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus.value) {\n      try {\n        permissionStatus.value = await navigator.permissions.query(desc);\n      } catch (e) {\n        permissionStatus.value = void 0;\n      } finally {\n        update();\n      }\n    }\n    if (controls)\n      return toRaw(permissionStatus.value);\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      if (storage instanceof Storage)\n        useEventListener(window, \"storage\", update);\n      else\n        useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      const payload = {\n        key,\n        oldValue,\n        newValue,\n        storageArea: storage\n      };\n      window.dispatchEvent(storage instanceof Storage ? new StorageEvent(\"storage\", payload) : new CustomEvent(customStorageEventName, {\n        detail: payload\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nconst CSS_DISABLE_TRANS = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      const classesToAdd = /* @__PURE__ */ new Set();\n      const classesToRemove = /* @__PURE__ */ new Set();\n      let attributeToChange = null;\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            classesToAdd.add(v);\n          else\n            classesToRemove.add(v);\n        });\n      } else {\n        attributeToChange = { key: attribute2, value };\n      }\n      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));\n        window.document.head.appendChild(style);\n      }\n      for (const c of classesToAdd) {\n        el.classList.add(c);\n      }\n      for (const c of classesToRemove) {\n        el.classList.remove(c);\n      }\n      if (attributeToChange) {\n        el.setAttribute(attributeToChange.key, attributeToChange.value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue, observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window && key) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    (_, old) => {\n      if (old[0] && old[1])\n        old[0].style.removeProperty(old[1]);\n      updateCssVar();\n    },\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      const raw_prop = toValue(prop);\n      if (((_a = elRef.value) == null ? void 0 : _a.style) && raw_prop) {\n        if (val == null)\n          elRef.value.style.removeProperty(raw_prop);\n        else\n          elRef.value.style.setProperty(raw_prop, val);\n      }\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => {\n    if (mode.system) {\n      return mode.system.value;\n    } else {\n      const preferredDark = usePreferredDark({ window });\n      return preferredDark.value ? \"dark\" : \"light\";\n    }\n  });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    tryOnScopeDispose(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      let granted = true;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia(constraints);\n      } catch (e) {\n        stream = null;\n        granted = false;\n      }\n      update();\n      permissionGranted.value = granted;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    var _a2;\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.addEventListener(\"ended\", stop));\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target,\n    buttons = [0]\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!toValue(buttons).includes(e.button))\n      return;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  var _a, _b;\n  const isOverDropZone = ref(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isValid = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const multiple = (_a = _options.multiple) != null ? _a : true;\n    const preventDefaultForUnhandled = (_b = _options.preventDefaultForUnhandled) != null ? _b : false;\n    const getFiles = (event) => {\n      var _a2, _b2;\n      const list = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b2 : []);\n      return list.length === 0 ? null : multiple ? list : [list[0]];\n    };\n    const checkDataTypes = (types) => {\n      if (_options.dataTypes) {\n        const dataTypes = unref(_options.dataTypes);\n        return typeof dataTypes === \"function\" ? dataTypes(types) : dataTypes ? dataTypes.some((item) => types.includes(item)) : true;\n      }\n      return true;\n    };\n    const checkValidity = (event) => {\n      var _a2, _b2;\n      const items = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.items) != null ? _b2 : []);\n      const types = items.map((item) => item.type);\n      const dataTypesValid = checkDataTypes(types);\n      const multipleFilesValid = multiple || items.length <= 1;\n      return dataTypesValid && multipleFilesValid;\n    };\n    const handleDragEvent = (event, eventType) => {\n      var _a2, _b2, _c, _d;\n      isValid = checkValidity(event);\n      if (!isValid) {\n        if (preventDefaultForUnhandled) {\n          event.preventDefault();\n        }\n        if (event.dataTransfer) {\n          event.dataTransfer.dropEffect = \"none\";\n        }\n        return;\n      }\n      event.preventDefault();\n      if (event.dataTransfer) {\n        event.dataTransfer.dropEffect = \"copy\";\n      }\n      const currentFiles = getFiles(event);\n      switch (eventType) {\n        case \"enter\":\n          counter += 1;\n          isOverDropZone.value = true;\n          (_a2 = _options.onEnter) == null ? void 0 : _a2.call(_options, null, event);\n          break;\n        case \"over\":\n          (_b2 = _options.onOver) == null ? void 0 : _b2.call(_options, null, event);\n          break;\n        case \"leave\":\n          counter -= 1;\n          if (counter === 0)\n            isOverDropZone.value = false;\n          (_c = _options.onLeave) == null ? void 0 : _c.call(_options, null, event);\n          break;\n        case \"drop\":\n          counter = 0;\n          isOverDropZone.value = false;\n          if (isValid) {\n            files.value = currentFiles;\n            (_d = _options.onDrop) == null ? void 0 : _d.call(_options, currentFiles, event);\n          }\n          break;\n      }\n    };\n    useEventListener(target, \"dragenter\", (event) => handleDragEvent(event, \"enter\"));\n    useEventListener(target, \"dragover\", (event) => handleDragEvent(event, \"over\"));\n    useEventListener(target, \"dragleave\", (event) => handleDragEvent(event, \"leave\"));\n    useEventListener(target, \"drop\", (event) => handleDragEvent(event, \"drop\"));\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const _targets = toValue(target);\n    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];\n  });\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els) {\n          if (_el)\n            observer.observe(_el, observerOptions);\n        }\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true,\n    updateTiming = \"sync\"\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function recalculate() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  function update() {\n    if (updateTiming === \"sync\")\n      recalculate();\n    else if (updateTiming === \"next-frame\")\n      requestAnimationFrame(() => recalculate());\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  const lastEventId = shallowRef(null);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      event.value = null;\n      data.value = e.data;\n      lastEventId.value = e.lastEventId;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        event.value = event_name;\n        data.value = e.data || null;\n      });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close,\n    lastEventId\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n  return reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = toValue(config.payload);\n      const proto = Object.getPrototypeOf(payload);\n      if (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\")) {\n    return `${start}/${end}`;\n  }\n  if (start.endsWith(\"/\") && end.startsWith(\"/\")) {\n    return `${start.slice(0, -1)}${end}`;\n  }\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger: changeTrigger } = createEventHook();\n  const { on: onCancel, trigger: cancelTrigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      changeTrigger(files.value);\n    };\n    input.oncancel = () => {\n      cancelTrigger();\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input && input.value) {\n      input.value = \"\";\n      changeTrigger(null);\n    }\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onCancel,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nconst EVENT_FOCUS_IN = \"focusin\";\nconst EVENT_FOCUS_OUT = \"focusout\";\nfunction useFocusWithin(target, options = {}) {\n  const { window = defaultWindow } = options;\n  const targetElement = computed(() => unrefElement(target));\n  const _focused = ref(false);\n  const focused = computed(() => _focused.value);\n  const activeElement = useActiveElement(options);\n  if (!window || !activeElement.value) {\n    return { focused };\n  }\n  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true);\n  useEventListener(targetElement, EVENT_FOCUS_OUT, () => _focused.value = false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      index: gamepad.index,\n      connected: gamepad.connected,\n      mapping: gamepad.mapping,\n      timestamp: gamepad.timestamp,\n      vibrationActuator: gamepad.vibrationActuator,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  const stop = watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  tryOnUnmounted(stop);\n  return {\n    isLoading,\n    reset() {\n      nextTick(() => checkAndLoad());\n    }\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  target = toRef(target);\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const playbackErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    if (isPlaying) {\n      el.play().catch((e) => {\n        playbackErrorEvent.trigger(e);\n        throw e;\n      });\n    } else {\n      el.pause();\n    }\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on,\n    onPlaybackError: playbackErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = shallowReactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  let _prevScrollX = 0;\n  let _prevScrollY = 0;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n    if (window) {\n      _prevScrollX = window.scrollX;\n      _prevScrollY = window.scrollY;\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX - _prevScrollX;\n      y.value = pos[1] + window.scrollY - _prevScrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el || !(el instanceof Element))\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported: readonly(isSupported),\n    isOnline: readonly(isOnline),\n    saveData: readonly(saveData),\n    offlineAt: readonly(offlineAt),\n    onlineAt: readonly(onlineAt),\n    downlink: readonly(downlink),\n    downlinkMax: readonly(downlinkMax),\n    effectiveType: readonly(effectiveType),\n    rtt: readonly(rtt),\n    type: readonly(type)\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\n      return \"deviceOrientation\";\n    }\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    })\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    if (isIOS)\n      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    maxAlternatives = 1,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.maxAlternatives = maxAlternatives;\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n      isFinal.value = currentResult.isFinal;\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    if (utterance)\n      synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))\n        e.preventDefault();\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  var _a;\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : \"height\";\n  const textareaScrollHeight = ref(1);\n  const textareaOldWidth = ref(0);\n  function triggerResize() {\n    var _a2;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    const _styleTarget = toValue(options == null ? void 0 : options.styleTarget);\n    if (_styleTarget)\n      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  watch(textareaScrollHeight, () => {\n    var _a2;\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\n  });\n  useResizeObserver(textarea, ([{ contentRect }]) => {\n    if (textareaOldWidth.value === contentRect.width)\n      return;\n    textareaOldWidth.value = contentRect.width;\n    triggerResize();\n  });\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval, { immediate: false });\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnBeforeUnmount(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${window.location.search || \"\"}${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${window.location.search || \"\"}${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n  watch([size.width, size.height, list, containerRef], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  const requestedType = ref(false);\n  const sentinel = shallowRef(null);\n  const documentVisibility = useDocumentVisibility({ document });\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = computed(() => !!sentinel.value && documentVisibility.value === \"visible\");\n  if (isSupported.value) {\n    useEventListener(sentinel, \"release\", () => {\n      var _a, _b;\n      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;\n    });\n    whenever(\n      () => documentVisibility.value === \"visible\" && (document == null ? void 0 : document.visibilityState) === \"visible\" && requestedType.value,\n      (type) => {\n        requestedType.value = false;\n        forceRequest(type);\n      }\n    );\n  }\n  async function forceRequest(type) {\n    var _a;\n    await ((_a = sentinel.value) == null ? void 0 : _a.release());\n    sentinel.value = isSupported.value ? await navigator.wakeLock.request(type) : null;\n  }\n  async function request(type) {\n    if (documentVisibility.value === \"visible\")\n      await forceRequest(type);\n    else\n      requestedType.value = type;\n  }\n  async function release() {\n    requestedType.value = false;\n    const s = sentinel.value;\n    sentinel.value = null;\n    await (s == null ? void 0 : s.release());\n  }\n  return {\n    sentinel,\n    isSupported,\n    isActive,\n    request,\n    forceRequest,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => {\n    if (!window || !(\"Notification\" in window))\n      return false;\n    try {\n      new Notification(\"\");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  });\n  const permissionGranted = ref(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      retried = 0;\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries)) {\n          retried += 1;\n          setTimeout(_init, delay);\n        } else if (typeof retries === \"function\" && retries()) {\n          setTimeout(_init, delay);\n        } else {\n          onFailed == null ? void 0 : onFailed();\n        }\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE,\n          responseMessage = message\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === responseMessage)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  watch(urlRef, open);\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction depsParser(deps, localDeps) {\n  if (deps.length === 0 && localDeps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n    const str = fn.toString();\n    if (str.trim().startsWith(\"function\")) {\n      return str;\n    } else {\n      const name = fn.name;\n      return `const ${name} = ${str}`;\n    }\n  }).join(\";\");\n  const importString = `importScripts(${depsString});`;\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    localDependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    var _a;\n    promise.value = {\n      resolve,\n      reject\n    };\n    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const internalX = ref(window.scrollX);\n  const internalY = ref(window.scrollY);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true,\n    type = \"inner\"\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (type === \"outer\") {\n        width.value = window.outerWidth;\n        height.value = window.outerHeight;\n      } else if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","/**\n * name: @tresjs/core\n * version: v4.3.1\n * (c) 2024\n * description: Declarative ThreeJS using Vue Components\n * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)\n */\nvar Et = Object.defineProperty;\nvar Tt = (e, t, n) => t in e ? Et(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar he = (e, t, n) => Tt(e, typeof t != \"symbol\" ? t + \"\" : t, n);\nimport { defineComponent as fe, withAsyncContext as nt, reactive as Se, renderSlot as rt, unref as W, ref as I, computed as K, watchEffect as xe, onUnmounted as J, shallowRef as $, watch as ae, readonly as we, provide as le, inject as St, isRef as xt, useSlots as At, getCurrentInstance as He, onMounted as kt, openBlock as Lt, createElementBlock as Rt, normalizeClass as Ot, normalizeStyle as Dt, createRenderer as jt, h as Ue, Fragment as Bt } from \"vue\";\nimport * as ot from \"three\";\nimport { Scene as st, Vector3 as Ae, MathUtils as it, MeshBasicMaterial as at, DoubleSide as It, TextureLoader as $t, PerspectiveCamera as be, Camera as Ht, Clock as lt, REVISION as Ut, Color as Z, SRGBColorSpace as Ft, ACESFilmicToneMapping as ct, PCFSoftShadowMap as Wt, NoToneMapping as Nt, WebGLRenderer as ge, Vector2 as ve, Raycaster as zt, BufferAttribute as Gt, Object3D as Vt, ArrowHelper as Yt, Line as qt, BufferGeometry as Fe, Float32BufferAttribute as We, LineBasicMaterial as Kt, Mesh as Jt, BackSide as Qt, DirectionalLightHelper as Xt, PointLightHelper as Zt, SpotLightHelper as en, HemisphereLightHelper as tn } from \"three\";\nimport { tryOnScopeDispose as nn, toValue as x, unrefElement as rn, useDevicePixelRatio as on, useWindowSize as sn, useElementSize as an, refDebounced as Ne, usePointer as ln, useElementBounding as cn, createEventHook as D, useFps as un, useMemory as fn, useRafFn as ut } from \"@vueuse/core\";\nconst dn = \"@tresjs/core\", pn = \"module\", mn = \"4.3.1\", hn = \"pnpm@9.1.4\", gn = \"Declarative ThreeJS using Vue Components\", vn = \"Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)\", yn = \"MIT\", _n = {\n  type: \"git\",\n  url: \"git+https://github.com/Tresjs/tres.git\"\n}, wn = [\n  \"vue\",\n  \"3d\",\n  \"threejs\",\n  \"three\",\n  \"threejs-vue\"\n], bn = !1, Mn = {\n  \".\": {\n    types: \"./dist/index.d.ts\",\n    import: \"./dist/tres.js\",\n    require: \"./dist/tres.umd.cjs\"\n  },\n  \"./components\": {\n    types: \"./dist/src/components/index.d.ts\"\n  },\n  \"./composables\": {\n    types: \"./dist/src/composables/index.d.ts\"\n  },\n  \"./types\": {\n    types: \"./dist/src/types/index.d.ts\"\n  },\n  \"./utils\": {\n    types: \"./dist/src/utils/index.d.ts\"\n  },\n  \"./*\": \"./*\"\n}, Pn = \"./dist/tres.js\", Cn = \"./dist/tres.js\", En = \"./dist/index.d.ts\", Tn = [\n  \"*.d.ts\",\n  \"dist\"\n], Sn = {\n  access: \"public\"\n}, xn = {\n  dev: \"cd playground/vue && npm run dev\",\n  \"dev:nuxt\": \"cd playground/nuxt && npm run dev\",\n  build: \"vite build\",\n  test: \"vitest\",\n  \"test:ci\": \"vitest run\",\n  \"test:ui\": \"vitest --ui --coverage.enabled=true\",\n  release: \"release-it\",\n  coverage: \"vitest run --coverage\",\n  lint: \"eslint .\",\n  \"lint:fix\": \"eslint . --fix\",\n  \"docs:dev\": \"vitepress dev docs\",\n  \"docs:build\": \"vitepress build docs\",\n  \"docs:serve\": \"vitepress serve docs\",\n  \"docs:preview\": \"vitepress preview docs\",\n  \"docs:contributors\": \"esno scripts/update-contributors.ts\"\n}, An = {\n  three: \">=0.133\",\n  vue: \">=3.4\"\n}, kn = {\n  \"@alvarosabu/utils\": \"^3.2.0\",\n  \"@vue/devtools-api\": \"^6.6.3\",\n  \"@vueuse/core\": \"^11.1.0\"\n}, Ln = {\n  \"@release-it/conventional-changelog\": \"^9.0.0\",\n  \"@stackblitz/sdk\": \"^1.11.0\",\n  \"@tresjs/cientos\": \"4.0.3\",\n  \"@tresjs/eslint-config\": \"^1.4.0\",\n  \"@types/three\": \"^0.169.0\",\n  \"@typescript-eslint/eslint-plugin\": \"^8.8.1\",\n  \"@typescript-eslint/parser\": \"^8.8.1\",\n  \"@vitejs/plugin-vue\": \"^5.1.4\",\n  \"@vitest/coverage-c8\": \"^0.33.0\",\n  \"@vitest/coverage-v8\": \"^2.1.2\",\n  \"@vitest/ui\": \"^2.1.2\",\n  \"@vue/test-utils\": \"^2.4.6\",\n  eslint: \"^9.12.0\",\n  \"eslint-plugin-vue\": \"^9.29.0\",\n  esno: \"^4.8.0\",\n  gsap: \"^3.12.5\",\n  husky: \"^9.1.6\",\n  jsdom: \"^25.0.1\",\n  kolorist: \"^1.8.0\",\n  ohmyfetch: \"^0.4.21\",\n  pathe: \"^1.1.2\",\n  \"release-it\": \"^17.8.2\",\n  \"rollup-plugin-analyzer\": \"^4.0.0\",\n  \"rollup-plugin-copy\": \"^3.5.0\",\n  \"rollup-plugin-visualizer\": \"^5.12.0\",\n  sponsorkit: \"^0.15.5\",\n  three: \"^0.169.0\",\n  unocss: \"^0.63.4\",\n  unplugin: \"^1.14.1\",\n  \"unplugin-vue-components\": \"^0.27.4\",\n  vite: \"^5.4.8\",\n  \"vite-plugin-banner\": \"^0.8.0\",\n  \"vite-plugin-dts\": \"4.2.4\",\n  \"vite-plugin-inspect\": \"^0.8.7\",\n  \"vite-plugin-require-transform\": \"^1.0.21\",\n  \"vite-svg-loader\": \"^5.1.0\",\n  vitepress: \"1.4.0\",\n  vitest: \"^2.1.2\",\n  vue: \"3.5.12\",\n  \"vue-demi\": \"^0.14.10\"\n}, Rn = {\n  name: dn,\n  type: pn,\n  version: mn,\n  packageManager: hn,\n  description: gn,\n  author: vn,\n  license: yn,\n  repository: _n,\n  keywords: wn,\n  sideEffects: bn,\n  exports: Mn,\n  main: Pn,\n  module: Cn,\n  types: En,\n  files: Tn,\n  publishConfig: Sn,\n  scripts: xn,\n  peerDependencies: An,\n  dependencies: kn,\n  devDependencies: Ln\n};\nfunction On(e) {\n  const t = { nodes: {}, materials: {} };\n  return e && e.traverse((n) => {\n    n.name && (t.nodes[n.name] = n), n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material);\n  }), t;\n}\nasync function Dn(e, t, n, r, s) {\n  const { logError: l } = V(), i = new e();\n  return s && s(i), n && n(i), await new Promise((a, c) => {\n    i.load(\n      t,\n      (o) => {\n        const f = o;\n        f.scene && Object.assign(f, On(f.scene)), a(f);\n      },\n      r,\n      (o) => {\n        l(\"[useLoader] - Failed to load resource\", o), c(o);\n      }\n    );\n  });\n}\nconst Yr = /* @__PURE__ */ fe({\n  __name: \"component\",\n  props: {\n    loader: {},\n    url: {}\n  },\n  async setup(e) {\n    let t, n;\n    const r = e, s = ([t, n] = nt(() => Se(Dn(r.loader, r.url))), t = await t, n(), t);\n    return (l, i) => rt(l.$slots, \"default\", { data: W(s) });\n  }\n});\nclass jn extends ot.Mesh {\n  constructor(...n) {\n    super(...n);\n    he(this, \"type\", \"HightlightMesh\");\n    he(this, \"createTime\");\n    this.createTime = Date.now();\n  }\n  onBeforeRender() {\n    const r = (Date.now() - this.createTime) / 1e3, i = 1 + 0.07 * Math.sin(2.5 * r);\n    this.scale.set(i, i, i);\n  }\n}\nfunction Me(e) {\n  return typeof e > \"u\";\n}\nfunction de(e) {\n  return Array.isArray(e);\n}\nfunction Bn(e) {\n  return typeof e == \"number\";\n}\nfunction ft(e) {\n  return typeof e == \"string\";\n}\nfunction G(e) {\n  return typeof e == \"function\";\n}\nfunction H(e) {\n  return e === Object(e) && !de(e) && !G(e);\n}\nfunction N(e) {\n  return H(e) && \"isObject3D\" in e && !!e.isObject3D;\n}\nfunction ze(e) {\n  return H(e) && \"isCamera\" in e && !!e.isCamera;\n}\nfunction In(e) {\n  return H(e) && \"isBufferGeometry\" in e && !!e.isBufferGeometry;\n}\nfunction $n(e) {\n  return H(e) && \"isMaterial\" in e && !!e.isMaterial;\n}\nfunction Hn(e) {\n  return H(e) && \"isLight\" in e && !!e.isLight;\n}\nfunction Un(e) {\n  return H(e) && \"isFog\" in e && !!e.isFog;\n}\nfunction Fn(e) {\n  return H(e) && \"isScene\" in e && !!e.isScene;\n}\nfunction re(e) {\n  return N(e) || In(e) || $n(e) || Un(e);\n}\nfunction Wn(e) {\n  return H(e) && !!e.isPrimitive;\n}\nconst dt = (e, t) => {\n  for (const n of Object.keys(t))\n    t[n] instanceof Object && Object.assign(t[n], dt(e[n], t[n]));\n  return Object.assign(e || {}, t), e;\n}, Nn = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\", zn = /* @__PURE__ */ Yn(Nn);\nfunction Ge(e) {\n  return e && e.nodeType === 1;\n}\nfunction oe(e) {\n  return e.replace(/-([a-z])/g, (t, n) => n.toUpperCase());\n}\nconst Gn = /\\B([A-Z])/g;\nfunction Vn(e) {\n  return e.replace(Gn, \"-$1\").toLowerCase();\n}\nfunction Yn(e, t) {\n  const n = /* @__PURE__ */ Object.create(null), r = e.split(\",\");\n  for (let s = 0; s < r.length; s++)\n    n[r[s]] = !0;\n  return (s) => !!n[s];\n}\nconst Ve = (e, t) => {\n  if (!t)\n    return;\n  const n = Array.isArray(t) ? t : t.match(/([^[.\\]])+/g);\n  return n == null ? void 0 : n.reduce((r, s) => r && r[s], e);\n}, qn = (e, t, n) => {\n  const r = Array.isArray(t) ? t : t.match(/([^[.\\]])+/g);\n  r && r.reduce((s, l, i) => (s[l] === void 0 && (s[l] = {}), i === r.length - 1 && (s[l] = n), s[l]), e);\n};\nfunction pt(e, t) {\n  if (Ge(e) && Ge(t)) {\n    const s = e.attributes, l = t.attributes;\n    return s.length !== l.length ? !1 : Array.from(s).every(({ name: i, value: a }) => t.getAttribute(i) === a);\n  }\n  if (e === t)\n    return !0;\n  if (e === null || typeof e != \"object\" || t === null || typeof t != \"object\")\n    return !1;\n  const n = Object.keys(e), r = Object.keys(t);\n  if (n.length !== r.length)\n    return !1;\n  for (const s of n)\n    if (!r.includes(s) || !pt(e[s], t[s]))\n      return !1;\n  return !0;\n}\nfunction Kn(e, t) {\n  if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length)\n    return !1;\n  for (let n = 0; n < e.length; n++)\n    if (!pt(e[n], t[n]))\n      return !1;\n  return !0;\n}\nconst Jn = Array.isArray;\nfunction Qn(e, t, n, r) {\n  const s = (c) => {\n    if (c.uuid === t)\n      return c;\n    for (const o of c.children) {\n      const f = s(o);\n      if (f)\n        return f;\n    }\n  }, l = s(e);\n  if (!l) {\n    console.warn(\"Object with UUID not found in the scene.\");\n    return;\n  }\n  let i = l;\n  for (let c = 0; c < n.length - 1; c++)\n    if (i[n[c]] !== void 0)\n      i = i[n[c]];\n    else {\n      console.warn(`Property path is not valid: ${n.join(\".\")}`);\n      return;\n    }\n  const a = n[n.length - 1];\n  i[a] !== void 0 ? i[a] = r : console.warn(`Property path is not valid: ${n.join(\".\")}`);\n}\nfunction Xn(e) {\n  const t = new at({\n    color: 11003607,\n    // Highlight color, e.g., yellow\n    transparent: !0,\n    opacity: 0.2,\n    depthTest: !1,\n    // So the highlight is always visible\n    side: It\n    // To e\n  });\n  return new jn(e.geometry.clone(), t);\n}\nfunction Zn(e) {\n  var n;\n  let t = e.value;\n  return e.value && ((n = e.value) != null && n.isMesh) && (t = e.value.position), Array.isArray(e.value) && (t = new Ae(...t)), t;\n}\nfunction er(e) {\n  return \"map\" in e;\n}\nfunction Ye(e) {\n  er(e) && e.map && e.map.dispose(), e.dispose();\n}\nfunction mt(e) {\n  var n, r;\n  if (e.parent && ((n = e.removeFromParent) == null || n.call(e)), delete e.__tres, [...e.children].forEach((s) => mt(s)), !(e instanceof st)) {\n    const s = e;\n    e && ((r = e.dispose) == null || r.call(e)), s.geometry && (s.geometry.dispose(), delete s.geometry), Array.isArray(s.material) ? (s.material.forEach((l) => Ye(l)), delete s.material) : s.material && (Ye(s.material), delete s.material);\n  }\n}\nfunction tr(e, t) {\n  let n = 0;\n  for (let r = 0; r < e.length; r++)\n    t(e[r], r) && (e[n] = e[r], n++);\n  return e.length = n, e;\n}\nfunction Pe(e, t) {\n  let n = e;\n  if (t.includes(\"-\")) {\n    const r = t.split(\"-\");\n    let s = r.shift();\n    for (; n && r.length; )\n      s in n ? (n = n[s], s = r.shift()) : s = qe(s, r.shift());\n    return { target: n, key: qe(s, ...r) };\n  } else\n    return { target: n, key: t };\n}\nfunction qe(...e) {\n  return e.map((t, n) => n === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)).join(\"\");\n}\nconst Ke = /-\\d+$/;\nfunction nr(e, t, n) {\n  if (ft(n)) {\n    if (Ke.test(n)) {\n      const l = n.replace(Ke, \"\"), { target: i, key: a } = Pe(e, l);\n      if (!Array.isArray(i[a])) {\n        const c = i[a], o = [];\n        o.__tresDetach = () => {\n          o.every((f) => Me(f)) && (i[a] = c);\n        }, i[a] = o;\n      }\n    }\n    const { target: r, key: s } = Pe(e, n);\n    t.__tres.previousAttach = r[s], r[s] = Q(t);\n  } else\n    t.__tres.previousAttach = n(e, t);\n}\nfunction rr(e, t, n) {\n  var r, s, l;\n  if (ft(n)) {\n    const { target: i, key: a } = Pe(e, n), c = t.__tres.previousAttach;\n    c === void 0 ? delete i[a] : i[a] = c, \"__tresDetach\" in i && i.__tresDetach();\n  } else\n    (s = (r = t.__tres) == null ? void 0 : r.previousAttach) == null || s.call(r, e, t);\n  (l = t.__tres) == null || delete l.previousAttach;\n}\nfunction z(e, t, n) {\n  const r = e;\n  return r.__tres = {\n    type: \"unknown\",\n    eventCount: 0,\n    root: n,\n    handlers: {},\n    memoizedProps: {},\n    objects: [],\n    parent: null,\n    previousAttach: null,\n    ...t\n  }, r.__tres.attach || (r.isMaterial ? r.__tres.attach = \"material\" : r.isBufferGeometry ? r.__tres.attach = \"geometry\" : r.isFog && (r.__tres.attach = \"fog\")), r;\n}\nfunction ht(e) {\n  var n;\n  const t = (n = e == null ? void 0 : e.__tres) == null ? void 0 : n.root;\n  t && t.render && t.render.canBeInvalidated.value && t.invalidate();\n}\nfunction or(e, t, n) {\n  var s;\n  if (!G(e.setPixelRatio))\n    return;\n  let r = 0;\n  if (de(n) && n.length >= 2) {\n    const [l, i] = n;\n    r = it.clamp(t, l, i);\n  } else Bn(n) ? r = n : r = t;\n  r !== ((s = e.getPixelRatio) == null ? void 0 : s.call(e)) && e.setPixelRatio(r);\n}\nfunction sr(e, t, n, r, s) {\n  const l = [...t.__tres.objects], i = Q(t);\n  if (e = Q(e), i === e)\n    return !0;\n  const a = z(e, t.__tres ?? {}, s), c = t.parent ?? t.__tres.parent ?? null, o = { ...t.__tres.memoizedProps };\n  delete o.object;\n  for (const f of l)\n    gt(f, s), vt(f, s);\n  i.__tres.objects = [], r.remove(t);\n  for (const [f, y] of Object.entries(o))\n    r.patchProp(a, f, a[f], y);\n  n(e), r.insert(t, c);\n  for (const f of l)\n    r.insert(f, t);\n  return !0;\n}\nfunction Q(e) {\n  return Wn(e) ? (e.object.__tres = e.__tres, e.object) : e;\n}\nfunction gt(e, t) {\n  var r, s, l, i;\n  const n = ((r = e.__tres) == null ? void 0 : r.parent) || t.scene.value;\n  e.__tres && (e.__tres.parent = null), n && n.__tres && \"objects\" in n.__tres && tr(n.__tres.objects, (a) => a !== e), (s = e.__tres) != null && s.attach ? rr(n, e, e.__tres.attach) : ((i = (l = e.parent) == null ? void 0 : l.remove) == null || i.call(l, Q(e)), e.parent = null);\n}\nfunction vt(e, t) {\n  var n;\n  (n = e.traverse) == null || n.call(e, (r) => {\n    var s;\n    t.deregisterCamera(r), (s = t.eventManager) == null || s.deregisterPointerMissedObject(r);\n  }), t.deregisterCamera(e), ht(e);\n}\nasync function ir(e, t) {\n  const n = new $t(t), r = (s) => new Promise((l, i) => {\n    n.load(\n      s,\n      (a) => l(a),\n      () => null,\n      () => {\n        i(new Error(\"[useTextures] - Failed to load texture\"));\n      }\n    );\n  });\n  if (Jn(e)) {\n    const s = await Promise.all(e.map((l) => r(l)));\n    return e.length > 1 ? s : s[0];\n  } else {\n    const {\n      map: s,\n      displacementMap: l,\n      normalMap: i,\n      roughnessMap: a,\n      metalnessMap: c,\n      aoMap: o,\n      alphaMap: f,\n      matcap: y\n    } = e;\n    return {\n      map: s ? await r(s) : null,\n      displacementMap: l ? await r(l) : null,\n      normalMap: i ? await r(i) : null,\n      roughnessMap: a ? await r(a) : null,\n      metalnessMap: c ? await r(c) : null,\n      aoMap: o ? await r(o) : null,\n      alphaMap: f ? await r(f) : null,\n      matcap: y ? await r(y) : null\n    };\n  }\n}\nconst qr = /* @__PURE__ */ fe({\n  __name: \"component\",\n  props: {\n    map: {},\n    displacementMap: {},\n    normalMap: {},\n    roughnessMap: {},\n    metalnessMap: {},\n    aoMap: {},\n    alphaMap: {},\n    matcap: {}\n  },\n  async setup(e) {\n    let t, n;\n    const r = e, s = ([t, n] = nt(() => Se(ir(r))), t = await t, n(), t);\n    return (l, i) => rt(l.$slots, \"default\", { textures: W(s) });\n  }\n}), ar = ({ sizes: e }) => {\n  const t = I([]), n = K(\n    () => t.value[0]\n  ), r = (i) => {\n    const a = i instanceof Ht ? i : t.value.find((o) => o.uuid === i);\n    if (!a)\n      return;\n    const c = t.value.filter(({ uuid: o }) => o !== a.uuid);\n    t.value = [a, ...c];\n  }, s = (i, a = !1) => {\n    if (ze(i)) {\n      const c = i;\n      if (t.value.some(({ uuid: o }) => o === c.uuid))\n        return;\n      a ? r(c) : t.value.push(c);\n    }\n  }, l = (i) => {\n    if (ze(i)) {\n      const a = i;\n      t.value = t.value.filter(({ uuid: c }) => c !== a.uuid);\n    }\n  };\n  return xe(() => {\n    e.aspectRatio.value && t.value.forEach((i) => {\n      !i.manual && (i instanceof be || lr(i)) && (i instanceof be ? i.aspect = e.aspectRatio.value : (i.left = e.width.value * -0.5, i.right = e.width.value * 0.5, i.top = e.height.value * 0.5, i.bottom = e.height.value * -0.5), i.updateProjectionMatrix());\n    });\n  }), J(() => {\n    t.value = [];\n  }), {\n    camera: n,\n    cameras: t,\n    registerCamera: s,\n    deregisterCamera: l,\n    setCameraActive: r\n  };\n};\nfunction lr(e) {\n  return e.hasOwnProperty(\"isOrthographicCamera\") && e.isOrthographicCamera;\n}\nconst Kr = !0, pe = \"[TresJS â–² â–  â—] \";\nfunction cr(...e) {\n  typeof e[0] == \"string\" ? e[0] = pe + e[0] : e.unshift(pe), console.error(...e);\n}\nfunction ur(...e) {\n  typeof e[0] == \"string\" ? e[0] = pe + e[0] : e.unshift(pe), console.warn(...e);\n}\nfunction fr(e, t) {\n}\nfunction V() {\n  return {\n    logError: cr,\n    logWarning: ur,\n    logMessage: fr\n  };\n}\nconst Ce = I({}), Ee = (e) => Object.assign(Ce.value, e);\nfunction ye() {\n  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set();\n  let n = 0, r = !1;\n  const s = () => {\n    const o = Array.from(e.entries()).sort((f, y) => {\n      const u = f[1].priority - y[1].priority;\n      return u === 0 ? f[1].addI - y[1].addI : u;\n    });\n    t.clear(), o.forEach((f) => t.add(f[0]));\n  }, l = (o) => {\n    e.delete(o), t.delete(o);\n  };\n  return { on: (o, f = 0) => {\n    e.set(o, { priority: f, addI: n++ });\n    const y = () => l(o);\n    return nn(y), r = !0, {\n      off: y\n    };\n  }, off: l, trigger: (...o) => {\n    r && (s(), r = !1), t.forEach((f) => f(...o));\n  }, dispose: () => {\n    e.clear(), t.clear();\n  }, get count() {\n    return e.size;\n  } };\n}\nfunction dr() {\n  let e = !0, t = !0, n = !1;\n  const r = new lt(!1), s = I(r.running), l = I(!1);\n  let i;\n  const a = it.generateUUID();\n  let c = null;\n  const o = ye(), f = ye(), y = ye();\n  E();\n  let u = {};\n  function v(M) {\n    u = M;\n  }\n  function h(M, A, p = 0) {\n    switch (A) {\n      case \"before\":\n        return o.on(M, p);\n      case \"render\":\n        return c || (c = M), f.dispose(), f.on(M);\n      case \"after\":\n        return y.on(M, p);\n    }\n  }\n  function g() {\n    t && (t = !1, E(), b());\n  }\n  function d() {\n    t = !0, E(), cancelAnimationFrame(i);\n  }\n  function _() {\n    n = !1, E();\n  }\n  function P() {\n    n = !0, E();\n  }\n  function C() {\n    l.value = !0;\n  }\n  function T() {\n    l.value = !1;\n  }\n  function b() {\n    if (!e) {\n      i = requestAnimationFrame(b);\n      return;\n    }\n    const M = r.getDelta(), A = r.getElapsedTime(), p = {\n      camera: W(u.camera),\n      scene: W(u.scene),\n      renderer: W(u.renderer),\n      raycaster: W(u.raycaster),\n      controls: W(u.controls),\n      invalidate: u.invalidate,\n      advance: u.advance\n    }, w = { delta: M, elapsed: A, clock: r, ...p };\n    s.value && o.trigger(w), l.value || (f.count ? f.trigger(w) : c && c(w)), s.value && y.trigger(w), i = requestAnimationFrame(b);\n  }\n  function E() {\n    const M = !t && !n;\n    r.running !== M && (r.running ? r.stop() : r.start()), s.value = r.running;\n  }\n  return {\n    loopId: a,\n    register: (M, A, p) => h(M, A, p),\n    start: g,\n    stop: d,\n    pause: P,\n    resume: _,\n    pauseRender: C,\n    resumeRender: T,\n    isRenderPaused: l,\n    isActive: s,\n    setContext: v,\n    setReady: (M) => e = M\n  };\n}\nfunction ke(e) {\n  let t = 0;\n  return e.traverse((n) => {\n    if (n.isMesh && n.geometry && n.type !== \"HightlightMesh\") {\n      const r = n.geometry, s = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, l = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, i = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, c = s + l + i + a;\n      t += c;\n    }\n  }), t;\n}\nfunction pr(e) {\n  return (e / 1024).toFixed(2);\n}\nconst mr = Number.parseInt(Ut.replace(\"dev\", \"\"));\nfunction Jr(e) {\n  return typeof e == \"number\" ? [e, e, e] : e instanceof Ae ? [e.x, e.y, e.z] : e;\n}\nfunction hr(e) {\n  return e instanceof Z ? e : Array.isArray(e) ? new Z(...e) : new Z(e);\n}\nconst se = {\n  realistic: {\n    shadows: !0,\n    physicallyCorrectLights: !0,\n    outputColorSpace: Ft,\n    toneMapping: ct,\n    toneMappingExposure: 3,\n    shadowMap: {\n      enabled: !0,\n      type: Wt\n    }\n  },\n  flat: {\n    toneMapping: Nt,\n    toneMappingExposure: 1\n  }\n};\nfunction gr({\n  canvas: e,\n  options: t,\n  contextParts: { sizes: n, render: r, invalidate: s, advance: l }\n}) {\n  const i = K(() => ({\n    alpha: x(t.alpha) ?? !0,\n    depth: x(t.depth),\n    canvas: rn(e),\n    context: x(t.context),\n    stencil: x(t.stencil),\n    antialias: x(t.antialias) ?? !0,\n    precision: x(t.precision),\n    powerPreference: x(t.powerPreference),\n    premultipliedAlpha: x(t.premultipliedAlpha),\n    preserveDrawingBuffer: x(t.preserveDrawingBuffer),\n    logarithmicDepthBuffer: x(t.logarithmicDepthBuffer),\n    failIfMajorPerformanceCaveat: x(t.failIfMajorPerformanceCaveat)\n  })), a = $(new ge(i.value));\n  function c() {\n    t.renderMode === \"on-demand\" && s();\n  }\n  ae(i, () => {\n    a.value.dispose(), a.value = new ge(i.value), c();\n  }), ae([n.width, n.height], () => {\n    a.value.setSize(n.width.value, n.height.value), c();\n  }, {\n    immediate: !0\n  }), ae(() => t.clearColor, c);\n  const { pixelRatio: o } = on(), { logError: f } = V(), u = (() => {\n    const h = new ge(), g = {\n      shadowMap: {\n        enabled: h.shadowMap.enabled,\n        type: h.shadowMap.type\n      },\n      toneMapping: h.toneMapping,\n      toneMappingExposure: h.toneMappingExposure,\n      outputColorSpace: h.outputColorSpace\n    };\n    return h.dispose(), g;\n  })(), v = x(t.renderMode);\n  return v === \"on-demand\" && s(), v === \"manual\" && setTimeout(() => {\n    l();\n  }, 100), xe(() => {\n    const h = x(t.preset);\n    h && (h in se || f(`Renderer Preset must be one of these: ${Object.keys(se).join(\", \")}`), dt(a.value, se[h])), or(a.value, o.value, x(t.dpr)), v === \"always\" && (r.frames.value = Math.max(1, r.frames.value));\n    const g = (P, C) => {\n      const T = x(P), b = () => {\n        if (h)\n          return Ve(se[h], C);\n      };\n      if (T !== void 0)\n        return T;\n      const E = b();\n      return E !== void 0 ? E : Ve(u, C);\n    }, d = (P, C) => qn(a.value, C, g(P, C));\n    d(t.shadows, \"shadowMap.enabled\"), d(t.toneMapping ?? ct, \"toneMapping\"), d(t.shadowMapType, \"shadowMap.type\"), mr < 150 && d(!t.useLegacyLights, \"physicallyCorrectLights\"), d(t.outputColorSpace, \"outputColorSpace\"), d(t.toneMappingExposure, \"toneMappingExposure\");\n    const _ = g(t.clearColor, \"clearColor\");\n    _ && a.value.setClearColor(\n      _ ? hr(_) : new Z(0)\n      // default clear color is not easily/efficiently retrievable from three\n    );\n  }), J(() => {\n    a.value.dispose(), a.value.forceContextLoss();\n  }), {\n    renderer: a\n  };\n}\nfunction vr(e, t, n = 10) {\n  const r = x(e) ? sn() : an(K(() => x(t).parentElement)), s = we(Ne(r.width, n)), l = we(Ne(r.height, n)), i = K(() => s.value / l.value);\n  return {\n    height: l,\n    width: s,\n    aspectRatio: i\n  };\n}\nconst yr = (e, t) => {\n  const n = K(() => t.renderer.value.domElement), r = $([]), { x: s, y: l } = ln({ target: n });\n  let i = 0;\n  const { width: a, height: c, top: o, left: f } = cn(n), y = ({ x: m, y: S }) => {\n    if (n.value)\n      return {\n        x: (m - f.value) / a.value * 2 - 1,\n        y: -((S - o.value) / c.value) * 2 + 1\n      };\n  }, u = ({ x: m, y: S }) => {\n    if (t.camera.value)\n      return t.raycaster.value.setFromCamera(new ve(m, S), t.camera.value), r.value = t.raycaster.value.intersectObjects(e.value, !0), r.value;\n  }, v = (m) => {\n    const S = y({\n      x: (m == null ? void 0 : m.clientX) ?? s.value,\n      y: (m == null ? void 0 : m.clientY) ?? l.value\n    });\n    return S ? u(S) || [] : [];\n  }, h = D(), g = D(), d = D(), _ = D(), P = D(), C = D(), T = D(), b = D();\n  function E(m) {\n    const S = {};\n    for (const U in m)\n      typeof U != \"function\" && (S[U] = m[U]);\n    return S;\n  }\n  const M = (m, S) => {\n    var Be, Ie, $e;\n    const U = E(S), ne = new Ae(S == null ? void 0 : S.clientX, S == null ? void 0 : S.clientY, 0).unproject((Be = t.camera) == null ? void 0 : Be.value);\n    m.trigger({\n      ...U,\n      intersections: r.value,\n      // The unprojectedPoint is wrong, math needs to be fixed\n      unprojectedPoint: ne,\n      ray: (Ie = t.raycaster) == null ? void 0 : Ie.value.ray,\n      camera: ($e = t.camera) == null ? void 0 : $e.value,\n      sourceEvent: S,\n      delta: i,\n      stopPropagating: !1\n    });\n  };\n  let A;\n  const p = (m) => {\n    v(m), M(d, m), A = m;\n  }, w = () => {\n    A && p(A);\n  };\n  let k, L, R;\n  const j = (m) => {\n    var S;\n    k = (S = r.value[0]) == null ? void 0 : S.object, i = 0, L = new ve(\n      (m == null ? void 0 : m.clientX) ?? s.value,\n      (m == null ? void 0 : m.clientY) ?? l.value\n    ), M(P, m);\n  };\n  let O, Y = !1;\n  const Re = (m) => {\n    var S, U, ne;\n    m instanceof PointerEvent && (r.value.length === 0 && M(C, m), k === ((S = r.value[0]) == null ? void 0 : S.object) && (R = new ve(\n      (m == null ? void 0 : m.clientX) ?? s.value,\n      (m == null ? void 0 : m.clientY) ?? l.value\n    ), i = L == null ? void 0 : L.distanceTo(R), m.button === 0 ? (M(h, m), O === ((U = r.value[0]) == null ? void 0 : U.object) ? Y = !0 : (O = (ne = r.value[0]) == null ? void 0 : ne.object, Y = !1)) : m.button === 2 && M(T, m)), M(_, m));\n  }, Oe = (m) => {\n    Y && (M(g, m), O = void 0, Y = !1);\n  }, De = (m) => M(d, m), je = (m) => M(b, m);\n  return n.value.addEventListener(\"pointerup\", Re), n.value.addEventListener(\"pointerdown\", j), n.value.addEventListener(\"pointermove\", p), n.value.addEventListener(\"pointerleave\", De), n.value.addEventListener(\"dblclick\", Oe), n.value.addEventListener(\"wheel\", je), J(() => {\n    n != null && n.value && (n.value.removeEventListener(\"pointerup\", Re), n.value.removeEventListener(\"pointerdown\", j), n.value.removeEventListener(\"pointermove\", p), n.value.removeEventListener(\"pointerleave\", De), n.value.removeEventListener(\"dblclick\", Oe), n.value.removeEventListener(\"wheel\", je));\n  }), {\n    intersects: r,\n    onClick: (m) => h.on(m).off,\n    onDblClick: (m) => g.on(m).off,\n    onContextMenu: (m) => T.on(m).off,\n    onPointerMove: (m) => d.on(m).off,\n    onPointerUp: (m) => _.on(m).off,\n    onPointerDown: (m) => P.on(m).off,\n    onPointerMissed: (m) => C.on(m).off,\n    onWheel: (m) => b.on(m).off,\n    forceUpdate: w\n  };\n};\nfunction _e(e, t) {\n  if (Array.isArray(e))\n    for (const n of e)\n      n(t);\n  typeof e == \"function\" && e(t);\n}\nfunction _r(e, t, n) {\n  var A;\n  const r = $(), s = $();\n  e && (r.value = e), t && (s.value = t);\n  const l = (p) => {\n    var w;\n    return ((w = p.__tres) == null ? void 0 : w.eventCount) > 0;\n  }, i = (p) => {\n    var w;\n    return ((w = p.children) == null ? void 0 : w.some((k) => i(k))) || l(p);\n  }, a = $(((A = r.value) == null ? void 0 : A.children).filter(i) || []);\n  function c(p, w) {\n    const k = [], L = () => w.stopPropagating = !0;\n    w.stopPropagation = L;\n    for (const R of w == null ? void 0 : w.intersections) {\n      if (w.stopPropagating)\n        return;\n      w = { ...w, ...R };\n      const { object: j } = R;\n      w.eventObject = j, _e(j[p], w), k.push(j);\n      let O = j.parent;\n      for (; O !== null && !w.stopPropagating && !k.includes(O); )\n        w.eventObject = O, _e(O[p], w), k.push(O), O = O.parent;\n      const Y = Vn(p.slice(2));\n      n(Y, { intersection: R, event: w });\n    }\n  }\n  const {\n    onClick: o,\n    onDblClick: f,\n    onContextMenu: y,\n    onPointerMove: u,\n    onPointerDown: v,\n    onPointerUp: h,\n    onPointerMissed: g,\n    onWheel: d,\n    forceUpdate: _\n  } = yr(a, t);\n  h((p) => c(\"onPointerUp\", p)), v((p) => c(\"onPointerDown\", p)), o((p) => c(\"onClick\", p)), f((p) => c(\"onDoubleClick\", p)), y((p) => c(\"onContextMenu\", p)), d((p) => c(\"onWheel\", p));\n  let P = [];\n  u((p) => {\n    const w = p.intersections.map(({ object: L }) => L), k = p.intersections;\n    P.forEach(({ object: L }) => {\n      w.includes(L) || (p.intersections = P, c(\"onPointerLeave\", p), c(\"onPointerOut\", p));\n    }), p.intersections = k, p.intersections.forEach(({ object: L }) => {\n      P.includes(L) || (c(\"onPointerEnter\", p), c(\"onPointerOver\", p));\n    }), c(\"onPointerMove\", p), P = p.intersections;\n  });\n  const C = [];\n  g((p) => {\n    const w = () => p.stopPropagating = !0;\n    p.stopPropagation = w, C.forEach((k) => {\n      p.stopPropagating || (p.eventObject = k, _e(k.onPointerMissed, p));\n    }), n(\"pointer-missed\", { event: p });\n  });\n  function T(p) {\n    re(p) && N(p) && a.value.push(p);\n  }\n  function b(p) {\n    if (re(p) && N(p)) {\n      const w = a.value.indexOf(p);\n      w > -1 && a.value.splice(w, 1);\n    }\n  }\n  function E(p) {\n    re(p) && N(p) && p.onPointerMissed && C.push(p);\n  }\n  function M(p) {\n    if (re(p) && N(p)) {\n      const w = C.indexOf(p);\n      w > -1 && C.splice(w, 1);\n    }\n  }\n  return t.eventManager = {\n    forceUpdate: _,\n    registerObject: T,\n    deregisterObject: b,\n    registerPointerMissedObject: E,\n    deregisterPointerMissedObject: M\n  }, {\n    forceUpdate: _,\n    registerObject: T,\n    deregisterObject: b,\n    registerPointerMissedObject: E,\n    deregisterPointerMissedObject: M\n  };\n}\nfunction wr(e, t, n = 100) {\n  n = n <= 0 ? 100 : n;\n  const r = D(), s = /* @__PURE__ */ new Set();\n  let l = !1, i = !1, a = null;\n  function c() {\n    a && clearTimeout(a), !i && !l && e() ? (r.trigger(t), s.forEach((u) => u()), s.clear(), l = !0) : !i && !l && (a = setTimeout(c, n));\n  }\n  function o() {\n    i = !0, a && clearTimeout(a);\n  }\n  c();\n  const f = (u, ...v) => {\n    u(...v);\n  };\n  return {\n    on: (u) => {\n      if (l)\n        return f(u, t), { off: () => {\n        } };\n      {\n        const v = r.on(u);\n        return s.add(v.off), r.on(u);\n      }\n    },\n    off: r.off,\n    trigger: r.trigger,\n    cancel: o\n  };\n}\nconst ee = /* @__PURE__ */ new WeakMap();\nfunction yt(e) {\n  if (e = e || me(), ee.has(e))\n    return ee.get(e);\n  const t = 100, n = Date.now(), l = wr(() => {\n    if (Date.now() - n >= t)\n      return !0;\n    {\n      const i = e.renderer.value, a = (i == null ? void 0 : i.domElement) || { width: 0, height: 0 };\n      return !!(i && a.width > 0 && a.height > 0);\n    }\n  }, e);\n  return ee.set(e, l), l;\n}\nfunction Qr(e) {\n  const t = me();\n  if (t)\n    return ee.has(t) ? ee.get(t).on(e) : yt(t).on(e);\n}\nfunction br({\n  scene: e,\n  canvas: t,\n  windowSize: n,\n  rendererOptions: r,\n  emit: s\n}) {\n  const l = $(e), i = vr(n, t), {\n    camera: a,\n    cameras: c,\n    registerCamera: o,\n    deregisterCamera: f,\n    setCameraActive: y\n  } = ar({ sizes: i, scene: e }), u = {\n    mode: I(r.renderMode || \"always\"),\n    priority: I(0),\n    frames: I(0),\n    maxFrames: 60,\n    canBeInvalidated: K(() => u.mode.value === \"on-demand\" && u.frames.value === 0)\n  };\n  function v(R = 1) {\n    r.renderMode === \"on-demand\" && (u.frames.value = Math.min(u.maxFrames, u.frames.value + R));\n  }\n  function h() {\n    r.renderMode === \"manual\" && (u.frames.value = 1);\n  }\n  const { renderer: g } = gr(\n    {\n      scene: e,\n      canvas: t,\n      options: r,\n      emit: s,\n      // TODO: replace contextParts with full ctx at https://github.com/Tresjs/tres/issues/516\n      contextParts: { sizes: i, camera: a, render: u, invalidate: v, advance: h }\n    }\n  ), d = {\n    sizes: i,\n    scene: l,\n    camera: a,\n    cameras: we(c),\n    renderer: g,\n    raycaster: $(new zt()),\n    controls: I(null),\n    perf: {\n      maxFrames: 160,\n      fps: {\n        value: 0,\n        accumulator: []\n      },\n      memory: {\n        currentMem: 0,\n        allocatedMem: 0,\n        accumulator: []\n      }\n    },\n    render: u,\n    advance: h,\n    extend: Ee,\n    invalidate: v,\n    registerCamera: o,\n    setCameraActive: y,\n    deregisterCamera: f,\n    loop: dr()\n  };\n  le(\"useTres\", d), d.scene.value.__tres = {\n    root: d\n  }, d.loop.register(() => {\n    a.value && u.frames.value > 0 && (g.value.render(e, a.value), s(\"render\", d.renderer.value)), u.priority.value = 0, u.mode.value === \"always\" ? u.frames.value = 1 : u.frames.value = Math.max(0, u.frames.value - 1);\n  }, \"render\");\n  const { on: _, cancel: P } = yt(d);\n  d.loop.setReady(!1), d.loop.start(), _(() => {\n    s(\"ready\", d), d.loop.setReady(!0), _r(e, d, s);\n  }), J(() => {\n    P(), d.loop.stop();\n  });\n  const C = 100, T = un({ every: C }), { isSupported: b, memory: E } = fn({ interval: C }), M = 160;\n  let A = performance.now();\n  const p = ({ timestamp: R }) => {\n    d.scene.value && (d.perf.memory.allocatedMem = ke(d.scene.value)), R - A >= C && (A = R, d.perf.fps.accumulator.push(T.value), d.perf.fps.accumulator.length > M && d.perf.fps.accumulator.shift(), d.perf.fps.value = T.value, b.value && E.value && (d.perf.memory.accumulator.push(E.value.usedJSHeapSize / 1024 / 1024), d.perf.memory.accumulator.length > M && d.perf.memory.accumulator.shift(), d.perf.memory.currentMem = d.perf.memory.accumulator.reduce((j, O) => j + O, 0) / d.perf.memory.accumulator.length));\n  };\n  let w = 0;\n  const k = 1, { pause: L } = ut(({ delta: R }) => {\n    window.__TRES__DEVTOOLS__ && (p({ timestamp: performance.now() }), w += R, w >= k && (window.__TRES__DEVTOOLS__.cb(d), w = 0));\n  }, { immediate: !0 });\n  return J(() => {\n    L();\n  }), d;\n}\nfunction me() {\n  const e = St(\"useTres\");\n  if (!e)\n    throw new Error(\"useTresContext must be used together with useTresContextProvider\");\n  return e;\n}\nconst Xr = me;\nfunction Zr() {\n  const {\n    camera: e,\n    scene: t,\n    renderer: n,\n    loop: r,\n    raycaster: s,\n    controls: l,\n    invalidate: i,\n    advance: a\n  } = me();\n  r.setContext({\n    camera: e,\n    scene: t,\n    renderer: n,\n    raycaster: s,\n    controls: l,\n    invalidate: i,\n    advance: a\n  });\n  function c(y, u = 0) {\n    return r.register(y, \"before\", u);\n  }\n  function o(y) {\n    return r.register(y, \"render\");\n  }\n  function f(y, u = 0) {\n    return r.register(y, \"after\", u);\n  }\n  return {\n    pause: r.pause,\n    resume: r.resume,\n    pauseRender: r.pauseRender,\n    resumeRender: r.resumeRender,\n    isActive: r.isActive,\n    onBeforeRender: c,\n    render: o,\n    onAfterRender: f\n  };\n}\nconst _t = D(), wt = D(), Le = D(), te = new lt();\nlet ce = 0, ue = 0;\nconst { pause: Mr, resume: Je, isActive: Pr } = ut(\n  () => {\n    _t.trigger({ delta: ce, elapsed: ue, clock: te }), wt.trigger({ delta: ce, elapsed: ue, clock: te }), Le.trigger({ delta: ce, elapsed: ue, clock: te });\n  },\n  { immediate: !1 }\n);\nLe.on(() => {\n  ce = te.getDelta(), ue = te.getElapsedTime();\n});\nlet Qe = !1;\nconst eo = () => (Qe || (Qe = !0, Je()), {\n  onBeforeLoop: _t.on,\n  onLoop: wt.on,\n  onAfterLoop: Le.on,\n  pause: Mr,\n  resume: Je,\n  isActive: Pr\n});\nfunction to() {\n  const { logWarning: e } = V();\n  function t(l, i, a) {\n    let c = null;\n    return l.traverse((o) => {\n      o[i] === a && (c = o);\n    }), c || e(`Child with ${i} '${a}' not found.`), c;\n  }\n  function n(l, i, a) {\n    const c = [];\n    return l.traverse((o) => {\n      o[i].includes(a) && c.push(o);\n    }), c.length || e(`Children with ${i} '${a}' not found.`), c;\n  }\n  function r(l, i) {\n    return t(l, \"name\", i);\n  }\n  function s(l, i) {\n    return n(l, \"name\", i);\n  }\n  return {\n    seek: t,\n    seekByName: r,\n    seekAll: n,\n    seekAllByName: s\n  };\n}\nfunction Cr(e, t = {}, n = {}) {\n  let r = e;\n  const s = (a) => {\n    r = a;\n  };\n  let l = new Proxy({}, {});\n  const i = {\n    has(a, c) {\n      return c in t || c in r;\n    },\n    get(a, c, o) {\n      return c in t ? t[c](r) : r[c];\n    },\n    set(a, c, o) {\n      return n[c] ? n[c](o, r, l, s) : r[c] = o, !0;\n    }\n  };\n  return l = new Proxy({}, i), l;\n}\nconst { logError: Xe } = V(), Ze = [\n  \"onClick\",\n  \"onContextMenu\",\n  \"onPointerMove\",\n  \"onPointerEnter\",\n  \"onPointerLeave\",\n  \"onPointerOver\",\n  \"onPointerOut\",\n  \"onDoubleClick\",\n  \"onPointerDown\",\n  \"onPointerUp\",\n  \"onPointerCancel\",\n  \"onPointerMissed\",\n  \"onLostPointerCapture\",\n  \"onWheel\"\n], Er = (e) => {\n  const t = e.scene.value;\n  function n(o, f, y, u) {\n    if (u || (u = {}), u.args || (u.args = []), o === \"template\" || zn(o))\n      return null;\n    let v = o.replace(\"Tres\", \"\"), h;\n    if (o === \"primitive\") {\n      (!H(u.object) || xt(u.object)) && Xe(\n        \"Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>\"\n      ), v = u.object.type;\n      const g = {};\n      h = Cr(\n        u.object,\n        {\n          object: (_) => _,\n          isPrimitive: () => !0,\n          __tres: () => g\n        },\n        {\n          object: (_, P, C, T) => {\n            sr(_, C, T, { patchProp: l, remove: s, insert: r }, e);\n          },\n          __tres: (_) => {\n            Object.assign(g, _);\n          }\n        }\n      );\n    } else {\n      const g = Ce.value[v];\n      g || Xe(\n        `${v} is not defined on the THREE namespace. Use extend to add it to the catalog.`\n      ), h = new g(...u.args);\n    }\n    return h ? (h.isCamera && (u != null && u.position || h.position.set(3, 3, 3), u != null && u.lookAt || h.lookAt(0, 0, 0)), h = z(h, {\n      ...h.__tres,\n      type: v,\n      memoizedProps: u,\n      eventCount: 0,\n      primitive: o === \"primitive\",\n      attach: u.attach\n    }, e), h) : null;\n  }\n  function r(o, f) {\n    var v, h, g;\n    if (!o)\n      return;\n    f = f || t;\n    const y = o.__tres ? o : z(o, {}, e), u = f.__tres ? f : z(f, {}, e);\n    o = Q(y), f = Q(u), o.__tres && ((v = o.__tres) == null ? void 0 : v.eventCount) > 0 && ((h = e.eventManager) == null || h.registerObject(o)), e.registerCamera(o), (g = e.eventManager) == null || g.registerPointerMissedObject(o), y.__tres.attach ? nr(u, y, y.__tres.attach) : N(o) && N(u) && (u.add(o), o.dispatchEvent({ type: \"added\" })), y.__tres.parent = u, u.__tres.objects && !u.__tres.objects.includes(y) && u.__tres.objects.push(y);\n  }\n  function s(o, f) {\n    var h, g, d, _;\n    if (!o)\n      return;\n    o != null && o.__tres && ((h = o.__tres) == null ? void 0 : h.eventCount) > 0 && ((g = e.eventManager) == null || g.deregisterObject(o)), f = Me(f) ? \"default\" : f;\n    const y = (d = o.__tres) == null ? void 0 : d.dispose;\n    Me(y) || (y === null ? f = !1 : f = y);\n    const u = (_ = o.__tres) == null ? void 0 : _.primitive, v = f === \"default\" ? !u : !!f;\n    if (o.__tres && \"objects\" in o.__tres && [...o.__tres.objects].forEach((P) => s(P, f)), v && o.children && [...o.children].forEach((P) => s(P, f)), gt(o, e), vt(o, e), v && !Fn(o)) {\n      if (G(f))\n        f(o);\n      else if (G(o.dispose))\n        try {\n          o.dispose();\n        } catch {\n        }\n    }\n    \"__tres\" in o && delete o.__tres;\n  }\n  function l(o, f, y, u) {\n    var P, C;\n    if (!o)\n      return;\n    let v = o, h = f;\n    if (o.__tres && (o.__tres.memoizedProps[f] = u), f === \"attach\") {\n      const T = ((P = o.__tres) == null ? void 0 : P.parent) || o.parent;\n      s(o), z(o, { attach: u }, e), T && r(o, T);\n      return;\n    }\n    if (f === \"dispose\") {\n      o.__tres || (o = z(o, {}, e)), o.__tres.dispose = u;\n      return;\n    }\n    if (N(o) && h === \"blocks-pointer-events\") {\n      u || u === \"\" ? o[h] = u : delete o[h];\n      return;\n    }\n    Ze.includes(f) && o.__tres && (o.__tres.eventCount += 1);\n    let g = oe(h), d = v == null ? void 0 : v[g];\n    if (h === \"args\") {\n      const T = o, b = y ?? [], E = u ?? [], M = ((C = o.__tres) == null ? void 0 : C.type) || o.type;\n      M && b.length && !Kn(b, E) && (v = Object.assign(\n        T,\n        new Ce.value[M](...u)\n      ));\n      return;\n    }\n    if (v.type === \"BufferGeometry\") {\n      if (h === \"args\")\n        return;\n      v.setAttribute(\n        oe(h),\n        new Gt(...u)\n      );\n      return;\n    }\n    if (h.includes(\"-\") && d === void 0) {\n      const T = h.split(\"-\");\n      d = T.reduce((b, E) => b[oe(E)], v), h = T.pop(), g = h, d != null && d.set || (v = T.reduce((b, E) => b[oe(E)], v));\n    }\n    let _ = u;\n    if (_ === \"\" && (_ = !0), G(d)) {\n      Ze.includes(f) || (de(_) ? o[g](..._) : o[g](_)), g.startsWith(\"on\") && G(_) && (v[g] = _);\n      return;\n    }\n    !(d != null && d.set) && !G(d) ? v[g] = _ : d.constructor === _.constructor && (d != null && d.copy) ? d == null || d.copy(_) : de(_) ? d.set(..._) : !d.isColor && d.setScalar ? d.setScalar(_) : d.set(_), ht(o);\n  }\n  function i(o) {\n    var f;\n    return ((f = o == null ? void 0 : o.__tres) == null ? void 0 : f.parent) || null;\n  }\n  function a(o) {\n    const f = z(new Vt(), { type: \"Comment\" }, e);\n    return f.name = o, f;\n  }\n  function c(o) {\n    var v;\n    const f = i(o), y = ((v = f == null ? void 0 : f.__tres) == null ? void 0 : v.objects) || [], u = y.indexOf(o);\n    return u < 0 || u >= y.length - 1 ? null : y[u + 1];\n  }\n  return {\n    insert: r,\n    remove: s,\n    createElement: n,\n    patchProp: l,\n    parentNode: i,\n    createText: () => void 0,\n    createComment: a,\n    setText: () => void 0,\n    setElementText: () => void 0,\n    nextSibling: c,\n    querySelector: () => void 0,\n    setScopeId: () => void 0,\n    cloneNode: () => void 0,\n    insertStaticContent: () => void 0\n  };\n};\nfunction Tr() {\n  return bt().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction bt() {\n  return typeof navigator < \"u\" && typeof window < \"u\" ? window : typeof globalThis < \"u\" ? globalThis : {};\n}\nconst Sr = typeof Proxy == \"function\", xr = \"devtools-plugin:setup\", Ar = \"plugin:settings:set\";\nlet q, Te;\nfunction kr() {\n  var e;\n  return q !== void 0 || (typeof window < \"u\" && window.performance ? (q = !0, Te = window.performance) : typeof globalThis < \"u\" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (q = !0, Te = globalThis.perf_hooks.performance) : q = !1), q;\n}\nfunction Lr() {\n  return kr() ? Te.now() : Date.now();\n}\nclass Rr {\n  constructor(t, n) {\n    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;\n    const r = {};\n    if (t.settings)\n      for (const i in t.settings) {\n        const a = t.settings[i];\n        r[i] = a.defaultValue;\n      }\n    const s = `__vue-devtools-plugin-settings__${t.id}`;\n    let l = Object.assign({}, r);\n    try {\n      const i = localStorage.getItem(s), a = JSON.parse(i);\n      Object.assign(l, a);\n    } catch {\n    }\n    this.fallbacks = {\n      getSettings() {\n        return l;\n      },\n      setSettings(i) {\n        try {\n          localStorage.setItem(s, JSON.stringify(i));\n        } catch {\n        }\n        l = i;\n      },\n      now() {\n        return Lr();\n      }\n    }, n && n.on(Ar, (i, a) => {\n      i === this.plugin.id && this.fallbacks.setSettings(a);\n    }), this.proxiedOn = new Proxy({}, {\n      get: (i, a) => this.target ? this.target.on[a] : (...c) => {\n        this.onQueue.push({\n          method: a,\n          args: c\n        });\n      }\n    }), this.proxiedTarget = new Proxy({}, {\n      get: (i, a) => this.target ? this.target[a] : a === \"on\" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...c) => (this.targetQueue.push({\n        method: a,\n        args: c,\n        resolve: () => {\n        }\n      }), this.fallbacks[a](...c)) : (...c) => new Promise((o) => {\n        this.targetQueue.push({\n          method: a,\n          args: c,\n          resolve: o\n        });\n      })\n    });\n  }\n  async setRealTarget(t) {\n    this.target = t;\n    for (const n of this.onQueue)\n      this.target.on[n.method](...n.args);\n    for (const n of this.targetQueue)\n      n.resolve(await this.target[n.method](...n.args));\n  }\n}\nfunction Or(e, t) {\n  const n = e, r = bt(), s = Tr(), l = Sr && n.enableEarlyProxy;\n  if (s && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !l))\n    s.emit(xr, e, t);\n  else {\n    const i = l ? new Rr(n, s) : null;\n    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({\n      pluginDescriptor: n,\n      setupFn: t,\n      proxy: i\n    }), i && t(i.proxiedTarget);\n  }\n}\nfunction Dr(e, t) {\n  const n = `â–² â–  â—${e}`;\n  typeof et == \"function\" ? et(n, t) : console.log(n);\n}\nfunction et(e, t) {\n  throw new Error(e + t);\n}\nconst Mt = (e) => {\n  const t = {\n    id: e.uuid,\n    label: e.type,\n    children: [],\n    tags: []\n  };\n  e.name !== \"\" && t.tags.push({\n    label: e.name,\n    textColor: 5750629,\n    backgroundColor: 15793395\n  });\n  const n = ke(e);\n  return n > 0 && t.tags.push({\n    label: `${pr(n)} KB`,\n    textColor: 15707189,\n    backgroundColor: 16775644,\n    tooltip: \"Memory usage\"\n  }), e.type.includes(\"Light\") && (Hn(e) && t.tags.push({\n    label: `${e.intensity}`,\n    textColor: 9738662,\n    backgroundColor: 16316922,\n    tooltip: \"Intensity\"\n  }), t.tags.push({\n    label: `#${new Z(e.color).getHexString()}`,\n    textColor: 9738662,\n    backgroundColor: 16316922,\n    tooltip: \"Color\"\n  })), e.type.includes(\"Camera\") && (t.tags.push({\n    label: `${e.fov}Â°`,\n    textColor: 9738662,\n    backgroundColor: 16316922,\n    tooltip: \"Field of view\"\n  }), t.tags.push({\n    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,\n    textColor: 9738662,\n    backgroundColor: 16316922,\n    tooltip: \"Position\"\n  })), t;\n};\nfunction Pt(e, t, n = \"\") {\n  e.children.forEach((r) => {\n    if (r.type === \"HightlightMesh\" || n && !r.type.includes(n) && !r.name.includes(n))\n      return;\n    const s = Mt(r);\n    t.children.push(s), Pt(r, s, n);\n  });\n}\nconst jr = [], X = \"tres:inspector\", Br = Se({\n  sceneGraph: null\n});\nfunction Ir(e, t) {\n  Or(\n    {\n      id: \"dev.esm.tres\",\n      label: \"TresJS ðŸª\",\n      logo: \"https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg\",\n      packageName: \"tresjs\",\n      homepage: \"https://tresjs.org\",\n      componentStateTypes: jr,\n      app: e\n    },\n    (n) => {\n      typeof n.now != \"function\" && Dr(\n        \"You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\"\n      ), n.addInspector({\n        id: X,\n        label: \"TresJS ðŸª\",\n        icon: \"account_tree\",\n        treeFilterPlaceholder: \"Search instances\"\n      }), setInterval(() => {\n        n.sendInspectorTree(X);\n      }, 1e3), setInterval(() => {\n        n.notifyComponentUpdate();\n      }, 5e3), n.on.getInspectorTree((l) => {\n        if (l.inspectorId === X) {\n          const i = Mt(t.scene.value);\n          Pt(t.scene.value, i, l.filter), Br.sceneGraph = i, l.rootNodes = [i];\n        }\n      });\n      let r = null, s = null;\n      n.on.getInspectorState((l) => {\n        var i;\n        if (l.inspectorId === X) {\n          const [a] = t.scene.value.getObjectsByProperty(\"uuid\", l.nodeId);\n          if (!a)\n            return;\n          if (s && r && r.parent && s.remove(r), a.isMesh) {\n            const c = Xn(a);\n            a.add(c), r = c, s = a;\n          }\n          l.state = {\n            object: Object.entries(a).map(([c, o]) => c === \"children\" ? { key: c, value: o.filter((f) => f.type !== \"HightlightMesh\") } : { key: c, value: o, editable: !0 }).filter(({ key: c }) => c !== \"parent\")\n          }, a.isScene && (l.state.info = {\n            objects: a.children.length,\n            memory: ke(a),\n            calls: t.renderer.value.info.render.calls,\n            triangles: t.renderer.value.info.render.triangles,\n            points: t.renderer.value.info.render.points,\n            lines: t.renderer.value.info.render.lines\n          }, l.state.programs = ((i = t.renderer.value.info.programs) == null ? void 0 : i.map((c) => ({\n            key: c.name,\n            value: {\n              ...c,\n              vertexShader: c.vertexShader,\n              attributes: c.getAttributes(),\n              uniforms: c.getUniforms()\n            }\n          }))) || []);\n        }\n      }), n.on.editInspectorState((l) => {\n        l.inspectorId === X && Qn(t.scene.value, l.nodeId, l.path, l.state.value);\n      });\n    }\n  );\n}\nconst $r = [\"data-scene\", \"data-tres\"], Hr = /* @__PURE__ */ fe({\n  __name: \"TresCanvas\",\n  props: {\n    shadows: { type: Boolean, default: void 0 },\n    clearColor: {},\n    toneMapping: {},\n    shadowMapType: {},\n    useLegacyLights: { type: Boolean, default: void 0 },\n    outputColorSpace: {},\n    toneMappingExposure: {},\n    renderMode: { default: \"always\" },\n    dpr: {},\n    camera: {},\n    preset: {},\n    windowSize: { type: Boolean, default: void 0 },\n    enableProvideBridge: { type: Boolean, default: !0 },\n    context: {},\n    alpha: { type: Boolean, default: void 0 },\n    premultipliedAlpha: { type: Boolean },\n    antialias: { type: Boolean, default: void 0 },\n    stencil: { type: Boolean, default: void 0 },\n    preserveDrawingBuffer: { type: Boolean, default: void 0 },\n    powerPreference: {},\n    depth: { type: Boolean, default: void 0 },\n    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 },\n    precision: {},\n    logarithmicDepthBuffer: { type: Boolean, default: void 0 },\n    reverseDepthBuffer: { type: Boolean }\n  },\n  emits: [\n    \"render\",\n    \"click\",\n    \"double-click\",\n    \"context-menu\",\n    \"pointer-move\",\n    \"pointer-up\",\n    \"pointer-down\",\n    \"pointer-enter\",\n    \"pointer-leave\",\n    \"pointer-over\",\n    \"pointer-out\",\n    \"pointer-missed\",\n    \"wheel\",\n    \"ready\"\n  ],\n  setup(e, { expose: t, emit: n }) {\n    const r = e, s = n, l = At(), { logWarning: i } = V(), a = I(), c = $(new st()), o = He();\n    Ee(ot);\n    const f = (g, d = !1) => fe({\n      setup() {\n        var T;\n        const _ = (T = He()) == null ? void 0 : T.appContext;\n        _ && (_.app = o == null ? void 0 : o.appContext.app);\n        const P = {};\n        function C(b) {\n          b && (b.parent && C(b.parent), b.provides && Object.assign(P, b.provides));\n        }\n        return o != null && o.parent && r.enableProvideBridge && (C(o.parent), Reflect.ownKeys(P).forEach((b) => {\n          le(b, P[b]);\n        })), le(\"useTres\", g), le(\"extend\", Ee), typeof window < \"u\" && Ir(_ == null ? void 0 : _.app, g), () => Ue(Bt, null, d ? [] : l.default());\n      }\n    }), y = (g, d = !1) => {\n      const _ = f(g, d), { render: P } = jt(Er(g));\n      P(Ue(_), c.value);\n    }, u = (g, d = !1) => {\n      mt(g.scene.value), d && (g.renderer.value.dispose(), g.renderer.value.renderLists.dispose(), g.renderer.value.forceContextLoss()), c.value.__tres = {\n        root: g\n      };\n    }, v = $(null);\n    t({ context: v, dispose: () => u(v.value, !0) });\n    const h = () => {\n      u(v.value), y(v.value, !0);\n    };\n    return kt(() => {\n      const g = a;\n      v.value = br({\n        scene: c.value,\n        canvas: g,\n        windowSize: r.windowSize ?? !1,\n        rendererOptions: r,\n        emit: s\n      });\n      const { registerCamera: d, camera: _, cameras: P, deregisterCamera: C } = v.value;\n      y(v.value);\n      const T = () => {\n        const b = new be(\n          45,\n          window.innerWidth / window.innerHeight,\n          0.1,\n          1e3\n        );\n        b.position.set(3, 3, 3), b.lookAt(0, 0, 0), d(b);\n        const E = xe(() => {\n          P.value.length >= 2 && (b.removeFromParent(), C(b), E == null || E());\n        });\n      };\n      ae(\n        () => r.camera,\n        (b, E) => {\n          b && d(b), E && (E.removeFromParent(), C(E));\n        },\n        {\n          immediate: !0\n        }\n      ), _.value || (i(\n        \"No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene.\"\n      ), T());\n    }), J(h), (g, d) => (Lt(), Rt(\"canvas\", {\n      ref_key: \"canvas\",\n      ref: a,\n      \"data-scene\": c.value.uuid,\n      class: Ot(g.$attrs.class),\n      \"data-tres\": `tresjs ${W(Rn).version}`,\n      style: Dt({\n        display: \"block\",\n        width: \"100%\",\n        height: \"100%\",\n        position: g.windowSize ? \"fixed\" : \"relative\",\n        top: 0,\n        left: 0,\n        pointerEvents: \"auto\",\n        touchAction: \"none\",\n        ...g.$attrs.style\n      })\n    }, null, 14, $r));\n  }\n}), Ur = [\n  \"TresCanvas\",\n  \"TresLeches\",\n  \"TresScene\"\n], no = {\n  template: {\n    compilerOptions: {\n      isCustomElement: (e) => e.startsWith(\"Tres\") && !Ur.includes(e) || e === \"primitive\"\n    }\n  }\n}, { logWarning: Fr } = V();\nlet B = null;\nconst ro = {\n  updated: (e, t) => {\n    var s;\n    const n = Zn(t);\n    if (!n) {\n      Fr(`v-distance-to: problem with binding value: ${t.value}`);\n      return;\n    }\n    B && (B.dispose(), e.parent.remove(B));\n    const r = n.clone().sub(e.position);\n    r.normalize(), B = new Yt(r, e.position, e.position.distanceTo(n), 16776960), e.parent.add(B), console.table(\n      [\n        [\"Distance:\", e.position.distanceTo(n)],\n        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],\n        [`Destiny: ${e.name || e.type}`, `x:${n.x}, y:${n.y}, z:${n == null ? void 0 : n.z}`]\n      ]\n    );\n  },\n  unmounted: (e) => {\n    B == null || B.dispose(), e.parent.remove(B);\n  }\n};\nclass Ct extends qt {\n  constructor(t, n) {\n    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new Fe();\n    s.setAttribute(\"position\", new We(r, 3)), s.computeBoundingSphere();\n    const l = new Kt({ fog: !1 });\n    super(s, l), this.light = t, this.color = n, this.type = \"RectAreaLightHelper\";\n    const i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new Fe();\n    a.setAttribute(\"position\", new We(i, 3)), a.computeBoundingSphere(), this.add(new Jt(a, new at({ side: Qt, fog: !1 })));\n  }\n  updateMatrixWorld() {\n    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)\n      this.material.color.set(this.color), this.children[0].material.color.set(this.color);\n    else {\n      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n      const t = this.material.color, n = Math.max(t.r, t.g, t.b);\n      n > 1 && t.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);\n    }\n    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);\n  }\n  dispose() {\n    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();\n  }\n}\nconst { logWarning: tt } = V();\nlet ie, F;\nconst Wr = {\n  DirectionalLight: Xt,\n  PointLight: Zt,\n  SpotLight: en,\n  HemisphereLight: tn,\n  RectAreaLight: Ct\n}, oo = {\n  mounted: (e) => {\n    if (!e.isLight) {\n      tt(`${e.type} is not a light`);\n      return;\n    }\n    ie = Wr[e.type], e.parent.add(new ie(e, 1, e.color.getHex()));\n  },\n  updated: (e) => {\n    F = e.parent.children.find((t) => t instanceof ie), !(F instanceof Ct) && F.update();\n  },\n  unmounted: (e) => {\n    if (!e.isLight) {\n      tt(`${e.type} is not a light`);\n      return;\n    }\n    F = e.parent.children.find((t) => t instanceof ie), F && F.dispose && F.dispose(), e.parent.remove(F);\n  }\n}, so = {\n  mounted: (e, t) => {\n    if (t.arg) {\n      console.log(`v-log:${t.arg}`, e[t.arg]);\n      return;\n    }\n    console.log(\"v-log\", e);\n  }\n}, io = {\n  install(e) {\n    e.component(\"TresCanvas\", Hr);\n  }\n};\nexport {\n  Hr as TresCanvas,\n  Yr as UseLoader,\n  qr as UseTexture,\n  Ce as catalogue,\n  dr as createRenderLoop,\n  io as default,\n  mt as dispose,\n  Ee as extend,\n  Kr as isProd,\n  hr as normalizeColor,\n  Jr as normalizeVectorFlexibleParam,\n  Qr as onTresReady,\n  no as templateCompilerOptions,\n  On as trasverseObjects,\n  ar as useCamera,\n  Dn as useLoader,\n  V as useLogger,\n  Zr as useLoop,\n  yr as useRaycaster,\n  eo as useRenderLoop,\n  gr as useRenderer,\n  to as useSeek,\n  ir as useTexture,\n  Xr as useTres,\n  me as useTresContext,\n  br as useTresContextProvider,\n  _r as useTresEventManager,\n  ro as vDistanceTo,\n  oo as vLightHelper,\n  so as vLog\n};\n","/**\n * name: @tresjs/cientos\n * version: v4.3.0\n * (c) 2025\n * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres\n * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)\n */\nvar Ml = Object.defineProperty;\nvar Sl = (r, e, t) => e in r ? Ml(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar pe = (r, e, t) => Sl(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nimport * as Jn from \"three\";\nimport { TextureLoader as ai, DoubleSide as on, WebGLCubeRenderTarget as aa, HalfFloatType as Lt, CubeCamera as la, Group as Zt, Quaternion as je, Euler as vt, AudioListener as ca, Audio as Al, AudioLoader as ua, MathUtils as Ye, ShaderMaterial as bt, UniformsUtils as Dn, Vector2 as ve, Color as be, FrontSide as ss, REVISION as Ts, Vector3 as $, BufferAttribute as ut, TrianglesDrawMode as Pl, TriangleFanDrawMode as oo, TriangleStripDrawMode as ha, CompressedTexture as mi, Texture as es, RGBAFormat as ei, PropertyBinding as rn, InterpolateDiscrete as fa, Matrix4 as Ie, Scene as xs, PlaneGeometry as jt, Uniform as Se, Mesh as de, PerspectiveCamera as kt, WebGLRenderer as Rl, NearestFilter as Kn, NearestMipmapNearestFilter as da, NearestMipmapLinearFilter as pa, LinearFilter as wt, LinearMipmapNearestFilter as ma, LinearMipmapLinearFilter as Eo, ClampToEdgeWrapping as Wt, RepeatWrapping as Ln, MirroredRepeatWrapping as ga, InterpolateLinear as Mo, Plane as bs, Vector4 as at, WebGLRenderTarget as Xt, NoToneMapping as Cl, MeshBasicMaterial as $t, DataTexture as ti, RawShaderMaterial as gi, AdditiveBlending as So, Box2 as va, BufferGeometry as ht, InterleavedBuffer as Ao, InterleavedBufferAttribute as nn, UniformsLib as ni, BoxGeometry as Ht, BackSide as li, Triangle as Il, Object3D as Rt, Raycaster as ya, LineBasicMaterial as ws, CylinderGeometry as Ct, Float32BufferAttribute as gt, Line as ke, OctahedronGeometry as Mn, SphereGeometry as Ol, TorusGeometry as Ds, EventDispatcher as _a, MOUSE as Dt, TOUCH as Vt, Spherical as si, OrthographicCamera as _n, Ray as Dl, Loader as Un, LoaderUtils as qn, FileLoader as kn, MeshPhysicalMaterial as Kt, SpotLight as xa, PointLight as ro, DirectionalLight as wa, InstancedMesh as Ta, InstancedBufferAttribute as Ll, ImageBitmapLoader as kl, PointsMaterial as Nl, Material as vi, MeshStandardMaterial as Es, SkinnedMesh as Po, LineSegments as Bl, LineLoop as Ul, Points as ba, Skeleton as Ea, AnimationClip as Ma, Bone as ao, VectorKeyframeTrack as lo, NumberKeyframeTrack as co, QuaternionKeyframeTrack as uo, Interpolant as Fl, Box3 as _t, Sphere as Ms, ExtrudeGeometry as zl, Curve as Gl, MeshPhongMaterial as yi, MeshLambertMaterial as Hl, EquirectangularReflectionMapping as ho, AmbientLight as jl, Uint16BufferAttribute as Vl, Matrix3 as Cn, ShapePath as pn, DataTextureLoader as Yl, FloatType as qs, DataUtils as Ls, ShapeUtils as Wl, Shape as Xl, Path as _i, InstancedBufferGeometry as $l, InstancedInterleavedBuffer as fo, WireframeGeometry as Zl, Line3 as Kl, AlwaysStencilFunc as ql, ReplaceStencilOp as xi, AnimationMixer as Ql, KeepStencilOp as wi, NotEqualStencilFunc as $o, EqualStencilFunc as Zo, DepthTexture as Sa, EdgesGeometry as Jl, CubeTextureLoader as ec, CubeReflectionMapping as tc, ShapeGeometry as nc, DefaultLoadingManager as ks, VideoTexture as sc, Clock as ic, NoBlending as oc, Camera as rc, TangentSpaceNormalMap as ac, CatmullRomCurve3 as lc, QuadraticBezierCurve3 as cc, MeshDepthMaterial as Ko, ShaderChunk as Ti, UnsignedByteType as uc, UVMapping as hc, IcosahedronGeometry as fc } from \"three\";\nimport { defineComponent as ue, watch as J, ref as me, shallowRef as re, withAsyncContext as Tn, onUnmounted as tt, createElementBlock as ce, openBlock as ae, renderSlot as Ne, createElementVNode as ye, unref as F, getCurrentScope as dc, onScopeDispose as pc, onMounted as bn, nextTick as Ro, getCurrentInstance as Aa, isRef as ii, computed as Pe, reactive as ts, watchEffect as et, toValue as ze, isReactive as po, createVNode as ms, mergeProps as $e, toRefs as Le, shallowReactive as Pa, onBeforeUnmount as Co, useSlots as Io, createCommentVNode as an, createBlock as Oo, Fragment as Ra, renderList as Ca, useAttrs as mc, render as gc, triggerRef as vc, toRaw as qo } from \"vue\";\nimport { useLogger as xt, useLoader as Nn, useTresContext as xe, useLoop as Ve, normalizeVectorFlexibleParam as Ia, useTres as xn, extend as Oa, useTexture as Bn, normalizeColor as tn } from \"@tresjs/core\";\nfunction yc(r) {\n  const e = _c(r), t = [];\n  for (const { startFrame: n, endFrame: s, duration: i } of e)\n    if (!(i <= 0))\n      if (s < 0 || n === s) {\n        for (let o = 0; o < i; o++)\n          t.push(n);\n        continue;\n      } else {\n        const o = Math.sign(s - n);\n        for (let a = n; a !== s + o; a += o)\n          for (let l = 0; l < i; l++)\n            t.push(a);\n      }\n  return t;\n}\nfunction _c(r) {\n  let e = \"START_FRAME_IN\";\n  const t = [];\n  for (const { name: n, value: s, startI: i } of xc(r))\n    e === \"START_FRAME_IN\" ? n === \"NUMBER\" ? (t.push({\n      startFrame: s,\n      endFrame: s,\n      duration: 1\n    }), e = \"START_FRAME_OUT\") : Sn(\n      \"number\",\n      n,\n      r,\n      i\n    ) : e === \"START_FRAME_OUT\" ? n === \"COMMA\" ? e = \"START_FRAME_IN\" : n === \"HYPHEN\" ? e = \"END_FRAME_IN\" : n === \"OPEN_PAREN\" ? e = \"DURATION_IN\" : Sn(\n      '\",\", \"-\", \"(\"',\n      n,\n      r,\n      i\n    ) : e === \"END_FRAME_IN\" ? n === \"NUMBER\" ? (t[t.length - 1].endFrame = s, e = \"END_FRAME_OUT\") : Sn(\n      \"number\",\n      n,\n      r,\n      i\n    ) : e === \"END_FRAME_OUT\" ? n === \"COMMA\" ? e = \"START_FRAME_IN\" : n === \"OPEN_PAREN\" ? e = \"DURATION_IN\" : Sn(\n      \"',' or '('\",\n      n,\n      r,\n      i\n    ) : e === \"DURATION_IN\" ? n === \"NUMBER\" ? (t[t.length - 1].duration = s, e = \"DURATION_OUT\") : Sn(\n      \"number\",\n      n,\n      r,\n      i\n    ) : e === \"DURATION_OUT\" ? n === \"CLOSE_PAREN\" ? e = \"NEXT_OR_DONE\" : Sn('\"(\"', n, r, i) : e === \"NEXT_OR_DONE\" && (n === \"COMMA\" ? e = \"START_FRAME_IN\" : Sn('\",\"', n, r, i));\n  return t;\n}\nfunction xc(r) {\n  const e = [];\n  for (let t = 0; t < r.length; t++) {\n    const n = r[t];\n    if (\"0123456789\".includes(n))\n      e.length && e[e.length - 1].name === \"NUMBER\" ? (e[e.length - 1].value *= 10, e[e.length - 1].value += Number.parseInt(n)) : e.push({ name: \"NUMBER\", value: Number.parseInt(n), startI: t });\n    else {\n      if (n === \" \")\n        continue;\n      n === \",\" ? e.push({ name: \"COMMA\", value: -1, startI: t }) : n === \"(\" ? e.push({ name: \"OPEN_PAREN\", value: -1, startI: t }) : n === \")\" ? e.push({ name: \"CLOSE_PAREN\", value: -1, startI: t }) : n === \"-\" ? e.push({ name: \"HYPHEN\", value: -1, startI: t }) : wc(\"0123456789,-()\", n, r, t);\n    }\n  }\n  return e;\n}\nfunction wc(r, e, t, n) {\n  xt().logError(\n    `Cientos AnimationDefinitionParser: Unexpected character while processing animation definition: expected ${r}, got ${e}.\n${t}\n${Array.from({ length: n + 1 }).join(\" \")}^`\n  );\n}\nfunction Sn(r, e, t, n) {\n  xt().logError(\n    `Cientos AnimationDefinitionParser: Syntax error while processing animation definition: expected ${r}, got ${e}.\n${t}\n${Array.from({ length: n + 1 }).join(\" \")}^`\n  );\n}\nconst Tc = /\\d*$/, bc = /_*\\d*$/;\nfunction Ec(r) {\n  return r.replace(bc, \"\");\n}\nfunction Mc(r) {\n  const e = r.match(Tc);\n  return e ? Number.parseInt(e[e.length - 1]) : null;\n}\nasync function Sc(r, e) {\n  const t = Nn(\n    ai,\n    r\n  ), n = typeof e != \"string\" ? new Promise((s) => s(e)) : fetch(e).then((s) => s.json()).catch((s) => xt().logError(`Cientos Atlas - ${s}`));\n  return Promise.all([t, n]).then(\n    ([s, i]) => {\n      const o = Ac(\n        i,\n        s.image.width,\n        s.image.height\n      );\n      return [s, o];\n    }\n  );\n}\nfunction Ac(r, e, t) {\n  const n = typeof r == \"number\" || Array.isArray(r) ? Ic(r, e, t) : Pc(\n    r,\n    e,\n    t\n  );\n  return { frames: n, animations: Da(n) };\n}\nfunction gs(r, e, t) {\n  let n;\n  return typeof e == \"string\" ? n = Dc(r, e) : typeof e == \"number\" ? n = Qo(\n    r,\n    e,\n    e\n  ) : n = Qo(\n    r,\n    e[0],\n    e[1]\n  ), t ? n.toReversed() : n;\n}\nfunction Do() {\n  return {\n    name: \"null\",\n    width: 0,\n    height: 0,\n    offsetX: 0,\n    offsetY: 0,\n    repeatX: 0,\n    repeatY: 0\n  };\n}\nfunction Pc(r, e, t) {\n  return Array.isArray(r.frames) ? Rc(\n    r,\n    e,\n    t\n  ) : Cc(\n    r,\n    e,\n    t\n  );\n}\nfunction Rc(r, e, t) {\n  const n = 1 / e, s = 1 / t;\n  return r.frames.map((i) => ({\n    name: i.filename,\n    offsetX: i.frame.x * n,\n    offsetY: 1 - (i.frame.y + i.frame.h) * s,\n    repeatX: i.frame.w * n,\n    repeatY: i.frame.h * s,\n    width: i.frame.w,\n    height: i.frame.h\n  }));\n}\nfunction Cc(r, e, t) {\n  const n = 1 / e, s = 1 / t;\n  return Object.entries(r.frames).map(([i, o]) => ({\n    name: i,\n    offsetX: o.frame.x * n,\n    offsetY: 1 - (o.frame.y + o.frame.h) * s,\n    repeatX: o.frame.w * n,\n    repeatY: o.frame.h * s,\n    width: o.frame.w,\n    height: o.frame.h\n  }));\n}\nfunction Ic(r, e, t, n = \"default\") {\n  const [s, i] = Array.isArray(r) ? r : [r, 1], o = e / s, a = t / i, l = (s * i).toString().length, c = 1 / s, f = 1 / i, u = [];\n  let d = 0;\n  for (let h = i - 1; h >= 0; h--)\n    for (let m = 0; m < s; m++)\n      d++, u.push({\n        name: n + String(d).padStart(l, \"0\"),\n        offsetX: m * c,\n        offsetY: h * f,\n        repeatX: c,\n        repeatY: f,\n        width: o,\n        height: a\n      });\n  return u;\n}\nfunction Oc(r, e = {}) {\n  const t = Da(r.frames);\n  for (const [n, s] of Object.entries(e)) {\n    const i = gs(r, n, !1), o = yc(s);\n    for (const a of o)\n      (a < 0 || i.length <= a) && xt().logError(\n        `Cientos Atlas: Attempting to access frame index ${a} in animation ${n}, but it does not exist.`\n      );\n    t[n] = o.map((a) => i[a]);\n  }\n  r.animations = t;\n}\nfunction Dc(r, e) {\n  if (!(e in r.animations)) {\n    const t = Object.keys(r.animations).map((n) => `* ${n}\n`).join(\"\");\n    return xt().logError(\n      `Cientos Atlas: getAtlasFramesByAnimationName\nThe animation name \"${e}\" does not exist in this atlas.\nAvailable names:\n${t}`\n    ), [Do()];\n  }\n  return r.animations[e];\n}\nfunction Qo(r, e, t) {\n  if (e < 0 || r.frames.length <= e || t < 0 || r.frames.length <= t)\n    return xt().logError(\n      `Cientos Atlas: getFramesByIndex â€“ [${e}, ${t}] is out of bounds.`\n    ), [Do()];\n  const n = [], s = Math.sign(t - e);\n  if (s === 0)\n    return [r.frames[e]];\n  for (let i = e; i !== t + s; i += s)\n    n.push(r.frames[i]);\n  return n;\n}\nfunction Da(r) {\n  const e = {};\n  for (const t of r)\n    if (Mc(t.name) !== null) {\n      const n = Ec(t.name);\n      Object.prototype.hasOwnProperty.call(e, n) ? e[n].push(t) : e[n] = [t];\n    }\n  for (const t of Object.values(e))\n    t.sort((n, s) => n.name.localeCompare(s.name));\n  return e;\n}\nconst Lc = [\"scale\", \"position\"], kc = [\"map\", \"alphaTest\"], Nc = [\"scale\", \"position\"], Bc = [\"side\", \"map\", \"alphaTest\", \"depthWrite\", \"depthTest\"], Ns = 0.01, Ag = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    image: {},\n    atlas: {},\n    definitions: {},\n    fps: { default: 30 },\n    loop: { type: Boolean, default: !0 },\n    animation: { default: 0 },\n    paused: { type: Boolean, default: !1 },\n    reversed: { type: Boolean, default: !1 },\n    flipX: { type: Boolean, default: !1 },\n    resetOnEnd: { type: Boolean, default: !1 },\n    asSprite: { type: Boolean, default: !0 },\n    center: { default: () => [0.5, 0.5] },\n    alphaTest: { default: 0 },\n    depthTest: { type: Boolean, default: !0 },\n    depthWrite: { type: Boolean, default: !0 }\n  },\n  emits: [\"frame\", \"end\", \"loop\"],\n  async setup(r, { expose: e, emit: t }) {\n    let n, s;\n    const i = r, o = t, { invalidate: a } = xe();\n    J(i, () => {\n      a();\n    });\n    const l = me(0), c = me(0), f = me(0), u = me(0), d = re();\n    e({ instance: d });\n    const [h, m] = ([n, s] = Tn(() => Sc(i.image, i.atlas)), n = await n, s(), n);\n    h.matrixAutoUpdate = !1;\n    let g = gs(m, i.animation, i.reversed), v = 0.5, p = 0.5, b = 1, _ = Do(), M = null, R = 0, w = !1, E = !0;\n    Ve().onBeforeRender(({ delta: T }) => {\n      for (!i.paused && !w && (b -= T * i.fps); b <= 0; )\n        b++, R++, i.loop ? (R >= g.length && o(\"loop\", g[g.length - 1].name), R %= g.length) : R >= g.length && (w = !0, R = i.resetOnEnd ? 0 : g.length - 1, o(\"end\", g[g.length - 1].name));\n      g[R] !== _ && (_ = g[R], M = _.name, x()), E && (E = !1, h.offset.x = _.offsetX + (i.flipX ? _.repeatX : 0), h.offset.y = _.offsetY, h.repeat.x = _.repeatX * (i.flipX ? -1 : 1), h.repeat.y = _.repeatY, h.updateMatrix(), f.value = _.width * Ns, u.value = _.height * Ns, l.value = (0.5 - v) * _.width * Ns, c.value = (0.5 - p) * _.height * Ns), M && (o(\"frame\", M), M = null);\n    });\n    function x() {\n      E = !0;\n    }\n    return J(() => i.animation, (T, y) => {\n      JSON.stringify(T) !== JSON.stringify(y) && (g = gs(m, i.animation, i.reversed), R = 0, b = 1, w = !1, x());\n    }, { immediate: !0 }), J(() => i.reversed, () => {\n      R = (g.length - R - 1) % g.length, g = gs(m, i.animation, i.reversed), w && (R = i.resetOnEnd ? 0 : g.length - 1), x();\n    }), J(() => i.paused, () => {\n      w = !1;\n    }), J(() => i.loop, () => {\n      w && i.loop && (w = !1);\n    }), J(() => i.resetOnEnd, () => {\n      w && (R = i.resetOnEnd ? 0 : g.length - 1, x());\n    }), J(() => i.flipX, x), J(() => [i.center], () => {\n      [v, p] = Ia(i.center), x();\n    }, { immediate: !0 }), J(() => [i.definitions], () => {\n      Oc(m, i.definitions), g = gs(m, i.animation, i.reversed), b = 1, R = 0, x();\n    }, { immediate: !0 }), tt(() => {\n      h.dispose();\n    }), (T, y) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"groupRef\",\n      ref: d\n    }, [\n      i.asSprite ? (ae(), ce(\"TresSprite\", {\n        key: 0,\n        scale: [f.value, u.value, 1],\n        position: [l.value, c.value, 0]\n      }, [\n        ye(\"TresSpriteMaterial\", {\n          toneMapped: !1,\n          map: F(h),\n          transparent: !0,\n          alphaTest: i.alphaTest\n        }, null, 8, kc)\n      ], 8, Lc)) : (ae(), ce(\"TresMesh\", {\n        key: 1,\n        scale: [f.value, u.value, 1],\n        position: [l.value, c.value, 0]\n      }, [\n        y[0] || (y[0] = ye(\"TresPlaneGeometry\", { args: [1, 1] }, null, -1)),\n        ye(\"TresMeshBasicMaterial\", {\n          toneMapped: !1,\n          side: F(on),\n          map: F(h),\n          transparent: !0,\n          alphaTest: i.alphaTest,\n          depthWrite: i.depthWrite,\n          depthTest: i.depthTest\n        }, null, 8, Bc)\n      ], 8, Nc)),\n      Ne(T.$slots, \"default\")\n    ], 512));\n  }\n});\nfunction ci(r) {\n  return dc() ? (pc(r), !0) : !1;\n}\nfunction ct(r) {\n  return typeof r == \"function\" ? r() : F(r);\n}\nconst Uc = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst Fc = Object.prototype.toString, zc = (r) => Fc.call(r) === \"[object Object]\", wn = () => {\n};\nfunction Lo(r, e) {\n  function t(...n) {\n    return new Promise((s, i) => {\n      Promise.resolve(r(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(s).catch(i);\n    });\n  }\n  return t;\n}\nconst Gc = (r) => r();\nfunction Hc(r, e = {}) {\n  let t, n, s = wn;\n  const i = (a) => {\n    clearTimeout(a), s(), s = wn;\n  };\n  return (a) => {\n    const l = ct(r), c = ct(e.maxWait);\n    return t && i(t), l <= 0 || c !== void 0 && c <= 0 ? (n && (i(n), n = null), Promise.resolve(a())) : new Promise((f, u) => {\n      s = e.rejectOnCancel ? u : f, c && !n && (n = setTimeout(() => {\n        t && i(t), n = null, f(a());\n      }, c)), t = setTimeout(() => {\n        n && i(n), n = null, f(a());\n      }, l);\n    });\n  };\n}\nfunction La(...r) {\n  let e = 0, t, n = !0, s = wn, i, o, a, l, c;\n  !ii(r[0]) && typeof r[0] == \"object\" ? { delay: o, trailing: a = !0, leading: l = !0, rejectOnCancel: c = !1 } = r[0] : [o, a = !0, l = !0, c = !1] = r;\n  const f = () => {\n    t && (clearTimeout(t), t = void 0, s(), s = wn);\n  };\n  return (d) => {\n    const h = ct(o), m = Date.now() - e, g = () => i = d();\n    return f(), h <= 0 ? (e = Date.now(), g()) : (m > h && (l || !n) ? (e = Date.now(), g()) : a && (i = new Promise((v, p) => {\n      s = c ? p : v, t = setTimeout(() => {\n        e = Date.now(), n = !0, v(g()), f();\n      }, Math.max(0, h - m));\n    })), !l && !t && (t = setTimeout(() => n = !0, h)), n = !1, i);\n  };\n}\nfunction jc(r) {\n  return Aa();\n}\nfunction Vc(r, e = 200, t = {}) {\n  return Lo(\n    Hc(e, t),\n    r\n  );\n}\nfunction Yc(r, e = 200, t = !1, n = !0, s = !1) {\n  return Lo(\n    La(e, t, n, s),\n    r\n  );\n}\nfunction Wc(r, e, t = {}) {\n  const {\n    eventFilter: n = Gc,\n    ...s\n  } = t;\n  return J(\n    r,\n    Lo(\n      n,\n      e\n    ),\n    s\n  );\n}\nfunction ko(r, e = !0, t) {\n  jc() ? bn(r, t) : e ? r() : Ro(r);\n}\nfunction Xc(r, e, t = {}) {\n  const {\n    throttle: n = 0,\n    trailing: s = !0,\n    leading: i = !0,\n    ...o\n  } = t;\n  return Wc(\n    r,\n    e,\n    {\n      ...o,\n      eventFilter: La(n, s, i)\n    }\n  );\n}\nconst ln = Uc ? window : void 0;\nfunction gn(r) {\n  var e;\n  const t = ct(r);\n  return (e = t == null ? void 0 : t.$el) != null ? e : t;\n}\nfunction Xe(...r) {\n  let e, t, n, s;\n  if (typeof r[0] == \"string\" || Array.isArray(r[0]) ? ([t, n, s] = r, e = ln) : [e, t, n, s] = r, !e)\n    return wn;\n  Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);\n  const i = [], o = () => {\n    i.forEach((f) => f()), i.length = 0;\n  }, a = (f, u, d, h) => (f.addEventListener(u, d, h), () => f.removeEventListener(u, d, h)), l = J(\n    () => [gn(e), ct(s)],\n    ([f, u]) => {\n      if (o(), !f)\n        return;\n      const d = zc(u) ? { ...u } : u;\n      i.push(\n        ...t.flatMap((h) => n.map((m) => a(f, h, m, d)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => {\n    l(), o();\n  };\n  return ci(c), c;\n}\nfunction $c() {\n  const r = me(!1), e = Aa();\n  return e && bn(() => {\n    r.value = !0;\n  }, e), r;\n}\nfunction ka(r) {\n  const e = $c();\n  return Pe(() => (e.value, !!r()));\n}\nfunction Zc(r, e = {}) {\n  const { window: t = ln } = e, n = ka(() => t && \"matchMedia\" in t && typeof t.matchMedia == \"function\");\n  let s;\n  const i = me(!1), o = (c) => {\n    i.value = c.matches;\n  }, a = () => {\n    s && (\"removeEventListener\" in s ? s.removeEventListener(\"change\", o) : s.removeListener(o));\n  }, l = et(() => {\n    n.value && (a(), s = t.matchMedia(ct(r)), \"addEventListener\" in s ? s.addEventListener(\"change\", o) : s.addListener(o), i.value = s.matches);\n  });\n  return ci(() => {\n    l(), a(), s = void 0;\n  }), i;\n}\nfunction Kc(r, e, t = {}) {\n  const { window: n = ln, ...s } = t;\n  let i;\n  const o = ka(() => n && \"ResizeObserver\" in n), a = () => {\n    i && (i.disconnect(), i = void 0);\n  }, l = Pe(() => {\n    const u = ct(r);\n    return Array.isArray(u) ? u.map((d) => gn(d)) : [gn(u)];\n  }), c = J(\n    l,\n    (u) => {\n      if (a(), o.value && n) {\n        i = new ResizeObserver(e);\n        for (const d of u)\n          d && i.observe(d, s);\n      }\n    },\n    { immediate: !0, flush: \"post\" }\n  ), f = () => {\n    a(), c();\n  };\n  return ci(f), {\n    isSupported: o,\n    stop: f\n  };\n}\nfunction qc(r, e = { width: 0, height: 0 }, t = {}) {\n  const { window: n = ln, box: s = \"content-box\" } = t, i = Pe(() => {\n    var u, d;\n    return (d = (u = gn(r)) == null ? void 0 : u.namespaceURI) == null ? void 0 : d.includes(\"svg\");\n  }), o = me(e.width), a = me(e.height), { stop: l } = Kc(\n    r,\n    ([u]) => {\n      const d = s === \"border-box\" ? u.borderBoxSize : s === \"content-box\" ? u.contentBoxSize : u.devicePixelContentBoxSize;\n      if (n && i.value) {\n        const h = gn(r);\n        if (h) {\n          const m = h.getBoundingClientRect();\n          o.value = m.width, a.value = m.height;\n        }\n      } else if (d) {\n        const h = Array.isArray(d) ? d : [d];\n        o.value = h.reduce((m, { inlineSize: g }) => m + g, 0), a.value = h.reduce((m, { blockSize: g }) => m + g, 0);\n      } else\n        o.value = u.contentRect.width, a.value = u.contentRect.height;\n    },\n    t\n  );\n  ko(() => {\n    const u = gn(r);\n    u && (o.value = \"offsetWidth\" in u ? u.offsetWidth : e.width, a.value = \"offsetHeight\" in u ? u.offsetHeight : e.height);\n  });\n  const c = J(\n    () => gn(r),\n    (u) => {\n      o.value = u ? e.width : 0, a.value = u ? e.height : 0;\n    }\n  );\n  function f() {\n    l(), c();\n  }\n  return {\n    width: o,\n    height: a,\n    stop: f\n  };\n}\nconst Jo = 1;\nfunction Qc(r, e = {}) {\n  const {\n    throttle: t = 0,\n    idle: n = 200,\n    onStop: s = wn,\n    onScroll: i = wn,\n    offset: o = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions: a = {\n      capture: !1,\n      passive: !0\n    },\n    behavior: l = \"auto\",\n    window: c = ln,\n    onError: f = (E) => {\n      console.error(E);\n    }\n  } = e, u = me(0), d = me(0), h = Pe({\n    get() {\n      return u.value;\n    },\n    set(E) {\n      g(E, void 0);\n    }\n  }), m = Pe({\n    get() {\n      return d.value;\n    },\n    set(E) {\n      g(void 0, E);\n    }\n  });\n  function g(E, x) {\n    var T, y, A, C;\n    if (!c)\n      return;\n    const N = ct(r);\n    if (!N)\n      return;\n    (A = N instanceof Document ? c.document.body : N) == null || A.scrollTo({\n      top: (T = ct(x)) != null ? T : m.value,\n      left: (y = ct(E)) != null ? y : h.value,\n      behavior: ct(l)\n    });\n    const U = ((C = N == null ? void 0 : N.document) == null ? void 0 : C.documentElement) || (N == null ? void 0 : N.documentElement) || N;\n    h != null && (u.value = U.scrollLeft), m != null && (d.value = U.scrollTop);\n  }\n  const v = me(!1), p = ts({\n    left: !0,\n    right: !1,\n    top: !0,\n    bottom: !1\n  }), b = ts({\n    left: !1,\n    right: !1,\n    top: !1,\n    bottom: !1\n  }), _ = (E) => {\n    v.value && (v.value = !1, b.left = !1, b.right = !1, b.top = !1, b.bottom = !1, s(E));\n  }, M = Vc(_, t + n), R = (E) => {\n    var x;\n    if (!c)\n      return;\n    const T = ((x = E == null ? void 0 : E.document) == null ? void 0 : x.documentElement) || (E == null ? void 0 : E.documentElement) || gn(E), { display: y, flexDirection: A } = getComputedStyle(T), C = T.scrollLeft;\n    b.left = C < u.value, b.right = C > u.value;\n    const N = Math.abs(C) <= (o.left || 0), U = Math.abs(C) + T.clientWidth >= T.scrollWidth - (o.right || 0) - Jo;\n    y === \"flex\" && A === \"row-reverse\" ? (p.left = U, p.right = N) : (p.left = N, p.right = U), u.value = C;\n    let Y = T.scrollTop;\n    E === c.document && !Y && (Y = c.document.body.scrollTop), b.top = Y < d.value, b.bottom = Y > d.value;\n    const V = Math.abs(Y) <= (o.top || 0), ne = Math.abs(Y) + T.clientHeight >= T.scrollHeight - (o.bottom || 0) - Jo;\n    y === \"flex\" && A === \"column-reverse\" ? (p.top = ne, p.bottom = V) : (p.top = V, p.bottom = ne), d.value = Y;\n  }, w = (E) => {\n    var x;\n    if (!c)\n      return;\n    const T = (x = E.target.documentElement) != null ? x : E.target;\n    R(T), v.value = !0, M(E), i(E);\n  };\n  return Xe(\n    r,\n    \"scroll\",\n    t ? Yc(w, t, !0, !1) : w,\n    a\n  ), ko(() => {\n    try {\n      const E = ct(r);\n      if (!E)\n        return;\n      R(E);\n    } catch (E) {\n      f(E);\n    }\n  }), Xe(\n    r,\n    \"scrollend\",\n    _,\n    a\n  ), {\n    x: h,\n    y: m,\n    isScrolling: v,\n    arrivedState: p,\n    directions: b,\n    measure() {\n      const E = ct(r);\n      c && E && R(E);\n    }\n  };\n}\nconst Jc = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\nfunction eu(r = {}) {\n  const {\n    reactive: e = !1,\n    target: t = ln,\n    aliasMap: n = Jc,\n    passive: s = !0,\n    onEventFired: i = wn\n  } = r, o = ts(/* @__PURE__ */ new Set()), a = {\n    toJSON() {\n      return {};\n    },\n    current: o\n  }, l = e ? ts(a) : a, c = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set();\n  function u(g, v) {\n    g in l && (e ? l[g] = v : l[g].value = v);\n  }\n  function d() {\n    o.clear();\n    for (const g of f)\n      u(g, !1);\n  }\n  function h(g, v) {\n    var p, b;\n    const _ = (p = g.key) == null ? void 0 : p.toLowerCase(), R = [(b = g.code) == null ? void 0 : b.toLowerCase(), _].filter(Boolean);\n    _ && (v ? o.add(_) : o.delete(_));\n    for (const w of R)\n      f.add(w), u(w, v);\n    _ === \"meta\" && !v ? (c.forEach((w) => {\n      o.delete(w), u(w, !1);\n    }), c.clear()) : typeof g.getModifierState == \"function\" && g.getModifierState(\"Meta\") && v && [...o, ...R].forEach((w) => c.add(w));\n  }\n  Xe(t, \"keydown\", (g) => (h(g, !0), i(g)), { passive: s }), Xe(t, \"keyup\", (g) => (h(g, !1), i(g)), { passive: s }), Xe(\"blur\", d, { passive: !0 }), Xe(\"focus\", d, { passive: !0 });\n  const m = new Proxy(\n    l,\n    {\n      get(g, v, p) {\n        if (typeof v != \"string\")\n          return Reflect.get(g, v, p);\n        if (v = v.toLowerCase(), v in n && (v = n[v]), !(v in l))\n          if (/[+_-]/.test(v)) {\n            const _ = v.split(/[+_-]/g).map((M) => M.trim());\n            l[v] = Pe(() => _.every((M) => ct(m[M])));\n          } else\n            l[v] = me(!1);\n        const b = Reflect.get(g, v, p);\n        return e ? ct(b) : b;\n      }\n    }\n  );\n  return m;\n}\nconst tu = {\n  page: (r) => [r.pageX, r.pageY],\n  client: (r) => [r.clientX, r.clientY],\n  screen: (r) => [r.screenX, r.screenY],\n  movement: (r) => r instanceof Touch ? null : [r.movementX, r.movementY]\n};\nfunction nu(r = {}) {\n  const {\n    type: e = \"page\",\n    touch: t = !0,\n    resetOnTouchEnds: n = !1,\n    initialValue: s = { x: 0, y: 0 },\n    window: i = ln,\n    target: o = i,\n    scroll: a = !0,\n    eventFilter: l\n  } = r;\n  let c = null, f = 0, u = 0;\n  const d = me(s.x), h = me(s.y), m = me(null), g = typeof e == \"function\" ? e : tu[e], v = (E) => {\n    const x = g(E);\n    c = E, x && ([d.value, h.value] = x, m.value = \"mouse\"), i && (f = i.scrollX, u = i.scrollY);\n  }, p = (E) => {\n    if (E.touches.length > 0) {\n      const x = g(E.touches[0]);\n      x && ([d.value, h.value] = x, m.value = \"touch\");\n    }\n  }, b = () => {\n    if (!c || !i)\n      return;\n    const E = g(c);\n    c instanceof MouseEvent && E && (d.value = E[0] + i.scrollX - f, h.value = E[1] + i.scrollY - u);\n  }, _ = () => {\n    d.value = s.x, h.value = s.y;\n  }, M = l ? (E) => l(() => v(E), {}) : (E) => v(E), R = l ? (E) => l(() => p(E), {}) : (E) => p(E), w = l ? () => l(() => b(), {}) : () => b();\n  if (o) {\n    const E = { passive: !0 };\n    Xe(o, [\"mousemove\", \"dragover\"], M, E), t && e !== \"movement\" && (Xe(o, [\"touchstart\", \"touchmove\"], R, E), n && Xe(o, \"touchend\", _, E)), a && e === \"page\" && Xe(i, \"scroll\", w, { passive: !0 });\n  }\n  return {\n    x: d,\n    y: h,\n    sourceType: m\n  };\n}\nfunction su(r = {}) {\n  const { window: e = ln, behavior: t = \"auto\" } = r;\n  if (!e)\n    return {\n      x: me(0),\n      y: me(0)\n    };\n  const n = me(e.scrollX), s = me(e.scrollY), i = Pe({\n    get() {\n      return n.value;\n    },\n    set(a) {\n      scrollTo({ left: a, behavior: t });\n    }\n  }), o = Pe({\n    get() {\n      return s.value;\n    },\n    set(a) {\n      scrollTo({ top: a, behavior: t });\n    }\n  });\n  return Xe(\n    e,\n    \"scroll\",\n    () => {\n      n.value = e.scrollX, s.value = e.scrollY;\n    },\n    {\n      capture: !1,\n      passive: !0\n    }\n  ), { x: i, y: o };\n}\nfunction Na(r = {}) {\n  const {\n    window: e = ln,\n    initialWidth: t = Number.POSITIVE_INFINITY,\n    initialHeight: n = Number.POSITIVE_INFINITY,\n    listenOrientation: s = !0,\n    includeScrollbar: i = !0,\n    type: o = \"inner\"\n  } = r, a = me(t), l = me(n), c = () => {\n    e && (o === \"outer\" ? (a.value = e.outerWidth, l.value = e.outerHeight) : i ? (a.value = e.innerWidth, l.value = e.innerHeight) : (a.value = e.document.documentElement.clientWidth, l.value = e.document.documentElement.clientHeight));\n  };\n  if (c(), ko(c), Xe(\"resize\", c, { passive: !0 }), s) {\n    const f = Zc(\"(orientation: portrait)\");\n    J(f, () => c());\n  }\n  return { width: a, height: l };\n}\nfunction iu(r) {\n  let { resolution: e, renderer: t, scene: n, envMap: s, fog: i, near: o, far: a } = r;\n  t = t ?? xn().renderer, n = n ?? xn().scene, et(() => {\n    e = ze(r.resolution) ?? 255, o = ze(r.near) ?? 0.1, a = ze(r.far) ?? 1e3, s = ze(r.envMap) ?? void 0, i = ze(r.fog) ?? void 0, t = ze(r.renderer) ?? t, n = ze(r.scene) ?? n;\n  });\n  const c = Pe(() => new aa(ze(e)));\n  c.value.texture.type = Lt, ci(() => {\n    c.value.dispose();\n  });\n  const f = Pe(() => new la(ze(o), ze(a), ze(c))), u = () => {\n    const d = ze(n), h = d.fog, m = d.background;\n    d.background = ze(s) || m, d.fog = ze(i) || h, f.value.update(ze(t), d), d.fog = h, d.background = m;\n  };\n  return et(u), {\n    fbo: c,\n    camera: f,\n    update: u\n  };\n}\nconst ou = [\"object\"], Pg = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    frames: { default: 1 / 0 },\n    resolution: {},\n    near: {},\n    far: {},\n    envMap: {},\n    fog: {},\n    renderer: {},\n    scene: {}\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), { fbo: s, camera: i, update: o } = iu(t);\n    let a = 0;\n    return Ve().onBeforeRender(() => {\n      n.value && (t.frames === 1 / 0 || a < ze(t.frames)) && (n.value.visible = !1, o(), n.value.visible = !0, n.value && n.value.traverse((l) => {\n        \"material\" in l && typeof l.material == \"object\" && l.material && \"envMap\" in l.material && (l.material.envMap = s.value.texture);\n      }), a++);\n    }), e({ instance: n, fbo: s, camera: i, update: o }), (l, c) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"groupRef\",\n      ref: n\n    }, [\n      ye(\"primitive\", { object: F(i) }, null, 8, ou),\n      Ne(l.$slots, \"default\")\n    ], 512));\n  }\n}), Rg = /* @__PURE__ */ ue({\n  __name: \"Billboard\",\n  props: {\n    autoUpdate: { type: Boolean, default: !0 },\n    lockX: { type: Boolean, default: !1 },\n    lockY: { type: Boolean, default: !1 },\n    lockZ: { type: Boolean, default: !1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(new Zt()), s = re(new Zt()), i = new je(), o = new vt();\n    function a(l) {\n      n.value && (!l && (l = xn().camera.value, !l) || (s.value.rotation.copy(o), n.value.updateMatrix(), n.value.updateWorldMatrix(!1, !1), n.value.getWorldQuaternion(i), l.getWorldQuaternion(s.value.quaternion).premultiply(i.invert()), t.lockX && (s.value.rotation.x = o.x), t.lockY && (s.value.rotation.y = o.y), t.lockZ && (s.value.rotation.z = o.z)));\n    }\n    return Ve().onBeforeRender(({ camera: l }) => {\n      t.autoUpdate && a(l);\n    }), e({ instance: n, update: a }), (l, c) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"outerRef\",\n      ref: n\n    }, [\n      ye(\"TresGroup\", {\n        ref_key: \"innerRef\",\n        ref: s\n      }, [\n        Ne(l.$slots, \"default\")\n      ], 512)\n    ], 512));\n  }\n}), Cg = ue({\n  name: \"GlobalAudio\",\n  props: [\n    \"src\",\n    \"loop\",\n    \"volume\",\n    \"playbackRate\",\n    \"playTrigger\",\n    \"stopTrigger\"\n  ],\n  async setup(r, { expose: e, emit: t }) {\n    var u;\n    const { camera: n, renderer: s } = xe(), i = new ca();\n    (u = n.value) == null || u.add(i);\n    const o = new Al(i), a = new ua();\n    e({ instance: o }), tt(() => {\n      o && o.disconnect();\n    }), J(() => [r.playbackRate], () => o.setPlaybackRate(r.playbackRate ?? 1), { immediate: !0 }), J(() => [r.volume], () => o.setVolume(r.volume ?? 0.5), { immediate: !0 }), J(() => [r.loop], () => o.setLoop(r.loop ?? !1), { immediate: !0 }), J(() => [r.src], async () => {\n      const d = await a.loadAsync(r.src);\n      o.setBuffer(d);\n    }, { immediate: !0 });\n    const c = document.getElementById(r.playTrigger ?? \"\") || s.value.domElement;\n    Xe(c, \"click\", () => {\n      o.isPlaying ? o.pause() : o.play(), t(\"isPlaying\", o.isPlaying);\n    });\n    const f = document.getElementById(r.stopTrigger ?? \"\");\n    return f && Xe(f, \"click\", () => {\n      o.stop(), t(\"isPlaying\", o.isPlaying);\n    }), null;\n  }\n}), ru = [\"color-space\", \"args\", \"attach\"], Ig = /* @__PURE__ */ ue({\n  __name: \"GradientTexture\",\n  props: {\n    stops: {},\n    colors: {},\n    attach: { default: \"map\" },\n    height: { default: 1024 },\n    width: { default: 16 },\n    type: { default: \"linear\" },\n    innerCircleRadius: { default: 0 },\n    outerCircleRadius: { default: \"auto\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), s = document.createElement(\"canvas\");\n    function i(a) {\n      const l = a.getContext(\"2d\");\n      a.width = t.width, a.height = t.height;\n      let c;\n      if (t.type === \"linear\")\n        c = l.createLinearGradient(0, 0, 0, t.height);\n      else {\n        const d = a.width / 2, h = a.height / 2, m = t.outerCircleRadius !== \"auto\" ? Math.abs(Number(t.outerCircleRadius)) : Math.sqrt(d ** 2 + h ** 2);\n        c = l.createRadialGradient(\n          d,\n          h,\n          Math.abs(t.innerCircleRadius),\n          d,\n          h,\n          m\n        );\n      }\n      const f = new Jn.Color();\n      let u = t.stops.length;\n      for (; u--; )\n        c.addColorStop(t.stops[u], f.set(t.colors[u]).getStyle());\n      l.save(), l.fillStyle = c, l.fillRect(0, 0, t.width, t.height), l.restore(), n.value && (n.value.needsUpdate = !0);\n    }\n    const o = xn().renderer;\n    return J(() => [t.colors, t.stops, t.height, t.width, t.type, t.innerCircleRadius, t.outerCircleRadius], () => {\n      i(s);\n    }, { immediate: !0 }), po(t.colors) && J(t.colors, () => i(s)), po(t.stops) && J(t.stops, () => i(s)), e({ instance: n }), (a, l) => (ae(), ce(\"TresCanvasTexture\", {\n      ref_key: \"textureRef\",\n      ref: n,\n      \"color-space\": F(o).outputColorSpace,\n      args: [F(s)],\n      attach: t.attach\n    }, null, 8, ru));\n  }\n});\nfunction No(r, e, t, n) {\n  const s = class extends bt {\n    constructor(o = {}) {\n      const a = Object.entries(r);\n      super({\n        uniforms: a.reduce((l, [c, f]) => {\n          const u = Dn.clone({ [c]: { value: f } });\n          return {\n            ...l,\n            ...u\n          };\n        }, {}),\n        vertexShader: e,\n        fragmentShader: t\n      });\n      pe(this, \"key\", \"\");\n      a.forEach(\n        ([l]) => Object.defineProperty(this, l, {\n          get: () => this.uniforms[l].value,\n          set: (c) => this.uniforms[l].value = c\n        })\n      ), Object.assign(this, o);\n    }\n  };\n  return s.key = Ye.generateUUID(), s;\n}\nconst au = No(\n  {\n    color: /* @__PURE__ */ new be(\"white\"),\n    scale: /* @__PURE__ */ new ve(1, 1),\n    imageBounds: /* @__PURE__ */ new ve(1, 1),\n    resolution: 1024,\n    map: null,\n    zoom: 1,\n    radius: 0,\n    grayscale: 0,\n    opacity: 1\n  },\n  /* glsl */\n  `\n    varying vec2 vUv;\n    varying vec2 vPos;\n    void main() {\n      gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n      vUv = uv;\n      vPos = position.xy;\n    }\n  `,\n  /* glsl */\n  `\n    // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\n    varying vec2 vUv;\n    varying vec2 vPos;\n    uniform vec2 scale;\n    uniform vec2 imageBounds;\n    uniform float resolution;\n    uniform vec3 color;\n    uniform sampler2D map;\n    uniform float radius;\n    uniform float zoom;\n    uniform float grayscale;\n    uniform float opacity;\n    const vec3 luma = vec3(.299, 0.587, 0.114);\n    vec4 toGrayscale(vec4 color, float intensity) {\n      return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);\n    }\n    vec2 aspect(vec2 size) {\n      return size / min(size.x, size.y);\n    }\n    \n    const float PI = 3.14159265;\n      \n    // from https://iquilezles.org/articles/distfunctions\n    float udRoundBox( vec2 p, vec2 b, float r ) {\n      return length(max(abs(p)-b+r,0.0))-r;\n    }\n  \n    void main() {\n      vec2 s = aspect(scale);\n      vec2 i = aspect(imageBounds);\n      float rs = s.x / s.y;\n      float ri = i.x / i.y;\n      vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);\n      vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;\n      vec2 uv = vUv * s / new + offset;\n      vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);\n  \n      vec2 res = vec2(scale * resolution);\n      vec2 halfRes = 0.5 * res;\n      float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);    \n        vec3 a = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0, 1.0, b));\n      gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity * a), grayscale);\n      \n      #include <tonemapping_fragment>\n      #include <colorspace_fragment>\n    }\n  `\n), lu = /* @__PURE__ */ ue({\n  __name: \"ImageMaterial\",\n  setup(r, { expose: e }) {\n    Oa({ ImageMaterial: au });\n    const t = re();\n    return e({ instance: t }), (n, s) => (ae(), ce(\"TresImageMaterial\", {\n      ref_key: \"materialRef\",\n      ref: t\n    }, null, 512));\n  }\n}), cu = [\"scale\"], uu = [\"args\"], Og = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    segments: { default: 1 },\n    scale: { default: 1 },\n    color: { default: () => new be(\"white\") },\n    zoom: { default: 1 },\n    radius: { default: 0 },\n    grayscale: { default: 0 },\n    toneMapped: { type: Boolean, default: !0 },\n    transparent: { type: Boolean, default: !1 },\n    opacity: { default: 1 },\n    side: { default: ss },\n    texture: {},\n    url: {}\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), s = re(t.texture ?? null), i = xn().sizes, o = Pe(() => Array.isArray(t.scale) ? [t.scale[0], t.scale[1]] : [t.scale, t.scale]), a = Pe(() => {\n      var f, u;\n      return [((f = s.value) == null ? void 0 : f.image.width) ?? 0, ((u = s.value) == null ? void 0 : u.image.height) ?? 0];\n    }), l = Pe(() => Math.max(i.width.value, i.height.value));\n    et(() => {\n      t.texture ? s.value = t.texture : Bn([t.url]).then((f) => s.value = f);\n    });\n    const c = Pe(\n      () => Array.isArray(t.scale) ? [...t.scale, 1] : t.scale\n    );\n    return e({ instance: n }), (f, u) => (ae(), ce(\"TresMesh\", {\n      ref_key: \"imageRef\",\n      ref: n,\n      scale: c.value\n    }, [\n      Ne(f.$slots, \"default\", {}, () => [\n        ye(\"TresPlaneGeometry\", {\n          args: [1, 1, t.segments, t.segments]\n        }, null, 8, uu)\n      ]),\n      ms(lu, {\n        color: t.color,\n        map: s.value,\n        zoom: t.zoom,\n        grayscale: t.grayscale,\n        opacity: t.opacity,\n        scale: o.value,\n        imageBounds: a.value,\n        resolution: l.value,\n        radius: f.radius,\n        toneMapped: f.toneMapped,\n        transparent: f.transparent,\n        side: f.side\n      }, null, 8, [\"color\", \"map\", \"zoom\", \"grayscale\", \"opacity\", \"scale\", \"imageBounds\", \"resolution\", \"radius\", \"toneMapped\", \"transparent\", \"side\"])\n    ], 8, cu));\n  }\n}), Ss = parseInt(Ts.replace(/\\D+/g, \"\")), Bo = Ss >= 125 ? \"uv1\" : \"uv2\";\nfunction er(r, e) {\n  if (e === Pl)\n    return console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\"), r;\n  if (e === oo || e === ha) {\n    let t = r.getIndex();\n    if (t === null) {\n      const o = [], a = r.getAttribute(\"position\");\n      if (a !== void 0) {\n        for (let l = 0; l < a.count; l++)\n          o.push(l);\n        r.setIndex(o), t = r.getIndex();\n      } else\n        return console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        ), r;\n    }\n    const n = t.count - 2, s = [];\n    if (t)\n      if (e === oo)\n        for (let o = 1; o <= n; o++)\n          s.push(t.getX(0)), s.push(t.getX(o)), s.push(t.getX(o + 1));\n      else\n        for (let o = 0; o < n; o++)\n          o % 2 === 0 ? (s.push(t.getX(o)), s.push(t.getX(o + 1)), s.push(t.getX(o + 2))) : (s.push(t.getX(o + 2)), s.push(t.getX(o + 1)), s.push(t.getX(o)));\n    s.length / 3 !== n && console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    const i = r.clone();\n    return i.setIndex(s), i.clearGroups(), i;\n  } else\n    return console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", e), r;\n}\nfunction hu(r, e = Math.PI / 3) {\n  const t = Math.cos(e), n = (1 + 1e-10) * 100, s = [new $(), new $(), new $()], i = new $(), o = new $(), a = new $(), l = new $();\n  function c(g) {\n    const v = ~~(g.x * n), p = ~~(g.y * n), b = ~~(g.z * n);\n    return `${v},${p},${b}`;\n  }\n  const f = r.index ? r.toNonIndexed() : r, u = f.attributes.position, d = {};\n  for (let g = 0, v = u.count / 3; g < v; g++) {\n    const p = 3 * g, b = s[0].fromBufferAttribute(u, p + 0), _ = s[1].fromBufferAttribute(u, p + 1), M = s[2].fromBufferAttribute(u, p + 2);\n    i.subVectors(M, _), o.subVectors(b, _);\n    const R = new $().crossVectors(i, o).normalize();\n    for (let w = 0; w < 3; w++) {\n      const E = s[w], x = c(E);\n      x in d || (d[x] = []), d[x].push(R);\n    }\n  }\n  const h = new Float32Array(u.count * 3), m = new ut(h, 3, !1);\n  for (let g = 0, v = u.count / 3; g < v; g++) {\n    const p = 3 * g, b = s[0].fromBufferAttribute(u, p + 0), _ = s[1].fromBufferAttribute(u, p + 1), M = s[2].fromBufferAttribute(u, p + 2);\n    i.subVectors(M, _), o.subVectors(b, _), a.crossVectors(i, o).normalize();\n    for (let R = 0; R < 3; R++) {\n      const w = s[R], E = c(w), x = d[E];\n      l.set(0, 0, 0);\n      for (let T = 0, y = x.length; T < y; T++) {\n        const A = x[T];\n        a.dot(A) > t && l.add(A);\n      }\n      l.normalize(), m.setXYZ(p + R, l.x, l.y, l.z);\n    }\n  }\n  return f.setAttribute(\"normal\", m), f;\n}\nvar fu = Object.defineProperty, du = (r, e, t) => e in r ? fu(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, pu = (r, e, t) => (du(r, e + \"\", t), t);\nasync function tr(r) {\n  const e = await r.arrayBuffer(), t = btoa(String.fromCharCode(...new Uint8Array(e)));\n  return `data:${r.type || \"\"};base64,${t}`;\n}\nlet Bs, bi, Fn, Us;\nfunction Ei(r, e = 1 / 0, t = null) {\n  bi || (bi = new jt(2, 2, 1, 1)), Fn || (Fn = new bt({\n    uniforms: { blitTexture: new Se(r) },\n    vertexShader: (\n      /* glsl */\n      `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `\n    ),\n    fragmentShader: (\n      /* glsl */\n      `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `\n    )\n  })), Fn.uniforms.blitTexture.value = r, Fn.defines.IS_SRGB = \"colorSpace\" in r ? r.colorSpace === \"srgb\" : r.encoding === 3001, Fn.needsUpdate = !0, Us || (Us = new de(bi, Fn), Us.frustrumCulled = !1);\n  const n = new kt(), s = new xs();\n  s.add(Us), t || (t = Bs = new Rl({ antialias: !1 })), t.setSize(Math.min(r.image.width, e), Math.min(r.image.height, e)), t.clear(), t.render(s, n);\n  const i = new es(t.domElement);\n  return i.minFilter = r.minFilter, i.magFilter = r.magFilter, i.wrapS = r.wrapS, i.wrapT = r.wrapT, i.name = r.name, Bs && (Bs.dispose(), Bs = null), i;\n}\nconst nr = {\n  POSITION: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"unsigned byte normalized\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\",\n    \"unsigned short normalized\"\n  ],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nclass Uo {\n  constructor() {\n    this.pluginCallbacks = [], this.register(function(e) {\n      return new Eu(e);\n    }), this.register(function(e) {\n      return new Mu(e);\n    }), this.register(function(e) {\n      return new Pu(e);\n    }), this.register(function(e) {\n      return new Ru(e);\n    }), this.register(function(e) {\n      return new Cu(e);\n    }), this.register(function(e) {\n      return new Iu(e);\n    }), this.register(function(e) {\n      return new Su(e);\n    }), this.register(function(e) {\n      return new Au(e);\n    }), this.register(function(e) {\n      return new Ou(e);\n    }), this.register(function(e) {\n      return new Du(e);\n    }), this.register(function(e) {\n      return new Lu(e);\n    });\n  }\n  register(e) {\n    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;\n  }\n  unregister(e) {\n    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(e, t, n, s) {\n    const i = new bu(), o = [];\n    for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)\n      o.push(this.pluginCallbacks[a](i));\n    i.setPlugins(o), i.write(e, t, s).catch(n);\n  }\n  parseAsync(e, t) {\n    const n = this;\n    return new Promise(function(s, i) {\n      n.parse(e, s, i, t);\n    });\n  }\n}\npu(Uo, \"Utils\", {\n  insertKeyframe: function(r, e) {\n    const n = r.getValueSize(), s = new r.TimeBufferType(r.times.length + 1), i = new r.ValueBufferType(r.values.length + n), o = r.createInterpolant(new r.ValueBufferType(n));\n    let a;\n    if (r.times.length === 0) {\n      s[0] = e;\n      for (let l = 0; l < n; l++)\n        i[l] = 0;\n      a = 0;\n    } else if (e < r.times[0]) {\n      if (Math.abs(r.times[0] - e) < 1e-3)\n        return 0;\n      s[0] = e, s.set(r.times, 1), i.set(o.evaluate(e), 0), i.set(r.values, n), a = 0;\n    } else if (e > r.times[r.times.length - 1]) {\n      if (Math.abs(r.times[r.times.length - 1] - e) < 1e-3)\n        return r.times.length - 1;\n      s[s.length - 1] = e, s.set(r.times, 0), i.set(r.values, 0), i.set(o.evaluate(e), r.values.length), a = s.length - 1;\n    } else\n      for (let l = 0; l < r.times.length; l++) {\n        if (Math.abs(r.times[l] - e) < 1e-3)\n          return l;\n        if (r.times[l] < e && r.times[l + 1] > e) {\n          s.set(r.times.slice(0, l + 1), 0), s[l + 1] = e, s.set(r.times.slice(l + 1), l + 2), i.set(r.values.slice(0, (l + 1) * n), 0), i.set(o.evaluate(e), (l + 1) * n), i.set(r.values.slice((l + 1) * n), (l + 2) * n), a = l + 1;\n          break;\n        }\n      }\n    return r.times = s, r.values = i, a;\n  },\n  mergeMorphTargetTracks: function(r, e) {\n    const t = [], n = {}, s = r.tracks;\n    for (let i = 0; i < s.length; ++i) {\n      let o = s[i];\n      const a = rn.parseTrackName(o.name), l = rn.findNode(e, a.nodeName);\n      if (a.propertyName !== \"morphTargetInfluences\" || a.propertyIndex === void 0) {\n        t.push(o);\n        continue;\n      }\n      if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {\n        if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\"), o = o.clone(), o.setInterpolation(Mo);\n      }\n      const c = l.morphTargetInfluences.length, f = l.morphTargetDictionary[a.propertyIndex];\n      if (f === void 0)\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + a.propertyIndex);\n      let u;\n      if (n[l.uuid] === void 0) {\n        u = o.clone();\n        const h = new u.ValueBufferType(c * u.times.length);\n        for (let m = 0; m < u.times.length; m++)\n          h[m * c + f] = u.values[m];\n        u.name = (a.nodeName || \"\") + \".morphTargetInfluences\", u.values = h, n[l.uuid] = u, t.push(u);\n        continue;\n      }\n      const d = o.createInterpolant(new o.ValueBufferType(1));\n      u = n[l.uuid];\n      for (let h = 0; h < u.times.length; h++)\n        u.values[h * c + f] = d.evaluate(u.times[h]);\n      for (let h = 0; h < o.times.length; h++) {\n        const m = this.insertKeyframe(u, o.times[h]);\n        u.values[m * c + f] = o.values[h];\n      }\n    }\n    return r.tracks = t, r;\n  }\n});\nconst De = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n}, Mi = \"KHR_mesh_quantization\", Tt = {};\nTt[Kn] = De.NEAREST;\nTt[da] = De.NEAREST_MIPMAP_NEAREST;\nTt[pa] = De.NEAREST_MIPMAP_LINEAR;\nTt[wt] = De.LINEAR;\nTt[ma] = De.LINEAR_MIPMAP_NEAREST;\nTt[Eo] = De.LINEAR_MIPMAP_LINEAR;\nTt[Wt] = De.CLAMP_TO_EDGE;\nTt[Ln] = De.REPEAT;\nTt[ga] = De.MIRRORED_REPEAT;\nconst sr = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n}, mu = new be(), ir = 12, gu = 1179937895, vu = 2, or = 8, yu = 1313821514, _u = 5130562;\nfunction vs(r, e) {\n  return r.length === e.length && r.every(function(t, n) {\n    return t === e[n];\n  });\n}\nfunction xu(r) {\n  return new TextEncoder().encode(r).buffer;\n}\nfunction wu(r) {\n  return vs(r.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction Tu(r, e, t) {\n  const n = {\n    min: new Array(r.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(r.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let s = e; s < e + t; s++)\n    for (let i = 0; i < r.itemSize; i++) {\n      let o;\n      r.itemSize > 4 ? o = r.array[s * r.itemSize + i] : (i === 0 ? o = r.getX(s) : i === 1 ? o = r.getY(s) : i === 2 ? o = r.getZ(s) : i === 3 && (o = r.getW(s)), r.normalized === !0 && (o = Ye.normalize(o, r.array))), n.min[i] = Math.min(n.min[i], o), n.max[i] = Math.max(n.max[i], o);\n    }\n  return n;\n}\nfunction Ba(r) {\n  return Math.ceil(r / 4) * 4;\n}\nfunction Si(r, e = 0) {\n  const t = Ba(r.byteLength);\n  if (t !== r.byteLength) {\n    const n = new Uint8Array(t);\n    if (n.set(new Uint8Array(r)), e !== 0)\n      for (let s = r.byteLength; s < t; s++)\n        n[s] = e;\n    return n.buffer;\n  }\n  return r;\n}\nfunction rr() {\n  return typeof document > \"u\" && typeof OffscreenCanvas < \"u\" ? new OffscreenCanvas(1, 1) : document.createElement(\"canvas\");\n}\nfunction ar(r, e) {\n  if (r.toBlob !== void 0)\n    return new Promise((n) => r.toBlob(n, e));\n  let t;\n  return e === \"image/jpeg\" ? t = 0.92 : e === \"image/webp\" && (t = 0.8), r.convertToBlob({\n    type: e,\n    quality: t\n  });\n}\nclass bu {\n  constructor() {\n    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    }, this.cache = {\n      meshes: /* @__PURE__ */ new Map(),\n      attributes: /* @__PURE__ */ new Map(),\n      attributesNormalized: /* @__PURE__ */ new Map(),\n      materials: /* @__PURE__ */ new Map(),\n      textures: /* @__PURE__ */ new Map(),\n      images: /* @__PURE__ */ new Map()\n    };\n  }\n  setPlugins(e) {\n    this.plugins = e;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(e, t, n = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: !1,\n        trs: !1,\n        onlyVisible: !0,\n        maxTextureSize: 1 / 0,\n        animations: [],\n        includeCustomExtensions: !1\n      },\n      n\n    ), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);\n    const s = this, i = s.buffers, o = s.json;\n    n = s.options;\n    const a = s.extensionsUsed, l = s.extensionsRequired, c = new Blob(i, { type: \"application/octet-stream\" }), f = Object.keys(a), u = Object.keys(l);\n    f.length > 0 && (o.extensionsUsed = f), u.length > 0 && (o.extensionsRequired = u), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((d) => {\n      const h = Si(d), m = new DataView(new ArrayBuffer(or));\n      m.setUint32(0, h.byteLength, !0), m.setUint32(4, _u, !0);\n      const g = Si(xu(JSON.stringify(o)), 32), v = new DataView(new ArrayBuffer(or));\n      v.setUint32(0, g.byteLength, !0), v.setUint32(4, yu, !0);\n      const p = new ArrayBuffer(ir), b = new DataView(p);\n      b.setUint32(0, gu, !0), b.setUint32(4, vu, !0);\n      const _ = ir + v.byteLength + g.byteLength + m.byteLength + h.byteLength;\n      b.setUint32(8, _, !0), new Blob([p, v, g, m, h], {\n        type: \"application/octet-stream\"\n      }).arrayBuffer().then(t);\n    }) : o.buffers && o.buffers.length > 0 ? tr(c).then((d) => {\n      o.buffers[0].uri = d, t(o);\n    }) : t(o);\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(e, t) {\n    if (Object.keys(e.userData).length === 0)\n      return;\n    const n = this.options, s = this.extensionsUsed;\n    try {\n      const i = JSON.parse(JSON.stringify(e.userData));\n      if (n.includeCustomExtensions && i.gltfExtensions) {\n        t.extensions === void 0 && (t.extensions = {});\n        for (const o in i.gltfExtensions)\n          t.extensions[o] = i.gltfExtensions[o], s[o] = !0;\n        delete i.gltfExtensions;\n      }\n      Object.keys(i).length > 0 && (t.extras = i);\n    } catch (i) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" + e.name + \"' won't be serialized because of JSON.stringify error - \" + i.message\n      );\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(e, t = !1) {\n    if (this.uids.has(e) === !1) {\n      const s = /* @__PURE__ */ new Map();\n      s.set(!0, this.uid++), s.set(!1, this.uid++), this.uids.set(e, s);\n    }\n    return this.uids.get(e).get(t);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(e) {\n    if (this.cache.attributesNormalized.has(e))\n      return !1;\n    const n = new $();\n    for (let s = 0, i = e.count; s < i; s++)\n      if (Math.abs(n.fromBufferAttribute(e, s).length() - 1) > 5e-4)\n        return !1;\n    return !0;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(e) {\n    const t = this.cache;\n    if (t.attributesNormalized.has(e))\n      return t.attributesNormalized.get(e);\n    const n = e.clone(), s = new $();\n    for (let i = 0, o = n.count; i < o; i++)\n      s.fromBufferAttribute(n, i), s.x === 0 && s.y === 0 && s.z === 0 ? s.setX(1) : s.normalize(), n.setXYZ(i, s.x, s.y, s.z);\n    return t.attributesNormalized.set(e, n), n;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(e, t) {\n    let n = !1;\n    const s = {};\n    (t.offset.x !== 0 || t.offset.y !== 0) && (s.offset = t.offset.toArray(), n = !0), t.rotation !== 0 && (s.rotation = t.rotation, n = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (s.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = s, this.extensionsUsed.KHR_texture_transform = !0);\n  }\n  buildMetalRoughTexture(e, t) {\n    if (e === t)\n      return e;\n    function n(h) {\n      return (\"colorSpace\" in h ? h.colorSpace === \"srgb\" : h.encoding === 3001) ? function(g) {\n        return g < 0.04045 ? g * 0.0773993808 : Math.pow(g * 0.9478672986 + 0.0521327014, 2.4);\n      } : function(g) {\n        return g;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\"), e instanceof mi && (e = Ei(e)), t instanceof mi && (t = Ei(t));\n    const s = e ? e.image : null, i = t ? t.image : null, o = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = rr();\n    l.width = o, l.height = a;\n    const c = l.getContext(\"2d\");\n    c.fillStyle = \"#00ffff\", c.fillRect(0, 0, o, a);\n    const f = c.getImageData(0, 0, o, a);\n    if (s) {\n      c.drawImage(s, 0, 0, o, a);\n      const h = n(e), m = c.getImageData(0, 0, o, a).data;\n      for (let g = 2; g < m.length; g += 4)\n        f.data[g] = h(m[g] / 256) * 256;\n    }\n    if (i) {\n      c.drawImage(i, 0, 0, o, a);\n      const h = n(t), m = c.getImageData(0, 0, o, a).data;\n      for (let g = 1; g < m.length; g += 4)\n        f.data[g] = h(m[g] / 256) * 256;\n    }\n    c.putImageData(f, 0, 0);\n    const d = (e || t).clone();\n    return d.source = new es(l).source, \"colorSpace\" in d ? d.colorSpace = \"\" : d.encoding = 3e3, d.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\"), d;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(e) {\n    const t = this.json, n = this.buffers;\n    return t.buffers || (t.buffers = [{ byteLength: 0 }]), n.push(e), 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(e, t, n, s, i) {\n    const o = this.json;\n    o.bufferViews || (o.bufferViews = []);\n    let a;\n    switch (t) {\n      case De.BYTE:\n      case De.UNSIGNED_BYTE:\n        a = 1;\n        break;\n      case De.SHORT:\n      case De.UNSIGNED_SHORT:\n        a = 2;\n        break;\n      default:\n        a = 4;\n    }\n    const l = Ba(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));\n    let f = 0;\n    for (let h = n; h < n + s; h++)\n      for (let m = 0; m < e.itemSize; m++) {\n        let g;\n        e.itemSize > 4 ? g = e.array[h * e.itemSize + m] : (m === 0 ? g = e.getX(h) : m === 1 ? g = e.getY(h) : m === 2 ? g = e.getZ(h) : m === 3 && (g = e.getW(h)), e.normalized === !0 && (g = Ye.normalize(g, e.array))), t === De.FLOAT ? c.setFloat32(f, g, !0) : t === De.INT ? c.setInt32(f, g, !0) : t === De.UNSIGNED_INT ? c.setUint32(f, g, !0) : t === De.SHORT ? c.setInt16(f, g, !0) : t === De.UNSIGNED_SHORT ? c.setUint16(f, g, !0) : t === De.BYTE ? c.setInt8(f, g) : t === De.UNSIGNED_BYTE && c.setUint8(f, g), f += a;\n      }\n    const u = {\n      buffer: this.processBuffer(c.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: l\n    };\n    return i !== void 0 && (u.target = i), i === De.ARRAY_BUFFER && (u.byteStride = e.itemSize * a), this.byteOffset += l, o.bufferViews.push(u), {\n      id: o.bufferViews.length - 1,\n      byteLength: 0\n    };\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(e) {\n    const t = this, n = t.json;\n    return n.bufferViews || (n.bufferViews = []), e.arrayBuffer().then((s) => {\n      const i = Si(s), o = {\n        buffer: t.processBuffer(i),\n        byteOffset: t.byteOffset,\n        byteLength: i.byteLength\n      };\n      return t.byteOffset += i.byteLength, n.bufferViews.push(o) - 1;\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(e, t, n, s) {\n    const i = this.json, o = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let a;\n    if (e.array.constructor === Float32Array)\n      a = De.FLOAT;\n    else if (e.array.constructor === Int32Array)\n      a = De.INT;\n    else if (e.array.constructor === Uint32Array)\n      a = De.UNSIGNED_INT;\n    else if (e.array.constructor === Int16Array)\n      a = De.SHORT;\n    else if (e.array.constructor === Uint16Array)\n      a = De.UNSIGNED_SHORT;\n    else if (e.array.constructor === Int8Array)\n      a = De.BYTE;\n    else if (e.array.constructor === Uint8Array)\n      a = De.UNSIGNED_BYTE;\n    else\n      throw new Error(\n        \"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + e.array.constructor.name\n      );\n    if (n === void 0 && (n = 0), s === void 0 && (s = e.count), s === 0)\n      return null;\n    const l = Tu(e, n, s);\n    let c;\n    t !== void 0 && (c = e === t.index ? De.ELEMENT_ARRAY_BUFFER : De.ARRAY_BUFFER);\n    const f = this.processBufferView(e, a, n, s, c), u = {\n      bufferView: f.id,\n      byteOffset: f.byteOffset,\n      componentType: a,\n      count: s,\n      max: l.max,\n      min: l.min,\n      type: o[e.itemSize]\n    };\n    return e.normalized === !0 && (u.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(u) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(e, t, n, s = \"image/png\") {\n    if (e !== null) {\n      const i = this, o = i.cache, a = i.json, l = i.options, c = i.pending;\n      o.images.has(e) || o.images.set(e, {});\n      const f = o.images.get(e), u = s + \":flipY/\" + n.toString();\n      if (f[u] !== void 0)\n        return f[u];\n      a.images || (a.images = []);\n      const d = { mimeType: s }, h = rr();\n      h.width = Math.min(e.width, l.maxTextureSize), h.height = Math.min(e.height, l.maxTextureSize);\n      const m = h.getContext(\"2d\");\n      if (n === !0 && (m.translate(0, h.height), m.scale(1, -1)), e.data !== void 0) {\n        t !== ei && console.error(\"GLTFExporter: Only RGBAFormat is supported.\", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", e);\n        const v = new Uint8ClampedArray(e.height * e.width * 4);\n        for (let p = 0; p < v.length; p += 4)\n          v[p + 0] = e.data[p + 0], v[p + 1] = e.data[p + 1], v[p + 2] = e.data[p + 2], v[p + 3] = e.data[p + 3];\n        m.putImageData(new ImageData(v, e.width, e.height), 0, 0);\n      } else\n        m.drawImage(e, 0, 0, h.width, h.height);\n      l.binary === !0 ? c.push(\n        ar(h, s).then((v) => i.processBufferViewImage(v)).then((v) => {\n          d.bufferView = v;\n        })\n      ) : h.toDataURL !== void 0 ? d.uri = h.toDataURL(s) : c.push(\n        ar(h, s).then(tr).then((v) => {\n          d.uri = v;\n        })\n      );\n      const g = a.images.push(d) - 1;\n      return f[u] = g, g;\n    } else\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(e) {\n    const t = this.json;\n    t.samplers || (t.samplers = []);\n    const n = {\n      magFilter: Tt[e.magFilter],\n      minFilter: Tt[e.minFilter],\n      wrapS: Tt[e.wrapS],\n      wrapT: Tt[e.wrapT]\n    };\n    return t.samplers.push(n) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(e) {\n    const n = this.options, s = this.cache, i = this.json;\n    if (s.textures.has(e))\n      return s.textures.get(e);\n    i.textures || (i.textures = []), e instanceof mi && (e = Ei(e, n.maxTextureSize));\n    let o = e.userData.mimeType;\n    o === \"image/webp\" && (o = \"image/png\");\n    const a = {\n      sampler: this.processSampler(e),\n      source: this.processImage(e.image, e.format, e.flipY, o)\n    };\n    e.name && (a.name = e.name), this._invokeAll(function(c) {\n      c.writeTexture && c.writeTexture(e, a);\n    });\n    const l = i.textures.push(a) - 1;\n    return s.textures.set(e, l), l;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(e) {\n    const t = this.cache, n = this.json;\n    if (t.materials.has(e))\n      return t.materials.get(e);\n    if (e.isShaderMaterial)\n      return console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\"), null;\n    n.materials || (n.materials = []);\n    const s = { pbrMetallicRoughness: {} };\n    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    const i = e.color.toArray().concat([e.opacity]);\n    if (vs(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {\n      const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {\n        index: this.processTexture(a),\n        channel: a.channel\n      };\n      this.applyTextureTransform(l, a), s.pbrMetallicRoughness.metallicRoughnessTexture = l;\n    }\n    if (e.map) {\n      const a = {\n        index: this.processTexture(e.map),\n        texCoord: e.map.channel\n      };\n      this.applyTextureTransform(a, e.map), s.pbrMetallicRoughness.baseColorTexture = a;\n    }\n    if (e.emissive) {\n      const a = e.emissive;\n      if (Math.max(a.r, a.g, a.b) > 0 && (s.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {\n        const c = {\n          index: this.processTexture(e.emissiveMap),\n          texCoord: e.emissiveMap.channel\n        };\n        this.applyTextureTransform(c, e.emissiveMap), s.emissiveTexture = c;\n      }\n    }\n    if (e.normalMap) {\n      const a = {\n        index: this.processTexture(e.normalMap),\n        texCoord: e.normalMap.channel\n      };\n      e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x), this.applyTextureTransform(a, e.normalMap), s.normalTexture = a;\n    }\n    if (e.aoMap) {\n      const a = {\n        index: this.processTexture(e.aoMap),\n        texCoord: e.aoMap.channel\n      };\n      e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), s.occlusionTexture = a;\n    }\n    e.transparent ? s.alphaMode = \"BLEND\" : e.alphaTest > 0 && (s.alphaMode = \"MASK\", s.alphaCutoff = e.alphaTest), e.side === on && (s.doubleSided = !0), e.name !== \"\" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {\n      a.writeMaterial && a.writeMaterial(e, s);\n    });\n    const o = n.materials.push(s) - 1;\n    return t.materials.set(e, o), o;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(e) {\n    const t = this.cache, n = this.json, s = [e.geometry.uuid];\n    if (Array.isArray(e.material))\n      for (let _ = 0, M = e.material.length; _ < M; _++)\n        s.push(e.material[_].uuid);\n    else\n      s.push(e.material.uuid);\n    const i = s.join(\":\");\n    if (t.meshes.has(i))\n      return t.meshes.get(i);\n    const o = e.geometry;\n    let a;\n    e.isLineSegments ? a = De.LINES : e.isLineLoop ? a = De.LINE_LOOP : e.isLine ? a = De.LINE_STRIP : e.isPoints ? a = De.POINTS : a = e.material.wireframe ? De.LINES : De.TRIANGLES;\n    const l = {}, c = {}, f = [], u = [], d = {\n      ...Ss >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      },\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    }, h = o.getAttribute(\"normal\");\n    h !== void 0 && !this.isNormalizedNormalAttribute(h) && (console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\"), o.setAttribute(\"normal\", this.createNormalizedNormalAttribute(h)));\n    let m = null;\n    for (let _ in o.attributes) {\n      if (_.slice(0, 5) === \"morph\")\n        continue;\n      const M = o.attributes[_];\n      if (_ = d[_] || _.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/.test(_) || (_ = \"_\" + _), t.attributes.has(this.getUID(M))) {\n        c[_] = t.attributes.get(this.getUID(M));\n        continue;\n      }\n      m = null;\n      const w = M.array;\n      _ === \"JOINTS_0\" && !(w instanceof Uint16Array) && !(w instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.'), m = new ut(new Uint16Array(w), M.itemSize, M.normalized));\n      const E = this.processAccessor(m || M, o);\n      E !== null && (_.startsWith(\"_\") || this.detectMeshQuantization(_, M), c[_] = E, t.attributes.set(this.getUID(M), E));\n    }\n    if (h !== void 0 && o.setAttribute(\"normal\", h), Object.keys(c).length === 0)\n      return null;\n    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {\n      const _ = [], M = [], R = {};\n      if (e.morphTargetDictionary !== void 0)\n        for (const w in e.morphTargetDictionary)\n          R[e.morphTargetDictionary[w]] = w;\n      for (let w = 0; w < e.morphTargetInfluences.length; ++w) {\n        const E = {};\n        let x = !1;\n        for (const T in o.morphAttributes) {\n          if (T !== \"position\" && T !== \"normal\") {\n            x || (console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\"), x = !0);\n            continue;\n          }\n          const y = o.morphAttributes[T][w], A = T.toUpperCase(), C = o.attributes[T];\n          if (t.attributes.has(this.getUID(y, !0))) {\n            E[A] = t.attributes.get(this.getUID(y, !0));\n            continue;\n          }\n          const N = y.clone();\n          if (!o.morphTargetsRelative)\n            for (let U = 0, Y = y.count; U < Y; U++)\n              for (let V = 0; V < y.itemSize; V++)\n                V === 0 && N.setX(U, y.getX(U) - C.getX(U)), V === 1 && N.setY(U, y.getY(U) - C.getY(U)), V === 2 && N.setZ(U, y.getZ(U) - C.getZ(U)), V === 3 && N.setW(U, y.getW(U) - C.getW(U));\n          E[A] = this.processAccessor(N, o), t.attributes.set(this.getUID(C, !0), E[A]);\n        }\n        u.push(E), _.push(e.morphTargetInfluences[w]), e.morphTargetDictionary !== void 0 && M.push(R[w]);\n      }\n      l.weights = _, M.length > 0 && (l.extras = {}, l.extras.targetNames = M);\n    }\n    const g = Array.isArray(e.material);\n    if (g && o.groups.length === 0)\n      return null;\n    const v = g ? e.material : [e.material], p = g ? o.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];\n    for (let _ = 0, M = p.length; _ < M; _++) {\n      const R = {\n        mode: a,\n        attributes: c\n      };\n      if (this.serializeUserData(o, R), u.length > 0 && (R.targets = u), o.index !== null) {\n        let E = this.getUID(o.index);\n        (p[_].start !== void 0 || p[_].count !== void 0) && (E += \":\" + p[_].start + \":\" + p[_].count), t.attributes.has(E) ? R.indices = t.attributes.get(E) : (R.indices = this.processAccessor(o.index, o, p[_].start, p[_].count), t.attributes.set(E, R.indices)), R.indices === null && delete R.indices;\n      }\n      const w = this.processMaterial(v[p[_].materialIndex]);\n      w !== null && (R.material = w), f.push(R);\n    }\n    l.primitives = f, n.meshes || (n.meshes = []), this._invokeAll(function(_) {\n      _.writeMesh && _.writeMesh(e, l);\n    });\n    const b = n.meshes.push(l) - 1;\n    return t.meshes.set(i, b), b;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(e, t) {\n    if (this.extensionsUsed[Mi])\n      return;\n    let n;\n    switch (t.array.constructor) {\n      case Int8Array:\n        n = \"byte\";\n        break;\n      case Uint8Array:\n        n = \"unsigned byte\";\n        break;\n      case Int16Array:\n        n = \"short\";\n        break;\n      case Uint16Array:\n        n = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    t.normalized && (n += \" normalized\");\n    const s = e.split(\"_\", 1)[0];\n    nr[s] && nr[s].includes(n) && (this.extensionsUsed[Mi] = !0, this.extensionsRequired[Mi] = !0);\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(e) {\n    const t = this.json;\n    t.cameras || (t.cameras = []);\n    const n = e.isOrthographicCamera, s = {\n      type: n ? \"orthographic\" : \"perspective\"\n    };\n    return n ? s.orthographic = {\n      xmag: e.right * 2,\n      ymag: e.top * 2,\n      zfar: e.far <= 0 ? 1e-3 : e.far,\n      znear: e.near < 0 ? 0 : e.near\n    } : s.perspective = {\n      aspectRatio: e.aspect,\n      yfov: Ye.degToRad(e.fov),\n      zfar: e.far <= 0 ? 1e-3 : e.far,\n      znear: e.near < 0 ? 0 : e.near\n    }, e.name !== \"\" && (s.name = e.type), t.cameras.push(s) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(e, t) {\n    const n = this.json, s = this.nodeMap;\n    n.animations || (n.animations = []), e = Uo.Utils.mergeMorphTargetTracks(e.clone(), t);\n    const i = e.tracks, o = [], a = [];\n    for (let l = 0; l < i.length; ++l) {\n      const c = i[l], f = rn.parseTrackName(c.name);\n      let u = rn.findNode(t, f.nodeName);\n      const d = sr[f.propertyName];\n      if (f.objectName === \"bones\" && (u.isSkinnedMesh === !0 ? u = u.skeleton.getBoneByName(f.objectIndex) : u = void 0), !u || !d)\n        return console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', c.name), null;\n      const h = 1;\n      let m = c.values.length / c.times.length;\n      d === sr.morphTargetInfluences && (m /= u.morphTargetInfluences.length);\n      let g;\n      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (g = \"CUBICSPLINE\", m /= 3) : c.getInterpolation() === fa ? g = \"STEP\" : g = \"LINEAR\", a.push({\n        input: this.processAccessor(new ut(c.times, h)),\n        output: this.processAccessor(new ut(c.values, m)),\n        interpolation: g\n      }), o.push({\n        sampler: a.length - 1,\n        target: {\n          node: s.get(u),\n          path: d\n        }\n      });\n    }\n    return n.animations.push({\n      name: e.name || \"clip_\" + n.animations.length,\n      samplers: a,\n      channels: o\n    }), n.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(e) {\n    const t = this.json, n = this.nodeMap, s = t.nodes[n.get(e)], i = e.skeleton;\n    if (i === void 0)\n      return null;\n    const o = e.skeleton.bones[0];\n    if (o === void 0)\n      return null;\n    const a = [], l = new Float32Array(i.bones.length * 16), c = new Ie();\n    for (let u = 0; u < i.bones.length; ++u)\n      a.push(n.get(i.bones[u])), c.copy(i.boneInverses[u]), c.multiply(e.bindMatrix).toArray(l, u * 16);\n    return t.skins === void 0 && (t.skins = []), t.skins.push({\n      inverseBindMatrices: this.processAccessor(new ut(l, 16)),\n      joints: a,\n      skeleton: n.get(o)\n    }), s.skin = t.skins.length - 1;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(e) {\n    const t = this.json, n = this.options, s = this.nodeMap;\n    t.nodes || (t.nodes = []);\n    const i = {};\n    if (n.trs) {\n      const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();\n      vs(a, [0, 0, 0, 1]) || (i.rotation = a), vs(l, [0, 0, 0]) || (i.translation = l), vs(c, [1, 1, 1]) || (i.scale = c);\n    } else\n      e.matrixAutoUpdate && e.updateMatrix(), wu(e.matrix) === !1 && (i.matrix = e.matrix.elements);\n    if (e.name !== \"\" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {\n      const a = this.processMesh(e);\n      a !== null && (i.mesh = a);\n    } else e.isCamera && (i.camera = this.processCamera(e));\n    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {\n      const a = [];\n      for (let l = 0, c = e.children.length; l < c; l++) {\n        const f = e.children[l];\n        if (f.visible || n.onlyVisible === !1) {\n          const u = this.processNode(f);\n          u !== null && a.push(u);\n        }\n      }\n      a.length > 0 && (i.children = a);\n    }\n    this._invokeAll(function(a) {\n      a.writeNode && a.writeNode(e, i);\n    });\n    const o = t.nodes.push(i) - 1;\n    return s.set(e, o), o;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(e) {\n    const t = this.json, n = this.options;\n    t.scenes || (t.scenes = [], t.scene = 0);\n    const s = {};\n    e.name !== \"\" && (s.name = e.name), t.scenes.push(s);\n    const i = [];\n    for (let o = 0, a = e.children.length; o < a; o++) {\n      const l = e.children[o];\n      if (l.visible || n.onlyVisible === !1) {\n        const c = this.processNode(l);\n        c !== null && i.push(c);\n      }\n    }\n    i.length > 0 && (s.nodes = i), this.serializeUserData(e, s);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(e) {\n    const t = new xs();\n    t.name = \"AuxScene\";\n    for (let n = 0; n < e.length; n++)\n      t.children.push(e[n]);\n    this.processScene(t);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(e) {\n    const t = this.options;\n    e = e instanceof Array ? e : [e], this._invokeAll(function(s) {\n      s.beforeParse && s.beforeParse(e);\n    });\n    const n = [];\n    for (let s = 0; s < e.length; s++)\n      e[s] instanceof xs ? this.processScene(e[s]) : n.push(e[s]);\n    n.length > 0 && this.processObjects(n);\n    for (let s = 0; s < this.skins.length; ++s)\n      this.processSkin(this.skins[s]);\n    for (let s = 0; s < t.animations.length; ++s)\n      this.processAnimation(t.animations[s], e[0]);\n    this._invokeAll(function(s) {\n      s.afterParse && s.afterParse(e);\n    });\n  }\n  _invokeAll(e) {\n    for (let t = 0, n = this.plugins.length; t < n; t++)\n      e(this.plugins[t]);\n  }\n}\nclass Eu {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(e, t) {\n    if (!e.isLight)\n      return;\n    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", e);\n      return;\n    }\n    const n = this.writer, s = n.json, i = n.extensionsUsed, o = {};\n    e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = \"directional\" : e.isPointLight ? (o.type = \"point\", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = \"spot\", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn(\n      \"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\"\n    ), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn(\n      \"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\"\n    ), i[this.name] || (s.extensions = s.extensions || {}, s.extensions[this.name] = { lights: [] }, i[this.name] = !0);\n    const a = s.extensions[this.name].lights;\n    a.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 };\n  }\n}\nlet Mu = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshBasicMaterial)\n      return;\n    const s = this.writer.extensionsUsed;\n    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}, Su = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {\n      const o = {\n        index: n.processTexture(e.clearcoatMap),\n        texCoord: e.clearcoatMap.channel\n      };\n      n.applyTextureTransform(o, e.clearcoatMap), i.clearcoatTexture = o;\n    }\n    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {\n      const o = {\n        index: n.processTexture(e.clearcoatRoughnessMap),\n        texCoord: e.clearcoatRoughnessMap.channel\n      };\n      n.applyTextureTransform(o, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = o;\n    }\n    if (e.clearcoatNormalMap) {\n      const o = {\n        index: n.processTexture(e.clearcoatNormalMap),\n        texCoord: e.clearcoatNormalMap.channel\n      };\n      n.applyTextureTransform(o, e.clearcoatNormalMap), i.clearcoatNormalTexture = o;\n    }\n    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Au = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.iridescence === 0)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {\n      const o = {\n        index: n.processTexture(e.iridescenceMap),\n        texCoord: e.iridescenceMap.channel\n      };\n      n.applyTextureTransform(o, e.iridescenceMap), i.iridescenceTexture = o;\n    }\n    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {\n      const o = {\n        index: n.processTexture(e.iridescenceThicknessMap),\n        texCoord: e.iridescenceThicknessMap.channel\n      };\n      n.applyTextureTransform(o, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = o;\n    }\n    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Pu = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.transmission === 0)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (i.transmissionFactor = e.transmission, e.transmissionMap) {\n      const o = {\n        index: n.processTexture(e.transmissionMap),\n        texCoord: e.transmissionMap.channel\n      };\n      n.applyTextureTransform(o, e.transmissionMap), i.transmissionTexture = o;\n    }\n    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Ru = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.transmission === 0)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (i.thicknessFactor = e.thickness, e.thicknessMap) {\n      const o = {\n        index: n.processTexture(e.thicknessMap),\n        texCoord: e.thicknessMap.channel\n      };\n      n.applyTextureTransform(o, e.thicknessMap), i.thicknessTexture = o;\n    }\n    i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Cu = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.ior === 1.5)\n      return;\n    const s = this.writer.extensionsUsed, i = {};\n    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Iu = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(mu) && !e.specularIntensityMap && !e.specularColorTexture)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (e.specularIntensityMap) {\n      const o = {\n        index: n.processTexture(e.specularIntensityMap),\n        texCoord: e.specularIntensityMap.channel\n      };\n      n.applyTextureTransform(o, e.specularIntensityMap), i.specularTexture = o;\n    }\n    if (e.specularColorMap) {\n      const o = {\n        index: n.processTexture(e.specularColorMap),\n        texCoord: e.specularColorMap.channel\n      };\n      n.applyTextureTransform(o, e.specularColorMap), i.specularColorTexture = o;\n    }\n    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Ou = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.sheen == 0)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (e.sheenRoughnessMap) {\n      const o = {\n        index: n.processTexture(e.sheenRoughnessMap),\n        texCoord: e.sheenRoughnessMap.channel\n      };\n      n.applyTextureTransform(o, e.sheenRoughnessMap), i.sheenRoughnessTexture = o;\n    }\n    if (e.sheenColorMap) {\n      const o = {\n        index: n.processTexture(e.sheenColorMap),\n        texCoord: e.sheenColorMap.channel\n      };\n      n.applyTextureTransform(o, e.sheenColorMap), i.sheenColorTexture = o;\n    }\n    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Du = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)\n      return;\n    const n = this.writer, s = n.extensionsUsed, i = {};\n    if (e.anisotropyMap) {\n      const o = { index: n.processTexture(e.anisotropyMap) };\n      n.applyTextureTransform(o, e.anisotropyMap), i.anisotropyTexture = o;\n    }\n    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n}, Lu = class {\n  constructor(e) {\n    this.writer = e, this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(e, t) {\n    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)\n      return;\n    const s = this.writer.extensionsUsed, i = {};\n    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;\n  }\n};\nvar Pt = Uint8Array, vn = Uint16Array, mo = Uint32Array, Ua = new Pt([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]), Fa = new Pt([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]), ku = new Pt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), za = function(r, e) {\n  for (var t = new vn(31), n = 0; n < 31; ++n)\n    t[n] = e += 1 << r[n - 1];\n  for (var s = new mo(t[30]), n = 1; n < 30; ++n)\n    for (var i = t[n]; i < t[n + 1]; ++i)\n      s[i] = i - t[n] << 5 | n;\n  return [t, s];\n}, Ga = za(Ua, 2), Ha = Ga[0], Nu = Ga[1];\nHa[28] = 258, Nu[258] = 28;\nvar Bu = za(Fa, 0), Uu = Bu[0], go = new vn(32768);\nfor (var Ze = 0; Ze < 32768; ++Ze) {\n  var fn = (Ze & 43690) >>> 1 | (Ze & 21845) << 1;\n  fn = (fn & 52428) >>> 2 | (fn & 13107) << 2, fn = (fn & 61680) >>> 4 | (fn & 3855) << 4, go[Ze] = ((fn & 65280) >>> 8 | (fn & 255) << 8) >>> 1;\n}\nvar ys = function(r, e, t) {\n  for (var n = r.length, s = 0, i = new vn(e); s < n; ++s)\n    ++i[r[s] - 1];\n  var o = new vn(e);\n  for (s = 0; s < e; ++s)\n    o[s] = o[s - 1] + i[s - 1] << 1;\n  var a;\n  if (t) {\n    a = new vn(1 << e);\n    var l = 15 - e;\n    for (s = 0; s < n; ++s)\n      if (r[s])\n        for (var c = s << 4 | r[s], f = e - r[s], u = o[r[s] - 1]++ << f, d = u | (1 << f) - 1; u <= d; ++u)\n          a[go[u] >>> l] = c;\n  } else\n    for (a = new vn(n), s = 0; s < n; ++s)\n      r[s] && (a[s] = go[o[r[s] - 1]++] >>> 15 - r[s]);\n  return a;\n}, As = new Pt(288);\nfor (var Ze = 0; Ze < 144; ++Ze)\n  As[Ze] = 8;\nfor (var Ze = 144; Ze < 256; ++Ze)\n  As[Ze] = 9;\nfor (var Ze = 256; Ze < 280; ++Ze)\n  As[Ze] = 7;\nfor (var Ze = 280; Ze < 288; ++Ze)\n  As[Ze] = 8;\nvar ja = new Pt(32);\nfor (var Ze = 0; Ze < 32; ++Ze)\n  ja[Ze] = 5;\nvar Fu = /* @__PURE__ */ ys(As, 9, 1), zu = /* @__PURE__ */ ys(ja, 5, 1), Ai = function(r) {\n  for (var e = r[0], t = 1; t < r.length; ++t)\n    r[t] > e && (e = r[t]);\n  return e;\n}, It = function(r, e, t) {\n  var n = e / 8 | 0;\n  return (r[n] | r[n + 1] << 8) >> (e & 7) & t;\n}, Pi = function(r, e) {\n  var t = e / 8 | 0;\n  return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7);\n}, Gu = function(r) {\n  return (r / 8 | 0) + (r & 7 && 1);\n}, Hu = function(r, e, t) {\n  (t == null || t > r.length) && (t = r.length);\n  var n = new (r instanceof vn ? vn : r instanceof mo ? mo : Pt)(t - e);\n  return n.set(r.subarray(e, t)), n;\n}, ju = function(r, e, t) {\n  var n = r.length;\n  if (!n || t && !t.l && n < 5)\n    return e || new Pt(0);\n  var s = !e || t, i = !t || t.i;\n  t || (t = {}), e || (e = new Pt(n * 3));\n  var o = function(D) {\n    var O = e.length;\n    if (D > O) {\n      var z = new Pt(Math.max(O * 2, D));\n      z.set(e), e = z;\n    }\n  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, f = t.l, u = t.d, d = t.m, h = t.n, m = n * 8;\n  do {\n    if (!f) {\n      t.f = a = It(r, l, 1);\n      var g = It(r, l + 1, 3);\n      if (l += 3, g)\n        if (g == 1)\n          f = Fu, u = zu, d = 9, h = 5;\n        else if (g == 2) {\n          var _ = It(r, l, 31) + 257, M = It(r, l + 10, 15) + 4, R = _ + It(r, l + 5, 31) + 1;\n          l += 14;\n          for (var w = new Pt(R), E = new Pt(19), x = 0; x < M; ++x)\n            E[ku[x]] = It(r, l + x * 3, 7);\n          l += M * 3;\n          for (var T = Ai(E), y = (1 << T) - 1, A = ys(E, T, 1), x = 0; x < R; ) {\n            var C = A[It(r, l, y)];\n            l += C & 15;\n            var v = C >>> 4;\n            if (v < 16)\n              w[x++] = v;\n            else {\n              var N = 0, U = 0;\n              for (v == 16 ? (U = 3 + It(r, l, 3), l += 2, N = w[x - 1]) : v == 17 ? (U = 3 + It(r, l, 7), l += 3) : v == 18 && (U = 11 + It(r, l, 127), l += 7); U--; )\n                w[x++] = N;\n            }\n          }\n          var Y = w.subarray(0, _), V = w.subarray(_);\n          d = Ai(Y), h = Ai(V), f = ys(Y, d, 1), u = ys(V, h, 1);\n        } else\n          throw \"invalid block type\";\n      else {\n        var v = Gu(l) + 4, p = r[v - 4] | r[v - 3] << 8, b = v + p;\n        if (b > n) {\n          if (i)\n            throw \"unexpected EOF\";\n          break;\n        }\n        s && o(c + p), e.set(r.subarray(v, b), c), t.b = c += p, t.p = l = b * 8;\n        continue;\n      }\n      if (l > m) {\n        if (i)\n          throw \"unexpected EOF\";\n        break;\n      }\n    }\n    s && o(c + 131072);\n    for (var ne = (1 << d) - 1, Z = (1 << h) - 1, ee = l; ; ee = l) {\n      var N = f[Pi(r, l) & ne], te = N >>> 4;\n      if (l += N & 15, l > m) {\n        if (i)\n          throw \"unexpected EOF\";\n        break;\n      }\n      if (!N)\n        throw \"invalid length/literal\";\n      if (te < 256)\n        e[c++] = te;\n      else if (te == 256) {\n        ee = l, f = null;\n        break;\n      } else {\n        var fe = te - 254;\n        if (te > 264) {\n          var x = te - 257, he = Ua[x];\n          fe = It(r, l, (1 << he) - 1) + Ha[x], l += he;\n        }\n        var we = u[Pi(r, l) & Z], I = we >>> 4;\n        if (!we)\n          throw \"invalid distance\";\n        l += we & 15;\n        var V = Uu[I];\n        if (I > 3) {\n          var he = Fa[I];\n          V += Pi(r, l) & (1 << he) - 1, l += he;\n        }\n        if (l > m) {\n          if (i)\n            throw \"unexpected EOF\";\n          break;\n        }\n        s && o(c + 131072);\n        for (var B = c + fe; c < B; c += 4)\n          e[c] = e[c - V], e[c + 1] = e[c + 1 - V], e[c + 2] = e[c + 2 - V], e[c + 3] = e[c + 3 - V];\n        c = B;\n      }\n    }\n    t.l = f, t.p = ee, t.b = c, f && (a = 1, t.m = d, t.d = u, t.n = h);\n  } while (!a);\n  return c == e.length ? e : Hu(e, 0, c);\n}, Vu = /* @__PURE__ */ new Pt(0), Yu = function(r) {\n  if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)\n    throw \"invalid zlib data\";\n  if (r[1] & 32)\n    throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction Wu(r, e) {\n  return ju((Yu(r), r.subarray(2, -4)), e);\n}\nvar Xu = typeof TextDecoder < \"u\" && /* @__PURE__ */ new TextDecoder(), $u = 0;\ntry {\n  Xu.decode(Vu, { stream: !0 }), $u = 1;\n} catch {\n}\nvar Zu = Object.defineProperty, Ku = (r, e, t) => e in r ? Zu(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, qu = (r, e, t) => (Ku(r, e + \"\", t), t);\nconst Va = class extends de {\n  constructor(r, e = {}) {\n    super(r), this.isReflector = !0, this.type = \"Reflector\", this.camera = new kt();\n    const t = this, n = e.color !== void 0 ? new be(e.color) : new be(8355711), s = e.textureWidth || 512, i = e.textureHeight || 512, o = e.clipBias || 0, a = e.shader || Va.ReflectorShader, l = e.multisample !== void 0 ? e.multisample : 4, c = new bs(), f = new $(), u = new $(), d = new $(), h = new Ie(), m = new $(0, 0, -1), g = new at(), v = new $(), p = new $(), b = new at(), _ = new Ie(), M = this.camera, R = new Xt(s, i, {\n      samples: l,\n      type: Lt\n    }), w = new bt({\n      uniforms: Dn.clone(a.uniforms),\n      fragmentShader: a.fragmentShader,\n      vertexShader: a.vertexShader\n    });\n    w.uniforms.tDiffuse.value = R.texture, w.uniforms.color.value = n, w.uniforms.textureMatrix.value = _, this.material = w, this.onBeforeRender = function(E, x, T) {\n      if (u.setFromMatrixPosition(t.matrixWorld), d.setFromMatrixPosition(T.matrixWorld), h.extractRotation(t.matrixWorld), f.set(0, 0, 1), f.applyMatrix4(h), v.subVectors(u, d), v.dot(f) > 0)\n        return;\n      v.reflect(f).negate(), v.add(u), h.extractRotation(T.matrixWorld), m.set(0, 0, -1), m.applyMatrix4(h), m.add(d), p.subVectors(u, m), p.reflect(f).negate(), p.add(u), M.position.copy(v), M.up.set(0, 1, 0), M.up.applyMatrix4(h), M.up.reflect(f), M.lookAt(p), M.far = T.far, M.updateMatrixWorld(), M.projectionMatrix.copy(T.projectionMatrix), _.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), _.multiply(M.projectionMatrix), _.multiply(M.matrixWorldInverse), _.multiply(t.matrixWorld), c.setFromNormalAndCoplanarPoint(f, u), c.applyMatrix4(M.matrixWorldInverse), g.set(c.normal.x, c.normal.y, c.normal.z, c.constant);\n      const y = M.projectionMatrix;\n      b.x = (Math.sign(g.x) + y.elements[8]) / y.elements[0], b.y = (Math.sign(g.y) + y.elements[9]) / y.elements[5], b.z = -1, b.w = (1 + y.elements[10]) / y.elements[14], g.multiplyScalar(2 / g.dot(b)), y.elements[2] = g.x, y.elements[6] = g.y, y.elements[10] = g.z + 1 - o, y.elements[14] = g.w, t.visible = !1;\n      const A = E.getRenderTarget(), C = E.xr.enabled, N = E.shadowMap.autoUpdate, U = E.toneMapping;\n      let Y = !1;\n      \"outputColorSpace\" in E ? Y = E.outputColorSpace === \"srgb\" : Y = E.outputEncoding === 3001, E.xr.enabled = !1, E.shadowMap.autoUpdate = !1, \"outputColorSpace\" in E ? E.outputColorSpace = \"srgb-linear\" : E.outputEncoding = 3e3, E.toneMapping = Cl, E.setRenderTarget(R), E.state.buffers.depth.setMask(!0), E.autoClear === !1 && E.clear(), E.render(x, M), E.xr.enabled = C, E.shadowMap.autoUpdate = N, E.toneMapping = U, \"outputColorSpace\" in E ? E.outputColorSpace = Y ? \"srgb\" : \"srgb-linear\" : E.outputEncoding = Y ? 3001 : 3e3, E.setRenderTarget(A);\n      const V = T.viewport;\n      V !== void 0 && E.state.viewport(V), t.visible = !0;\n    }, this.getRenderTarget = function() {\n      return R;\n    }, this.dispose = function() {\n      R.dispose(), t.material.dispose();\n    };\n  }\n};\nlet vo = Va;\nqu(vo, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${Ss >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`\n  )\n});\nvar Qu = Object.defineProperty, Ju = (r, e, t) => e in r ? Qu(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ya = (r, e, t) => (Ju(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nconst ui = new ht(), eh = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]), Wa = new Ao(eh, 5);\nui.setIndex([0, 1, 2, 0, 2, 3]);\nui.setAttribute(\"position\", new nn(Wa, 3, 0, !1));\nui.setAttribute(\"uv\", new nn(Wa, 2, 3, !1));\nconst yo = class extends de {\n  constructor() {\n    super(yo.Geometry, new $t({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = \"Lensflare\", this.frustumCulled = !1, this.renderOrder = 1 / 0;\n    const r = new $(), e = new $(), t = new ti(new Uint8Array(16 * 16 * 3), 16, 16, ei);\n    t.minFilter = Kn, t.magFilter = Kn, t.wrapS = Wt, t.wrapT = Wt;\n    const n = new ti(new Uint8Array(16 * 16 * 3), 16, 16, ei);\n    n.minFilter = Kn, n.magFilter = Kn, n.wrapS = Wt, n.wrapT = Wt;\n    const s = yo.Geometry, i = new gi({\n      uniforms: {\n        scale: { value: null },\n        screenPosition: { value: null }\n      },\n      vertexShader: (\n        /* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`\n      ),\n      depthTest: !0,\n      depthWrite: !1,\n      transparent: !1\n    }), o = new gi({\n      uniforms: {\n        map: { value: t },\n        scale: { value: null },\n        screenPosition: { value: null }\n      },\n      vertexShader: (\n        /* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`\n      ),\n      depthTest: !1,\n      depthWrite: !1,\n      transparent: !1\n    }), a = new de(s, i), l = [], c = $a.Shader, f = new gi({\n      uniforms: {\n        map: { value: null },\n        occlusionMap: { value: n },\n        color: { value: new be(16777215) },\n        scale: { value: new ve() },\n        screenPosition: { value: new $() }\n      },\n      vertexShader: c.vertexShader,\n      fragmentShader: c.fragmentShader,\n      blending: So,\n      transparent: !0,\n      depthWrite: !1\n    }), u = new de(s, f);\n    this.addElement = function(v) {\n      l.push(v);\n    };\n    const d = new ve(), h = new ve(), m = new va(), g = new at();\n    this.onBeforeRender = function(v, p, b) {\n      v.getCurrentViewport(g);\n      const _ = g.w / g.z, M = g.z / 2, R = g.w / 2;\n      let w = 16 / g.w;\n      if (d.set(w * _, w), m.min.set(g.x, g.y), m.max.set(g.x + (g.z - 16), g.y + (g.w - 16)), e.setFromMatrixPosition(this.matrixWorld), e.applyMatrix4(b.matrixWorldInverse), !(e.z > 0) && (r.copy(e).applyMatrix4(b.projectionMatrix), h.x = g.x + r.x * M + M - 8, h.y = g.y + r.y * R + R - 8, m.containsPoint(h))) {\n        v.copyFramebufferToTexture(h, t);\n        let E = i.uniforms;\n        E.scale.value = d, E.screenPosition.value = r, v.renderBufferDirect(b, null, s, i, a, null), v.copyFramebufferToTexture(h, n), E = o.uniforms, E.scale.value = d, E.screenPosition.value = r, v.renderBufferDirect(b, null, s, o, a, null);\n        const x = -r.x * 2, T = -r.y * 2;\n        for (let y = 0, A = l.length; y < A; y++) {\n          const C = l[y], N = f.uniforms;\n          N.color.value.copy(C.color), N.map.value = C.texture, N.screenPosition.value.x = r.x + x * C.distance, N.screenPosition.value.y = r.y + T * C.distance, w = C.size / g.w;\n          const U = g.w / g.z;\n          N.scale.value.set(w * U, w), f.uniformsNeedUpdate = !0, v.renderBufferDirect(b, null, s, f, u, null);\n        }\n      }\n    }, this.dispose = function() {\n      i.dispose(), o.dispose(), f.dispose(), t.dispose(), n.dispose();\n      for (let v = 0, p = l.length; v < p; v++)\n        l[v].texture.dispose();\n    };\n  }\n};\nlet Xa = yo;\nYa(Xa, \"Geometry\", ui);\nclass $a {\n  constructor(e, t = 1, n = 0, s = new be(16777215)) {\n    this.texture = e, this.size = t, this.distance = n, this.color = s;\n  }\n}\nYa($a, \"Shader\", {\n  uniforms: {\n    map: { value: null },\n    occlusionMap: { value: null },\n    color: { value: null },\n    scale: { value: null },\n    screenPosition: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n  )\n});\nclass th extends de {\n  constructor(e, t = {}) {\n    super(e), this.isWater = !0;\n    const n = this, s = t.textureWidth !== void 0 ? t.textureWidth : 512, i = t.textureHeight !== void 0 ? t.textureHeight : 512, o = t.clipBias !== void 0 ? t.clipBias : 0, a = t.alpha !== void 0 ? t.alpha : 1, l = t.time !== void 0 ? t.time : 0, c = t.waterNormals !== void 0 ? t.waterNormals : null, f = t.sunDirection !== void 0 ? t.sunDirection : new $(0.70707, 0.70707, 0), u = new be(t.sunColor !== void 0 ? t.sunColor : 16777215), d = new be(t.waterColor !== void 0 ? t.waterColor : 8355711), h = t.eye !== void 0 ? t.eye : new $(0, 0, 0), m = t.distortionScale !== void 0 ? t.distortionScale : 20, g = t.side !== void 0 ? t.side : ss, v = t.fog !== void 0 ? t.fog : !1, p = new bs(), b = new $(), _ = new $(), M = new $(), R = new Ie(), w = new $(0, 0, -1), E = new at(), x = new $(), T = new $(), y = new at(), A = new Ie(), C = new kt(), N = new Xt(s, i), U = {\n      uniforms: Dn.merge([\n        ni.fog,\n        ni.lights,\n        {\n          normalSampler: { value: null },\n          mirrorSampler: { value: null },\n          alpha: { value: 1 },\n          time: { value: 0 },\n          size: { value: 1 },\n          distortionScale: { value: 20 },\n          textureMatrix: { value: new Ie() },\n          sunColor: { value: new be(8355711) },\n          sunDirection: { value: new $(0.70707, 0.70707, 0) },\n          eye: { value: new $() },\n          waterColor: { value: new be(5592405) }\n        }\n      ]),\n      vertexShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(Ts.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`\n      )\n    }, Y = new bt({\n      fragmentShader: U.fragmentShader,\n      vertexShader: U.vertexShader,\n      uniforms: Dn.clone(U.uniforms),\n      lights: !0,\n      side: g,\n      fog: v\n    });\n    Y.uniforms.mirrorSampler.value = N.texture, Y.uniforms.textureMatrix.value = A, Y.uniforms.alpha.value = a, Y.uniforms.time.value = l, Y.uniforms.normalSampler.value = c, Y.uniforms.sunColor.value = u, Y.uniforms.waterColor.value = d, Y.uniforms.sunDirection.value = f, Y.uniforms.distortionScale.value = m, Y.uniforms.eye.value = h, n.material = Y, n.onBeforeRender = function(V, ne, Z) {\n      if (_.setFromMatrixPosition(n.matrixWorld), M.setFromMatrixPosition(Z.matrixWorld), R.extractRotation(n.matrixWorld), b.set(0, 0, 1), b.applyMatrix4(R), x.subVectors(_, M), x.dot(b) > 0)\n        return;\n      x.reflect(b).negate(), x.add(_), R.extractRotation(Z.matrixWorld), w.set(0, 0, -1), w.applyMatrix4(R), w.add(M), T.subVectors(_, w), T.reflect(b).negate(), T.add(_), C.position.copy(x), C.up.set(0, 1, 0), C.up.applyMatrix4(R), C.up.reflect(b), C.lookAt(T), C.far = Z.far, C.updateMatrixWorld(), C.projectionMatrix.copy(Z.projectionMatrix), A.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), A.multiply(C.projectionMatrix), A.multiply(C.matrixWorldInverse), p.setFromNormalAndCoplanarPoint(b, _), p.applyMatrix4(C.matrixWorldInverse), E.set(p.normal.x, p.normal.y, p.normal.z, p.constant);\n      const ee = C.projectionMatrix;\n      y.x = (Math.sign(E.x) + ee.elements[8]) / ee.elements[0], y.y = (Math.sign(E.y) + ee.elements[9]) / ee.elements[5], y.z = -1, y.w = (1 + ee.elements[10]) / ee.elements[14], E.multiplyScalar(2 / E.dot(y)), ee.elements[2] = E.x, ee.elements[6] = E.y, ee.elements[10] = E.z + 1 - o, ee.elements[14] = E.w, h.setFromMatrixPosition(Z.matrixWorld);\n      const te = V.getRenderTarget(), fe = V.xr.enabled, he = V.shadowMap.autoUpdate;\n      n.visible = !1, V.xr.enabled = !1, V.shadowMap.autoUpdate = !1, V.setRenderTarget(N), V.state.buffers.depth.setMask(!0), V.autoClear === !1 && V.clear(), V.render(ne, C), n.visible = !0, V.xr.enabled = fe, V.shadowMap.autoUpdate = he, V.setRenderTarget(te);\n      const we = Z.viewport;\n      we !== void 0 && V.state.viewport(we);\n    };\n  }\n}\nvar nh = Object.defineProperty, sh = (r, e, t) => e in r ? nh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Za = (r, e, t) => (sh(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nconst Qs = {\n  uniforms: {\n    turbidity: { value: 2 },\n    rayleigh: { value: 1 },\n    mieCoefficient: { value: 5e-3 },\n    mieDirectionalG: { value: 0.8 },\n    sunPosition: { value: new $() },\n    up: { value: new $(0, 1, 0) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n      uniform vec3 sunPosition;\n      uniform float rayleigh;\n      uniform float turbidity;\n      uniform float mieCoefficient;\n      uniform vec3 up;\n\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      // constants for atmospheric scattering\n      const float e = 2.71828182845904523536028747135266249775724709369995957;\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      // wavelength of used primaries, according to preetham\n      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n      // mie stuff\n      // K coefficient for the primaries\n      const float v = 4.0;\n      const vec3 K = vec3( 0.686, 0.678, 0.666 );\n      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n      // earth shadow hack\n      // cutoffAngle = pi / 1.95;\n      const float cutoffAngle = 1.6110731556870734;\n      const float steepness = 1.5;\n      const float EE = 1000.0;\n\n      float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n      }\n\n      vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n      }\n\n      void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        gl_Position.z = gl_Position.w; // set z to camera.far\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n      // extinction (absorbtion + out scattering)\n      // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n      // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n      }\n    `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      uniform float mieDirectionalG;\n      uniform vec3 up;\n\n      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n      // constants for atmospheric scattering\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      const float n = 1.0003; // refractive index of air\n      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n      // optical length at zenith for molecules\n      const float rayleighZenithLength = 8.4E3;\n      const float mieZenithLength = 1.25E3;\n      // 66 arc seconds -> degrees, and the cosine of that\n      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n      // 3.0 / ( 16.0 * pi )\n      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n      // 1.0 / ( 4.0 * pi )\n      const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n      float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n      }\n\n      float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n      }\n\n      void main() {\n\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n\n      // optical length\n      // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n      // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n      // in scattering\n        float cosTheta = dot( direction, vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n      // nightsky\n        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n      // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n      #include <tonemapping_fragment>\n      #include <${Ss >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n      }\n    `\n  )\n}, Ka = new bt({\n  name: \"SkyShader\",\n  fragmentShader: Qs.fragmentShader,\n  vertexShader: Qs.vertexShader,\n  uniforms: Dn.clone(Qs.uniforms),\n  side: li,\n  depthWrite: !1\n});\nclass Fo extends de {\n  constructor() {\n    super(new Ht(1, 1, 1), Ka);\n  }\n}\nZa(Fo, \"SkyShader\", Qs);\nZa(Fo, \"material\", Ka);\nconst st = new Il(), Fs = new $();\nclass ih {\n  constructor(e) {\n    let t = e.geometry;\n    t.index && (console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\"), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute(\"position\"), this.colorAttribute = this.geometry.getAttribute(\"color\"), this.weightAttribute = null, this.distribution = null;\n  }\n  setWeightAttribute(e) {\n    return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this;\n  }\n  build() {\n    const e = this.positionAttribute, t = this.weightAttribute, n = new Float32Array(e.count / 3);\n    for (let i = 0; i < e.count; i += 3) {\n      let o = 1;\n      t && (o = t.getX(i) + t.getX(i + 1) + t.getX(i + 2)), st.a.fromBufferAttribute(e, i), st.b.fromBufferAttribute(e, i + 1), st.c.fromBufferAttribute(e, i + 2), o *= st.getArea(), n[i / 3] = o;\n    }\n    this.distribution = new Float32Array(e.count / 3);\n    let s = 0;\n    for (let i = 0; i < n.length; i++)\n      s += n[i], this.distribution[i] = s;\n    return this;\n  }\n  setRandomGenerator(e) {\n    return this.randomFunction = e, this;\n  }\n  sample(e, t, n) {\n    const s = this.sampleFaceIndex();\n    return this.sampleFace(s, e, t, n);\n  }\n  sampleFaceIndex() {\n    const e = this.distribution[this.distribution.length - 1];\n    return this.binarySearch(this.randomFunction() * e);\n  }\n  binarySearch(e) {\n    const t = this.distribution;\n    let n = 0, s = t.length - 1, i = -1;\n    for (; n <= s; ) {\n      const o = Math.ceil((n + s) / 2);\n      if (o === 0 || t[o - 1] <= e && t[o] > e) {\n        i = o;\n        break;\n      } else e < t[o] ? s = o - 1 : n = o + 1;\n    }\n    return i;\n  }\n  sampleFace(e, t, n, s) {\n    let i = this.randomFunction(), o = this.randomFunction();\n    return i + o > 1 && (i = 1 - i, o = 1 - o), st.a.fromBufferAttribute(this.positionAttribute, e * 3), st.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), st.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(st.a, i).addScaledVector(st.b, o).addScaledVector(st.c, 1 - (i + o)), n !== void 0 && st.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (st.a.fromBufferAttribute(this.colorAttribute, e * 3), st.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), st.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), Fs.set(0, 0, 0).addScaledVector(st.a, i).addScaledVector(st.b, o).addScaledVector(st.c, 1 - (i + o)), s.r = Fs.x, s.g = Fs.y, s.b = Fs.z), this;\n  }\n}\nvar oh = Object.defineProperty, rh = (r, e, t) => e in r ? oh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, q = (r, e, t) => (rh(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nclass ah extends Rt {\n  constructor(e, t) {\n    super(), q(this, \"isTransformControls\", !0), q(this, \"visible\", !1), q(this, \"domElement\"), q(this, \"raycaster\", new ya()), q(this, \"gizmo\"), q(this, \"plane\"), q(this, \"tempVector\", new $()), q(this, \"tempVector2\", new $()), q(this, \"tempQuaternion\", new je()), q(this, \"unit\", {\n      X: new $(1, 0, 0),\n      Y: new $(0, 1, 0),\n      Z: new $(0, 0, 1)\n    }), q(this, \"pointStart\", new $()), q(this, \"pointEnd\", new $()), q(this, \"offset\", new $()), q(this, \"rotationAxis\", new $()), q(this, \"startNorm\", new $()), q(this, \"endNorm\", new $()), q(this, \"rotationAngle\", 0), q(this, \"cameraPosition\", new $()), q(this, \"cameraQuaternion\", new je()), q(this, \"cameraScale\", new $()), q(this, \"parentPosition\", new $()), q(this, \"parentQuaternion\", new je()), q(this, \"parentQuaternionInv\", new je()), q(this, \"parentScale\", new $()), q(this, \"worldPositionStart\", new $()), q(this, \"worldQuaternionStart\", new je()), q(this, \"worldScaleStart\", new $()), q(this, \"worldPosition\", new $()), q(this, \"worldQuaternion\", new je()), q(this, \"worldQuaternionInv\", new je()), q(this, \"worldScale\", new $()), q(this, \"eye\", new $()), q(this, \"positionStart\", new $()), q(this, \"quaternionStart\", new je()), q(this, \"scaleStart\", new $()), q(this, \"camera\"), q(this, \"object\"), q(this, \"enabled\", !0), q(this, \"axis\", null), q(this, \"mode\", \"translate\"), q(this, \"translationSnap\", null), q(this, \"rotationSnap\", null), q(this, \"scaleSnap\", null), q(this, \"space\", \"world\"), q(this, \"size\", 1), q(this, \"dragging\", !1), q(this, \"showX\", !0), q(this, \"showY\", !0), q(this, \"showZ\", !0), q(this, \"changeEvent\", { type: \"change\" }), q(this, \"mouseDownEvent\", { type: \"mouseDown\", mode: this.mode }), q(this, \"mouseUpEvent\", { type: \"mouseUp\", mode: this.mode }), q(this, \"objectChangeEvent\", { type: \"objectChange\" }), q(this, \"intersectObjectWithRay\", (s, i, o) => {\n      const a = i.intersectObject(s, !0);\n      for (let l = 0; l < a.length; l++)\n        if (a[l].object.visible || o)\n          return a[l];\n      return !1;\n    }), q(this, \"attach\", (s) => (this.object = s, this.visible = !0, this)), q(this, \"detach\", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), q(this, \"reset\", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), q(this, \"updateMatrixWorld\", () => {\n      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error(\"TransformControls: The attached 3D object must be a part of the scene graph.\") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();\n    }), q(this, \"pointerHover\", (s) => {\n      if (this.object === void 0 || this.dragging === !0)\n        return;\n      this.raycaster.setFromCamera(s, this.camera);\n      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);\n      i ? this.axis = i.object.name : this.axis = null;\n    }), q(this, \"pointerDown\", (s) => {\n      if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {\n        this.raycaster.setFromCamera(s, this.camera);\n        const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);\n        if (i) {\n          let o = this.space;\n          if (this.mode === \"scale\" ? o = \"local\" : (this.axis === \"E\" || this.axis === \"XYZE\" || this.axis === \"XYZ\") && (o = \"world\"), o === \"local\" && this.mode === \"rotate\") {\n            const a = this.rotationSnap;\n            this.axis === \"X\" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === \"Y\" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === \"Z\" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);\n          }\n          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);\n        }\n        this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);\n      }\n    }), q(this, \"pointerMove\", (s) => {\n      const i = this.axis, o = this.mode, a = this.object;\n      let l = this.space;\n      if (o === \"scale\" ? l = \"local\" : (i === \"E\" || i === \"XYZE\" || i === \"XYZ\") && (l = \"world\"), a === void 0 || i === null || this.dragging === !1 || s.button !== -1)\n        return;\n      this.raycaster.setFromCamera(s, this.camera);\n      const c = this.intersectObjectWithRay(this.plane, this.raycaster, !0);\n      if (c) {\n        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), o === \"translate\")\n          this.offset.copy(this.pointEnd).sub(this.pointStart), l === \"local\" && i !== \"XYZ\" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf(\"X\") === -1 && (this.offset.x = 0), i.indexOf(\"Y\") === -1 && (this.offset.y = 0), i.indexOf(\"Z\") === -1 && (this.offset.z = 0), l === \"local\" && i !== \"XYZ\" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (l === \"local\" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search(\"X\") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search(\"Y\") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search(\"Z\") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), l === \"world\" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), i.search(\"X\") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search(\"Y\") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search(\"Z\") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));\n        else if (o === \"scale\") {\n          if (i.search(\"XYZ\") !== -1) {\n            let f = this.pointEnd.length() / this.pointStart.length();\n            this.pointEnd.dot(this.pointStart) < 0 && (f *= -1), this.tempVector2.set(f, f, f);\n          } else\n            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search(\"X\") === -1 && (this.tempVector2.x = 1), i.search(\"Y\") === -1 && (this.tempVector2.y = 1), i.search(\"Z\") === -1 && (this.tempVector2.z = 1);\n          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search(\"X\") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search(\"Y\") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search(\"Z\") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));\n        } else if (o === \"rotate\") {\n          this.offset.copy(this.pointEnd).sub(this.pointStart);\n          const f = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));\n          i === \"E\" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === \"XYZE\" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * f) : (i === \"X\" || i === \"Y\" || i === \"Z\") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), l === \"local\" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * f), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), l === \"local\" && i !== \"E\" && i !== \"XYZE\" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());\n        }\n        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);\n      }\n    }), q(this, \"pointerUp\", (s) => {\n      s.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);\n    }), q(this, \"getPointer\", (s) => {\n      var i;\n      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))\n        return {\n          x: 0,\n          y: 0,\n          button: s.button\n        };\n      {\n        const o = s.changedTouches ? s.changedTouches[0] : s, a = this.domElement.getBoundingClientRect();\n        return {\n          x: (o.clientX - a.left) / a.width * 2 - 1,\n          y: -(o.clientY - a.top) / a.height * 2 + 1,\n          button: s.button\n        };\n      }\n    }), q(this, \"onPointerHover\", (s) => {\n      if (this.enabled)\n        switch (s.pointerType) {\n          case \"mouse\":\n          case \"pen\":\n            this.pointerHover(this.getPointer(s));\n            break;\n        }\n    }), q(this, \"onPointerDown\", (s) => {\n      !this.enabled || !this.domElement || (this.domElement.style.touchAction = \"none\", this.domElement.ownerDocument.addEventListener(\"pointermove\", this.onPointerMove), this.pointerHover(this.getPointer(s)), this.pointerDown(this.getPointer(s)));\n    }), q(this, \"onPointerMove\", (s) => {\n      this.enabled && this.pointerMove(this.getPointer(s));\n    }), q(this, \"onPointerUp\", (s) => {\n      !this.enabled || !this.domElement || (this.domElement.style.touchAction = \"\", this.domElement.ownerDocument.removeEventListener(\"pointermove\", this.onPointerMove), this.pointerUp(this.getPointer(s)));\n    }), q(this, \"getMode\", () => this.mode), q(this, \"setMode\", (s) => {\n      this.mode = s;\n    }), q(this, \"setTranslationSnap\", (s) => {\n      this.translationSnap = s;\n    }), q(this, \"setRotationSnap\", (s) => {\n      this.rotationSnap = s;\n    }), q(this, \"setScaleSnap\", (s) => {\n      this.scaleSnap = s;\n    }), q(this, \"setSize\", (s) => {\n      this.size = s;\n    }), q(this, \"setSpace\", (s) => {\n      this.space = s;\n    }), q(this, \"update\", () => {\n      console.warn(\n        \"THREE.TransformControls: update function has no more functionality and therefore has been deprecated.\"\n      );\n    }), q(this, \"connect\", (s) => {\n      s === document && console.error(\n        'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.'\n      ), this.domElement = s, this.domElement.addEventListener(\"pointerdown\", this.onPointerDown), this.domElement.addEventListener(\"pointermove\", this.onPointerHover), this.domElement.ownerDocument.addEventListener(\"pointerup\", this.onPointerUp);\n    }), q(this, \"dispose\", () => {\n      var s, i, o, a, l, c;\n      (s = this.domElement) == null || s.removeEventListener(\"pointerdown\", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener(\"pointermove\", this.onPointerHover), (a = (o = this.domElement) == null ? void 0 : o.ownerDocument) == null || a.removeEventListener(\"pointermove\", this.onPointerMove), (c = (l = this.domElement) == null ? void 0 : l.ownerDocument) == null || c.removeEventListener(\"pointerup\", this.onPointerUp), this.traverse((f) => {\n        const u = f;\n        u.geometry && u.geometry.dispose(), u.material && u.material.dispose();\n      });\n    }), this.domElement = t, this.camera = e, this.gizmo = new lh(), this.add(this.gizmo), this.plane = new ch(), this.add(this.plane);\n    const n = (s, i) => {\n      let o = i;\n      Object.defineProperty(this, s, {\n        get: function() {\n          return o !== void 0 ? o : i;\n        },\n        set: function(a) {\n          o !== a && (o = a, this.plane[s] = a, this.gizmo[s] = a, this.dispatchEvent({ type: s + \"-changed\", value: a }), this.dispatchEvent(this.changeEvent));\n        }\n      }), this[s] = i, this.plane[s] = i, this.gizmo[s] = i;\n    };\n    n(\"camera\", this.camera), n(\"object\", this.object), n(\"enabled\", this.enabled), n(\"axis\", this.axis), n(\"mode\", this.mode), n(\"translationSnap\", this.translationSnap), n(\"rotationSnap\", this.rotationSnap), n(\"scaleSnap\", this.scaleSnap), n(\"space\", this.space), n(\"size\", this.size), n(\"dragging\", this.dragging), n(\"showX\", this.showX), n(\"showY\", this.showY), n(\"showZ\", this.showZ), n(\"worldPosition\", this.worldPosition), n(\"worldPositionStart\", this.worldPositionStart), n(\"worldQuaternion\", this.worldQuaternion), n(\"worldQuaternionStart\", this.worldQuaternionStart), n(\"cameraPosition\", this.cameraPosition), n(\"cameraQuaternion\", this.cameraQuaternion), n(\"pointStart\", this.pointStart), n(\"pointEnd\", this.pointEnd), n(\"rotationAxis\", this.rotationAxis), n(\"rotationAngle\", this.rotationAngle), n(\"eye\", this.eye), t !== void 0 && this.connect(t);\n  }\n}\nclass lh extends Rt {\n  constructor() {\n    super(), q(this, \"isTransformControlsGizmo\", !0), q(this, \"type\", \"TransformControlsGizmo\"), q(this, \"tempVector\", new $(0, 0, 0)), q(this, \"tempEuler\", new vt()), q(this, \"alignVector\", new $(0, 1, 0)), q(this, \"zeroVector\", new $(0, 0, 0)), q(this, \"lookAtMatrix\", new Ie()), q(this, \"tempQuaternion\", new je()), q(this, \"tempQuaternion2\", new je()), q(this, \"identityQuaternion\", new je()), q(this, \"unitX\", new $(1, 0, 0)), q(this, \"unitY\", new $(0, 1, 0)), q(this, \"unitZ\", new $(0, 0, 1)), q(this, \"gizmo\"), q(this, \"picker\"), q(this, \"helper\"), q(this, \"rotationAxis\", new $()), q(this, \"cameraPosition\", new $()), q(this, \"worldPositionStart\", new $()), q(this, \"worldQuaternionStart\", new je()), q(this, \"worldPosition\", new $()), q(this, \"worldQuaternion\", new je()), q(this, \"eye\", new $()), q(this, \"camera\", null), q(this, \"enabled\", !0), q(this, \"axis\", null), q(this, \"mode\", \"translate\"), q(this, \"space\", \"world\"), q(this, \"size\", 1), q(this, \"dragging\", !1), q(this, \"showX\", !0), q(this, \"showY\", !0), q(this, \"showZ\", !0), q(this, \"updateMatrixWorld\", () => {\n      let te = this.space;\n      this.mode === \"scale\" && (te = \"local\");\n      const fe = te === \"local\" ? this.worldQuaternion : this.identityQuaternion;\n      this.gizmo.translate.visible = this.mode === \"translate\", this.gizmo.rotate.visible = this.mode === \"rotate\", this.gizmo.scale.visible = this.mode === \"scale\", this.helper.translate.visible = this.mode === \"translate\", this.helper.rotate.visible = this.mode === \"rotate\", this.helper.scale.visible = this.mode === \"scale\";\n      let he = [];\n      he = he.concat(this.picker[this.mode].children), he = he.concat(this.gizmo[this.mode].children), he = he.concat(this.helper[this.mode].children);\n      for (let we = 0; we < he.length; we++) {\n        const I = he[we];\n        I.visible = !0, I.rotation.set(0, 0, 0), I.position.copy(this.worldPosition);\n        let B;\n        if (this.camera.isOrthographicCamera ? B = (this.camera.top - this.camera.bottom) / this.camera.zoom : B = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), I.scale.set(1, 1, 1).multiplyScalar(B * this.size / 7), I.tag === \"helper\") {\n          I.visible = !1, I.name === \"AXIS\" ? (I.position.copy(this.worldPositionStart), I.visible = !!this.axis, this.axis === \"X\" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), I.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === \"Y\" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), I.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === \"Z\" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), I.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === \"XYZE\" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), I.quaternion.setFromRotationMatrix(\n            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)\n          ), I.quaternion.multiply(this.tempQuaternion), I.visible = this.dragging), this.axis === \"E\" && (I.visible = !1)) : I.name === \"START\" ? (I.position.copy(this.worldPositionStart), I.visible = this.dragging) : I.name === \"END\" ? (I.position.copy(this.worldPosition), I.visible = this.dragging) : I.name === \"DELTA\" ? (I.position.copy(this.worldPositionStart), I.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), I.scale.copy(this.tempVector), I.visible = this.dragging) : (I.quaternion.copy(fe), this.dragging ? I.position.copy(this.worldPositionStart) : I.position.copy(this.worldPosition), this.axis && (I.visible = this.axis.search(I.name) !== -1));\n          continue;\n        }\n        I.quaternion.copy(fe), this.mode === \"translate\" || this.mode === \"scale\" ? ((I.name === \"X\" || I.name === \"XYZX\") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), (I.name === \"Y\" || I.name === \"XYZY\") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), (I.name === \"Z\" || I.name === \"XYZZ\") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === \"XY\" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === \"YZ\" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === \"XZ\" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name.search(\"X\") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye) < 0 ? I.tag === \"fwd\" ? I.visible = !1 : I.scale.x *= -1 : I.tag === \"bwd\" && (I.visible = !1)), I.name.search(\"Y\") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye) < 0 ? I.tag === \"fwd\" ? I.visible = !1 : I.scale.y *= -1 : I.tag === \"bwd\" && (I.visible = !1)), I.name.search(\"Z\") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye) < 0 ? I.tag === \"fwd\" ? I.visible = !1 : I.scale.z *= -1 : I.tag === \"bwd\" && (I.visible = !1))) : this.mode === \"rotate\" && (this.tempQuaternion2.copy(fe), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(fe).invert()), I.name.search(\"E\") !== -1 && I.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), I.name === \"X\" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion)), I.name === \"Y\" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion)), I.name === \"Z\" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion))), I.visible = I.visible && (I.name.indexOf(\"X\") === -1 || this.showX), I.visible = I.visible && (I.name.indexOf(\"Y\") === -1 || this.showY), I.visible = I.visible && (I.name.indexOf(\"Z\") === -1 || this.showZ), I.visible = I.visible && (I.name.indexOf(\"E\") === -1 || this.showX && this.showY && this.showZ), I.material.tempOpacity = I.material.tempOpacity || I.material.opacity, I.material.tempColor = I.material.tempColor || I.material.color.clone(), I.material.color.copy(I.material.tempColor), I.material.opacity = I.material.tempOpacity, this.enabled ? this.axis && (I.name === this.axis ? (I.material.opacity = 1, I.material.color.lerp(new be(1, 1, 1), 0.5)) : this.axis.split(\"\").some(function(D) {\n          return I.name === D;\n        }) ? (I.material.opacity = 1, I.material.color.lerp(new be(1, 1, 1), 0.5)) : (I.material.opacity *= 0.25, I.material.color.lerp(new be(1, 1, 1), 0.5))) : (I.material.opacity *= 0.5, I.material.color.lerp(new be(1, 1, 1), 0.5));\n      }\n      super.updateMatrixWorld();\n    });\n    const e = new $t({\n      depthTest: !1,\n      depthWrite: !1,\n      transparent: !0,\n      side: on,\n      fog: !1,\n      toneMapped: !1\n    }), t = new ws({\n      depthTest: !1,\n      depthWrite: !1,\n      transparent: !0,\n      linewidth: 1,\n      fog: !1,\n      toneMapped: !1\n    }), n = e.clone();\n    n.opacity = 0.15;\n    const s = e.clone();\n    s.opacity = 0.33;\n    const i = e.clone();\n    i.color.set(16711680);\n    const o = e.clone();\n    o.color.set(65280);\n    const a = e.clone();\n    a.color.set(255);\n    const l = e.clone();\n    l.opacity = 0.25;\n    const c = l.clone();\n    c.color.set(16776960);\n    const f = l.clone();\n    f.color.set(65535);\n    const u = l.clone();\n    u.color.set(16711935), e.clone().color.set(16776960);\n    const h = t.clone();\n    h.color.set(16711680);\n    const m = t.clone();\n    m.color.set(65280);\n    const g = t.clone();\n    g.color.set(255);\n    const v = t.clone();\n    v.color.set(65535);\n    const p = t.clone();\n    p.color.set(16711935);\n    const b = t.clone();\n    b.color.set(16776960);\n    const _ = t.clone();\n    _.color.set(7895160);\n    const M = b.clone();\n    M.opacity = 0.25;\n    const R = new Ct(0, 0.05, 0.2, 12, 1, !1), w = new Ht(0.125, 0.125, 0.125), E = new ht();\n    E.setAttribute(\"position\", new gt([0, 0, 0, 1, 0, 0], 3));\n    const x = (te, fe) => {\n      const he = new ht(), we = [];\n      for (let I = 0; I <= 64 * fe; ++I)\n        we.push(0, Math.cos(I / 32 * Math.PI) * te, Math.sin(I / 32 * Math.PI) * te);\n      return he.setAttribute(\"position\", new gt(we, 3)), he;\n    }, T = () => {\n      const te = new ht();\n      return te.setAttribute(\"position\", new gt([0, 0, 0, 1, 1, 1], 3)), te;\n    }, y = {\n      X: [\n        [new de(R, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, \"fwd\"],\n        [new de(R, i), [1, 0, 0], [0, 0, Math.PI / 2], null, \"bwd\"],\n        [new ke(E, h)]\n      ],\n      Y: [\n        [new de(R, o), [0, 1, 0], null, null, \"fwd\"],\n        [new de(R, o), [0, 1, 0], [Math.PI, 0, 0], null, \"bwd\"],\n        [new ke(E, m), null, [0, 0, Math.PI / 2]]\n      ],\n      Z: [\n        [new de(R, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, \"fwd\"],\n        [new de(R, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, \"bwd\"],\n        [new ke(E, g), null, [0, -Math.PI / 2, 0]]\n      ],\n      XYZ: [[new de(new Mn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],\n      XY: [\n        [new de(new jt(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],\n        [new ke(E, b), [0.18, 0.3, 0], null, [0.125, 1, 1]],\n        [new ke(E, b), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]\n      ],\n      YZ: [\n        [new de(new jt(0.295, 0.295), f.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],\n        [new ke(E, v), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],\n        [new ke(E, v), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]\n      ],\n      XZ: [\n        [\n          new de(new jt(0.295, 0.295), u.clone()),\n          [0.15, 0, 0.15],\n          [-Math.PI / 2, 0, 0]\n        ],\n        [new ke(E, p), [0.18, 0, 0.3], null, [0.125, 1, 1]],\n        [new ke(E, p), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]\n      ]\n    }, A = {\n      X: [[new de(new Ct(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n      Y: [[new de(new Ct(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],\n      Z: [[new de(new Ct(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n      XYZ: [[new de(new Mn(0.2, 0), n)]],\n      XY: [[new de(new jt(0.4, 0.4), n), [0.2, 0.2, 0]]],\n      YZ: [[new de(new jt(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],\n      XZ: [[new de(new jt(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]\n    }, C = {\n      START: [[new de(new Mn(0.01, 2), s), null, null, null, \"helper\"]],\n      END: [[new de(new Mn(0.01, 2), s), null, null, null, \"helper\"]],\n      DELTA: [[new ke(T(), s), null, null, null, \"helper\"]],\n      X: [[new ke(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], \"helper\"]],\n      Y: [[new ke(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], \"helper\"]],\n      Z: [[new ke(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], \"helper\"]]\n    }, N = {\n      X: [\n        [new ke(x(1, 0.5), h)],\n        [new de(new Mn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]\n      ],\n      Y: [\n        [new ke(x(1, 0.5), m), null, [0, 0, -Math.PI / 2]],\n        [new de(new Mn(0.04, 0), o), [0, 0, 0.99], null, [3, 1, 1]]\n      ],\n      Z: [\n        [new ke(x(1, 0.5), g), null, [0, Math.PI / 2, 0]],\n        [new de(new Mn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]\n      ],\n      E: [\n        [new ke(x(1.25, 1), M), null, [0, Math.PI / 2, 0]],\n        [\n          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),\n          [1.17, 0, 0],\n          [0, 0, -Math.PI / 2],\n          [1, 1, 1e-3]\n        ],\n        [\n          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),\n          [-1.17, 0, 0],\n          [0, 0, Math.PI / 2],\n          [1, 1, 1e-3]\n        ],\n        [\n          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),\n          [0, -1.17, 0],\n          [Math.PI, 0, 0],\n          [1, 1, 1e-3]\n        ],\n        [\n          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),\n          [0, 1.17, 0],\n          [0, 0, 0],\n          [1, 1, 1e-3]\n        ]\n      ],\n      XYZE: [[new ke(x(1, 1), _), null, [0, Math.PI / 2, 0]]]\n    }, U = {\n      AXIS: [[new ke(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], \"helper\"]]\n    }, Y = {\n      X: [[new de(new Ds(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],\n      Y: [[new de(new Ds(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],\n      Z: [[new de(new Ds(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],\n      E: [[new de(new Ds(1.25, 0.1, 2, 24), n)]],\n      XYZE: [[new de(new Ol(0.7, 10, 8), n)]]\n    }, V = {\n      X: [\n        [new de(w, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],\n        [new ke(E, h), null, null, [0.8, 1, 1]]\n      ],\n      Y: [\n        [new de(w, o), [0, 0.8, 0]],\n        [new ke(E, m), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]\n      ],\n      Z: [\n        [new de(w, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],\n        [new ke(E, g), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]\n      ],\n      XY: [\n        [new de(w, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],\n        [new ke(E, b), [0.855, 0.98, 0], null, [0.125, 1, 1]],\n        [new ke(E, b), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]\n      ],\n      YZ: [\n        [new de(w, f), [0, 0.85, 0.85], null, [0.2, 2, 2]],\n        [new ke(E, v), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],\n        [new ke(E, v), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]\n      ],\n      XZ: [\n        [new de(w, u), [0.85, 0, 0.85], null, [2, 0.2, 2]],\n        [new ke(E, p), [0.855, 0, 0.98], null, [0.125, 1, 1]],\n        [new ke(E, p), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]\n      ],\n      XYZX: [[new de(new Ht(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],\n      XYZY: [[new de(new Ht(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],\n      XYZZ: [[new de(new Ht(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]\n    }, ne = {\n      X: [[new de(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],\n      Y: [[new de(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],\n      Z: [[new de(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],\n      XY: [[new de(w, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],\n      YZ: [[new de(w, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],\n      XZ: [[new de(w, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],\n      XYZX: [[new de(new Ht(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],\n      XYZY: [[new de(new Ht(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],\n      XYZZ: [[new de(new Ht(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]\n    }, Z = {\n      X: [[new ke(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], \"helper\"]],\n      Y: [[new ke(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], \"helper\"]],\n      Z: [[new ke(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], \"helper\"]]\n    }, ee = (te) => {\n      const fe = new Rt();\n      for (let he in te)\n        for (let we = te[he].length; we--; ) {\n          const I = te[he][we][0].clone(), B = te[he][we][1], D = te[he][we][2], O = te[he][we][3], z = te[he][we][4];\n          I.name = he, I.tag = z, B && I.position.set(B[0], B[1], B[2]), D && I.rotation.set(D[0], D[1], D[2]), O && I.scale.set(O[0], O[1], O[2]), I.updateMatrix();\n          const S = I.geometry.clone();\n          S.applyMatrix4(I.matrix), I.geometry = S, I.renderOrder = 1 / 0, I.position.set(0, 0, 0), I.rotation.set(0, 0, 0), I.scale.set(1, 1, 1), fe.add(I);\n        }\n      return fe;\n    };\n    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ee(y)), this.add(this.gizmo.rotate = ee(N)), this.add(this.gizmo.scale = ee(V)), this.add(this.picker.translate = ee(A)), this.add(this.picker.rotate = ee(Y)), this.add(this.picker.scale = ee(ne)), this.add(this.helper.translate = ee(C)), this.add(this.helper.rotate = ee(U)), this.add(this.helper.scale = ee(Z)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;\n  }\n}\nclass ch extends de {\n  constructor() {\n    super(\n      new jt(1e5, 1e5, 2, 2),\n      new $t({\n        visible: !1,\n        wireframe: !0,\n        side: on,\n        transparent: !0,\n        opacity: 0.1,\n        toneMapped: !1\n      })\n    ), q(this, \"isTransformControlsPlane\", !0), q(this, \"type\", \"TransformControlsPlane\"), q(this, \"unitX\", new $(1, 0, 0)), q(this, \"unitY\", new $(0, 1, 0)), q(this, \"unitZ\", new $(0, 0, 1)), q(this, \"tempVector\", new $()), q(this, \"dirVector\", new $()), q(this, \"alignVector\", new $()), q(this, \"tempMatrix\", new Ie()), q(this, \"identityQuaternion\", new je()), q(this, \"cameraQuaternion\", new je()), q(this, \"worldPosition\", new $()), q(this, \"worldQuaternion\", new je()), q(this, \"eye\", new $()), q(this, \"axis\", null), q(this, \"mode\", \"translate\"), q(this, \"space\", \"world\"), q(this, \"updateMatrixWorld\", () => {\n      let e = this.space;\n      switch (this.position.copy(this.worldPosition), this.mode === \"scale\" && (e = \"local\"), this.unitX.set(1, 0, 0).applyQuaternion(e === \"local\" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === \"local\" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === \"local\" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {\n        case \"translate\":\n        case \"scale\":\n          switch (this.axis) {\n            case \"X\":\n              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);\n              break;\n            case \"Y\":\n              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);\n              break;\n            case \"Z\":\n              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);\n              break;\n            case \"XY\":\n              this.dirVector.copy(this.unitZ);\n              break;\n            case \"YZ\":\n              this.dirVector.copy(this.unitX);\n              break;\n            case \"XZ\":\n              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);\n              break;\n            case \"XYZ\":\n            case \"E\":\n              this.dirVector.set(0, 0, 0);\n              break;\n          }\n          break;\n        case \"rotate\":\n        default:\n          this.dirVector.set(0, 0, 0);\n      }\n      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();\n    });\n  }\n}\nvar uh = Object.defineProperty, hh = (r, e, t) => e in r ? uh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Je = (r, e, t) => (hh(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nconst zn = new vt(0, 0, 0, \"YXZ\"), Gn = new $(), fh = { type: \"change\" }, dh = { type: \"lock\" }, ph = { type: \"unlock\" }, lr = Math.PI / 2;\nclass qa extends _a {\n  constructor(e, t) {\n    super(), Je(this, \"camera\"), Je(this, \"domElement\"), Je(this, \"isLocked\"), Je(this, \"minPolarAngle\"), Je(this, \"maxPolarAngle\"), Je(this, \"pointerSpeed\"), Je(this, \"onMouseMove\", (n) => {\n      if (!this.domElement || this.isLocked === !1)\n        return;\n      const s = n.movementX || n.mozMovementX || n.webkitMovementX || 0, i = n.movementY || n.mozMovementY || n.webkitMovementY || 0;\n      zn.setFromQuaternion(this.camera.quaternion), zn.y -= s * 2e-3 * this.pointerSpeed, zn.x -= i * 2e-3 * this.pointerSpeed, zn.x = Math.max(lr - this.maxPolarAngle, Math.min(lr - this.minPolarAngle, zn.x)), this.camera.quaternion.setFromEuler(zn), this.dispatchEvent(fh);\n    }), Je(this, \"onPointerlockChange\", () => {\n      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(dh), this.isLocked = !0) : (this.dispatchEvent(ph), this.isLocked = !1));\n    }), Je(this, \"onPointerlockError\", () => {\n      console.error(\"THREE.PointerLockControls: Unable to use Pointer Lock API\");\n    }), Je(this, \"connect\", (n) => {\n      this.domElement = n || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener(\"mousemove\", this.onMouseMove), this.domElement.ownerDocument.addEventListener(\"pointerlockchange\", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener(\"pointerlockerror\", this.onPointerlockError));\n    }), Je(this, \"disconnect\", () => {\n      this.domElement && (this.domElement.ownerDocument.removeEventListener(\"mousemove\", this.onMouseMove), this.domElement.ownerDocument.removeEventListener(\"pointerlockchange\", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener(\"pointerlockerror\", this.onPointerlockError));\n    }), Je(this, \"dispose\", () => {\n      this.disconnect();\n    }), Je(this, \"getObject\", () => this.camera), Je(this, \"direction\", new $(0, 0, -1)), Je(this, \"getDirection\", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Je(this, \"moveForward\", (n) => {\n      Gn.setFromMatrixColumn(this.camera.matrix, 0), Gn.crossVectors(this.camera.up, Gn), this.camera.position.addScaledVector(Gn, n);\n    }), Je(this, \"moveRight\", (n) => {\n      Gn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Gn, n);\n    }), Je(this, \"lock\", () => {\n      this.domElement && this.domElement.requestPointerLock();\n    }), Je(this, \"unlock\", () => {\n      this.domElement && this.domElement.ownerDocument.exitPointerLock();\n    }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);\n  }\n}\nvar mh = Object.defineProperty, gh = (r, e, t) => e in r ? mh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, _e = (r, e, t) => (gh(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nconst zs = new Dl(), cr = new bs(), vh = Math.cos(70 * (Math.PI / 180)), ur = (r, e) => (r % e + e) % e;\nclass Qa extends _a {\n  constructor(e, t) {\n    super(), _e(this, \"object\"), _e(this, \"domElement\"), _e(this, \"enabled\", !0), _e(this, \"target\", new $()), _e(this, \"minDistance\", 0), _e(this, \"maxDistance\", 1 / 0), _e(this, \"minZoom\", 0), _e(this, \"maxZoom\", 1 / 0), _e(this, \"minPolarAngle\", 0), _e(this, \"maxPolarAngle\", Math.PI), _e(this, \"minAzimuthAngle\", -1 / 0), _e(this, \"maxAzimuthAngle\", 1 / 0), _e(this, \"enableDamping\", !1), _e(this, \"dampingFactor\", 0.05), _e(this, \"enableZoom\", !0), _e(this, \"zoomSpeed\", 1), _e(this, \"enableRotate\", !0), _e(this, \"rotateSpeed\", 1), _e(this, \"enablePan\", !0), _e(this, \"panSpeed\", 1), _e(this, \"screenSpacePanning\", !0), _e(this, \"keyPanSpeed\", 7), _e(this, \"zoomToCursor\", !1), _e(this, \"autoRotate\", !1), _e(this, \"autoRotateSpeed\", 2), _e(this, \"reverseOrbit\", !1), _e(this, \"reverseHorizontalOrbit\", !1), _e(this, \"reverseVerticalOrbit\", !1), _e(this, \"keys\", { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" }), _e(this, \"mouseButtons\", {\n      LEFT: Dt.ROTATE,\n      MIDDLE: Dt.DOLLY,\n      RIGHT: Dt.PAN\n    }), _e(this, \"touches\", { ONE: Vt.ROTATE, TWO: Vt.DOLLY_PAN }), _e(this, \"target0\"), _e(this, \"position0\"), _e(this, \"zoom0\"), _e(this, \"_domElementKeyEvents\", null), _e(this, \"getPolarAngle\"), _e(this, \"getAzimuthalAngle\"), _e(this, \"setPolarAngle\"), _e(this, \"setAzimuthalAngle\"), _e(this, \"getDistance\"), _e(this, \"getZoomScale\"), _e(this, \"listenToKeyEvents\"), _e(this, \"stopListenToKeyEvents\"), _e(this, \"saveState\"), _e(this, \"reset\"), _e(this, \"update\"), _e(this, \"connect\"), _e(this, \"dispose\"), _e(this, \"dollyIn\"), _e(this, \"dollyOut\"), _e(this, \"getScale\"), _e(this, \"setScale\"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => f.phi, this.getAzimuthalAngle = () => f.theta, this.setPolarAngle = (W) => {\n      let le = ur(W, 2 * Math.PI), Ee = f.phi;\n      Ee < 0 && (Ee += 2 * Math.PI), le < 0 && (le += 2 * Math.PI);\n      let Ue = Math.abs(le - Ee);\n      2 * Math.PI - Ue < Ue && (le < Ee ? le += 2 * Math.PI : Ee += 2 * Math.PI), u.phi = le - Ee, n.update();\n    }, this.setAzimuthalAngle = (W) => {\n      let le = ur(W, 2 * Math.PI), Ee = f.theta;\n      Ee < 0 && (Ee += 2 * Math.PI), le < 0 && (le += 2 * Math.PI);\n      let Ue = Math.abs(le - Ee);\n      2 * Math.PI - Ue < Ue && (le < Ee ? le += 2 * Math.PI : Ee += 2 * Math.PI), u.theta = le - Ee, n.update();\n    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (W) => {\n      W.addEventListener(\"keydown\", Nt), this._domElementKeyEvents = W;\n    }, this.stopListenToKeyEvents = () => {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", Nt), this._domElementKeyEvents = null;\n    }, this.saveState = () => {\n      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;\n    }, this.reset = () => {\n      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(s), n.update(), l = a.NONE;\n    }, this.update = (() => {\n      const W = new $(), le = new $(0, 1, 0), Ee = new je().setFromUnitVectors(e.up, le), Ue = Ee.clone().invert(), nt = new $(), qt = new je(), hn = 2 * Math.PI;\n      return function() {\n        const Xo = n.object.position;\n        Ee.setFromUnitVectors(e.up, le), Ue.copy(Ee).invert(), W.copy(Xo).sub(n.target), W.applyQuaternion(Ee), f.setFromVector3(W), n.autoRotate && l === a.NONE && U(C()), n.enableDamping ? (f.theta += u.theta * n.dampingFactor, f.phi += u.phi * n.dampingFactor) : (f.theta += u.theta, f.phi += u.phi);\n        let Qt = n.minAzimuthAngle, Jt = n.maxAzimuthAngle;\n        isFinite(Qt) && isFinite(Jt) && (Qt < -Math.PI ? Qt += hn : Qt > Math.PI && (Qt -= hn), Jt < -Math.PI ? Jt += hn : Jt > Math.PI && (Jt -= hn), Qt <= Jt ? f.theta = Math.max(Qt, Math.min(Jt, f.theta)) : f.theta = f.theta > (Qt + Jt) / 2 ? Math.max(Qt, f.theta) : Math.min(Jt, f.theta)), f.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, f.phi)), f.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.zoomToCursor && T || n.object.isOrthographicCamera ? f.radius = we(f.radius) : f.radius = we(f.radius * d), W.setFromSpherical(f), W.applyQuaternion(Ue), Xo.copy(n.target).add(W), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), h.set(0, 0, 0));\n        let os = !1;\n        if (n.zoomToCursor && T) {\n          let rs = null;\n          if (n.object instanceof kt && n.object.isPerspectiveCamera) {\n            const as = W.length();\n            rs = we(as * d);\n            const Os = as - rs;\n            n.object.position.addScaledVector(E, Os), n.object.updateMatrixWorld();\n          } else if (n.object.isOrthographicCamera) {\n            const as = new $(x.x, x.y, 0);\n            as.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix(), os = !0;\n            const Os = new $(x.x, x.y, 0);\n            Os.unproject(n.object), n.object.position.sub(Os).add(as), n.object.updateMatrixWorld(), rs = W.length();\n          } else\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\"), n.zoomToCursor = !1;\n          rs !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(rs).add(n.object.position) : (zs.origin.copy(n.object.position), zs.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(zs.direction)) < vh ? e.lookAt(n.target) : (cr.setFromNormalAndCoplanarPoint(n.object.up, n.target), zs.intersectPlane(cr, n.target))));\n        } else n.object instanceof _n && n.object.isOrthographicCamera && (os = d !== 1, os && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix()));\n        return d = 1, T = !1, os || nt.distanceToSquared(n.object.position) > c || 8 * (1 - qt.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), nt.copy(n.object.position), qt.copy(n.object.quaternion), os = !1, !0) : !1;\n      };\n    })(), this.connect = (W) => {\n      n.domElement = W, n.domElement.style.touchAction = \"none\", n.domElement.addEventListener(\"contextmenu\", is), n.domElement.addEventListener(\"pointerdown\", Re), n.domElement.addEventListener(\"pointercancel\", He), n.domElement.addEventListener(\"wheel\", En);\n    }, this.dispose = () => {\n      var W, le, Ee, Ue, nt, qt;\n      n.domElement && (n.domElement.style.touchAction = \"auto\"), (W = n.domElement) == null || W.removeEventListener(\"contextmenu\", is), (le = n.domElement) == null || le.removeEventListener(\"pointerdown\", Re), (Ee = n.domElement) == null || Ee.removeEventListener(\"pointercancel\", He), (Ue = n.domElement) == null || Ue.removeEventListener(\"wheel\", En), (nt = n.domElement) == null || nt.ownerDocument.removeEventListener(\"pointermove\", Ke), (qt = n.domElement) == null || qt.ownerDocument.removeEventListener(\"pointerup\", He), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener(\"keydown\", Nt);\n    };\n    const n = this, s = { type: \"change\" }, i = { type: \"start\" }, o = { type: \"end\" }, a = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    let l = a.NONE;\n    const c = 1e-6, f = new si(), u = new si();\n    let d = 1;\n    const h = new $(), m = new ve(), g = new ve(), v = new ve(), p = new ve(), b = new ve(), _ = new ve(), M = new ve(), R = new ve(), w = new ve(), E = new $(), x = new ve();\n    let T = !1;\n    const y = [], A = {};\n    function C() {\n      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;\n    }\n    function N() {\n      return Math.pow(0.95, n.zoomSpeed);\n    }\n    function U(W) {\n      n.reverseOrbit || n.reverseHorizontalOrbit ? u.theta += W : u.theta -= W;\n    }\n    function Y(W) {\n      n.reverseOrbit || n.reverseVerticalOrbit ? u.phi += W : u.phi -= W;\n    }\n    const V = (() => {\n      const W = new $();\n      return function(Ee, Ue) {\n        W.setFromMatrixColumn(Ue, 0), W.multiplyScalar(-Ee), h.add(W);\n      };\n    })(), ne = (() => {\n      const W = new $();\n      return function(Ee, Ue) {\n        n.screenSpacePanning === !0 ? W.setFromMatrixColumn(Ue, 1) : (W.setFromMatrixColumn(Ue, 0), W.crossVectors(n.object.up, W)), W.multiplyScalar(Ee), h.add(W);\n      };\n    })(), Z = (() => {\n      const W = new $();\n      return function(Ee, Ue) {\n        const nt = n.domElement;\n        if (nt && n.object instanceof kt && n.object.isPerspectiveCamera) {\n          const qt = n.object.position;\n          W.copy(qt).sub(n.target);\n          let hn = W.length();\n          hn *= Math.tan(n.object.fov / 2 * Math.PI / 180), V(2 * Ee * hn / nt.clientHeight, n.object.matrix), ne(2 * Ue * hn / nt.clientHeight, n.object.matrix);\n        } else nt && n.object instanceof _n && n.object.isOrthographicCamera ? (V(\n          Ee * (n.object.right - n.object.left) / n.object.zoom / nt.clientWidth,\n          n.object.matrix\n        ), ne(\n          Ue * (n.object.top - n.object.bottom) / n.object.zoom / nt.clientHeight,\n          n.object.matrix\n        )) : (console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\"), n.enablePan = !1);\n      };\n    })();\n    function ee(W) {\n      n.object instanceof kt && n.object.isPerspectiveCamera || n.object instanceof _n && n.object.isOrthographicCamera ? d = W : (console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"), n.enableZoom = !1);\n    }\n    function te(W) {\n      ee(d / W);\n    }\n    function fe(W) {\n      ee(d * W);\n    }\n    function he(W) {\n      if (!n.zoomToCursor || !n.domElement)\n        return;\n      T = !0;\n      const le = n.domElement.getBoundingClientRect(), Ee = W.clientX - le.left, Ue = W.clientY - le.top, nt = le.width, qt = le.height;\n      x.x = Ee / nt * 2 - 1, x.y = -(Ue / qt) * 2 + 1, E.set(x.x, x.y, 1).unproject(n.object).sub(n.object.position).normalize();\n    }\n    function we(W) {\n      return Math.max(n.minDistance, Math.min(n.maxDistance, W));\n    }\n    function I(W) {\n      m.set(W.clientX, W.clientY);\n    }\n    function B(W) {\n      he(W), M.set(W.clientX, W.clientY);\n    }\n    function D(W) {\n      p.set(W.clientX, W.clientY);\n    }\n    function O(W) {\n      g.set(W.clientX, W.clientY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);\n      const le = n.domElement;\n      le && (U(2 * Math.PI * v.x / le.clientHeight), Y(2 * Math.PI * v.y / le.clientHeight)), m.copy(g), n.update();\n    }\n    function z(W) {\n      R.set(W.clientX, W.clientY), w.subVectors(R, M), w.y > 0 ? te(N()) : w.y < 0 && fe(N()), M.copy(R), n.update();\n    }\n    function S(W) {\n      b.set(W.clientX, W.clientY), _.subVectors(b, p).multiplyScalar(n.panSpeed), Z(_.x, _.y), p.copy(b), n.update();\n    }\n    function P(W) {\n      he(W), W.deltaY < 0 ? fe(N()) : W.deltaY > 0 && te(N()), n.update();\n    }\n    function L(W) {\n      let le = !1;\n      switch (W.code) {\n        case n.keys.UP:\n          Z(0, n.keyPanSpeed), le = !0;\n          break;\n        case n.keys.BOTTOM:\n          Z(0, -n.keyPanSpeed), le = !0;\n          break;\n        case n.keys.LEFT:\n          Z(n.keyPanSpeed, 0), le = !0;\n          break;\n        case n.keys.RIGHT:\n          Z(-n.keyPanSpeed, 0), le = !0;\n          break;\n      }\n      le && (W.preventDefault(), n.update());\n    }\n    function X() {\n      if (y.length == 1)\n        m.set(y[0].pageX, y[0].pageY);\n      else {\n        const W = 0.5 * (y[0].pageX + y[1].pageX), le = 0.5 * (y[0].pageY + y[1].pageY);\n        m.set(W, le);\n      }\n    }\n    function H() {\n      if (y.length == 1)\n        p.set(y[0].pageX, y[0].pageY);\n      else {\n        const W = 0.5 * (y[0].pageX + y[1].pageX), le = 0.5 * (y[0].pageY + y[1].pageY);\n        p.set(W, le);\n      }\n    }\n    function j() {\n      const W = y[0].pageX - y[1].pageX, le = y[0].pageY - y[1].pageY, Ee = Math.sqrt(W * W + le * le);\n      M.set(0, Ee);\n    }\n    function K() {\n      n.enableZoom && j(), n.enablePan && H();\n    }\n    function se() {\n      n.enableZoom && j(), n.enableRotate && X();\n    }\n    function ie(W) {\n      if (y.length == 1)\n        g.set(W.pageX, W.pageY);\n      else {\n        const Ee = pi(W), Ue = 0.5 * (W.pageX + Ee.x), nt = 0.5 * (W.pageY + Ee.y);\n        g.set(Ue, nt);\n      }\n      v.subVectors(g, m).multiplyScalar(n.rotateSpeed);\n      const le = n.domElement;\n      le && (U(2 * Math.PI * v.x / le.clientHeight), Y(2 * Math.PI * v.y / le.clientHeight)), m.copy(g);\n    }\n    function G(W) {\n      if (y.length == 1)\n        b.set(W.pageX, W.pageY);\n      else {\n        const le = pi(W), Ee = 0.5 * (W.pageX + le.x), Ue = 0.5 * (W.pageY + le.y);\n        b.set(Ee, Ue);\n      }\n      _.subVectors(b, p).multiplyScalar(n.panSpeed), Z(_.x, _.y), p.copy(b);\n    }\n    function k(W) {\n      const le = pi(W), Ee = W.pageX - le.x, Ue = W.pageY - le.y, nt = Math.sqrt(Ee * Ee + Ue * Ue);\n      R.set(0, nt), w.set(0, Math.pow(R.y / M.y, n.zoomSpeed)), te(w.y), M.copy(R);\n    }\n    function oe(W) {\n      n.enableZoom && k(W), n.enablePan && G(W);\n    }\n    function ge(W) {\n      n.enableZoom && k(W), n.enableRotate && ie(W);\n    }\n    function Re(W) {\n      var le, Ee;\n      n.enabled !== !1 && (y.length === 0 && ((le = n.domElement) == null || le.ownerDocument.addEventListener(\"pointermove\", Ke), (Ee = n.domElement) == null || Ee.ownerDocument.addEventListener(\"pointerup\", He)), Cs(W), W.pointerType === \"touch\" ? yt(W) : Et(W));\n    }\n    function Ke(W) {\n      n.enabled !== !1 && (W.pointerType === \"touch\" ? Bt(W) : un(W));\n    }\n    function He(W) {\n      var le, Ee, Ue;\n      di(W), y.length === 0 && ((le = n.domElement) == null || le.releasePointerCapture(W.pointerId), (Ee = n.domElement) == null || Ee.ownerDocument.removeEventListener(\"pointermove\", Ke), (Ue = n.domElement) == null || Ue.ownerDocument.removeEventListener(\"pointerup\", He)), n.dispatchEvent(o), l = a.NONE;\n    }\n    function Et(W) {\n      let le;\n      switch (W.button) {\n        case 0:\n          le = n.mouseButtons.LEFT;\n          break;\n        case 1:\n          le = n.mouseButtons.MIDDLE;\n          break;\n        case 2:\n          le = n.mouseButtons.RIGHT;\n          break;\n        default:\n          le = -1;\n      }\n      switch (le) {\n        case Dt.DOLLY:\n          if (n.enableZoom === !1)\n            return;\n          B(W), l = a.DOLLY;\n          break;\n        case Dt.ROTATE:\n          if (W.ctrlKey || W.metaKey || W.shiftKey) {\n            if (n.enablePan === !1)\n              return;\n            D(W), l = a.PAN;\n          } else {\n            if (n.enableRotate === !1)\n              return;\n            I(W), l = a.ROTATE;\n          }\n          break;\n        case Dt.PAN:\n          if (W.ctrlKey || W.metaKey || W.shiftKey) {\n            if (n.enableRotate === !1)\n              return;\n            I(W), l = a.ROTATE;\n          } else {\n            if (n.enablePan === !1)\n              return;\n            D(W), l = a.PAN;\n          }\n          break;\n        default:\n          l = a.NONE;\n      }\n      l !== a.NONE && n.dispatchEvent(i);\n    }\n    function un(W) {\n      if (n.enabled !== !1)\n        switch (l) {\n          case a.ROTATE:\n            if (n.enableRotate === !1)\n              return;\n            O(W);\n            break;\n          case a.DOLLY:\n            if (n.enableZoom === !1)\n              return;\n            z(W);\n            break;\n          case a.PAN:\n            if (n.enablePan === !1)\n              return;\n            S(W);\n            break;\n        }\n    }\n    function En(W) {\n      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (W.preventDefault(), n.dispatchEvent(i), P(W), n.dispatchEvent(o));\n    }\n    function Nt(W) {\n      n.enabled === !1 || n.enablePan === !1 || L(W);\n    }\n    function yt(W) {\n      switch (Is(W), y.length) {\n        case 1:\n          switch (n.touches.ONE) {\n            case Vt.ROTATE:\n              if (n.enableRotate === !1)\n                return;\n              X(), l = a.TOUCH_ROTATE;\n              break;\n            case Vt.PAN:\n              if (n.enablePan === !1)\n                return;\n              H(), l = a.TOUCH_PAN;\n              break;\n            default:\n              l = a.NONE;\n          }\n          break;\n        case 2:\n          switch (n.touches.TWO) {\n            case Vt.DOLLY_PAN:\n              if (n.enableZoom === !1 && n.enablePan === !1)\n                return;\n              K(), l = a.TOUCH_DOLLY_PAN;\n              break;\n            case Vt.DOLLY_ROTATE:\n              if (n.enableZoom === !1 && n.enableRotate === !1)\n                return;\n              se(), l = a.TOUCH_DOLLY_ROTATE;\n              break;\n            default:\n              l = a.NONE;\n          }\n          break;\n        default:\n          l = a.NONE;\n      }\n      l !== a.NONE && n.dispatchEvent(i);\n    }\n    function Bt(W) {\n      switch (Is(W), l) {\n        case a.TOUCH_ROTATE:\n          if (n.enableRotate === !1)\n            return;\n          ie(W), n.update();\n          break;\n        case a.TOUCH_PAN:\n          if (n.enablePan === !1)\n            return;\n          G(W), n.update();\n          break;\n        case a.TOUCH_DOLLY_PAN:\n          if (n.enableZoom === !1 && n.enablePan === !1)\n            return;\n          oe(W), n.update();\n          break;\n        case a.TOUCH_DOLLY_ROTATE:\n          if (n.enableZoom === !1 && n.enableRotate === !1)\n            return;\n          ge(W), n.update();\n          break;\n        default:\n          l = a.NONE;\n      }\n    }\n    function is(W) {\n      n.enabled !== !1 && W.preventDefault();\n    }\n    function Cs(W) {\n      y.push(W);\n    }\n    function di(W) {\n      delete A[W.pointerId];\n      for (let le = 0; le < y.length; le++)\n        if (y[le].pointerId == W.pointerId) {\n          y.splice(le, 1);\n          return;\n        }\n    }\n    function Is(W) {\n      let le = A[W.pointerId];\n      le === void 0 && (le = new ve(), A[W.pointerId] = le), le.set(W.pageX, W.pageY);\n    }\n    function pi(W) {\n      const le = W.pointerId === y[0].pointerId ? y[1] : y[0];\n      return A[le.pointerId];\n    }\n    this.dollyIn = (W = N()) => {\n      fe(W), n.update();\n    }, this.dollyOut = (W = N()) => {\n      te(W), n.update();\n    }, this.getScale = () => d, this.setScale = (W) => {\n      ee(W), n.update();\n    }, this.getZoomScale = () => N(), t !== void 0 && this.connect(t), this.update();\n  }\n}\nclass yh extends Qa {\n  constructor(e, t) {\n    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = Dt.PAN, this.mouseButtons.RIGHT = Dt.ROTATE, this.touches.ONE = Vt.PAN, this.touches.TWO = Vt.DOLLY_ROTATE;\n  }\n}\nfunction ns(r) {\n  if (typeof TextDecoder < \"u\")\n    return new TextDecoder().decode(r);\n  let e = \"\";\n  for (let t = 0, n = r.length; t < n; t++)\n    e += String.fromCharCode(r[t]);\n  try {\n    return decodeURIComponent(escape(e));\n  } catch {\n    return e;\n  }\n}\nconst In = \"srgb\", sn = \"srgb-linear\", hr = 3001, _h = 3e3;\nclass xh extends Un {\n  constructor(e) {\n    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {\n      return new Mh(t);\n    }), this.register(function(t) {\n      return new Sh(t);\n    }), this.register(function(t) {\n      return new kh(t);\n    }), this.register(function(t) {\n      return new Nh(t);\n    }), this.register(function(t) {\n      return new Bh(t);\n    }), this.register(function(t) {\n      return new Ph(t);\n    }), this.register(function(t) {\n      return new Rh(t);\n    }), this.register(function(t) {\n      return new Ch(t);\n    }), this.register(function(t) {\n      return new Ih(t);\n    }), this.register(function(t) {\n      return new Eh(t);\n    }), this.register(function(t) {\n      return new Oh(t);\n    }), this.register(function(t) {\n      return new Ah(t);\n    }), this.register(function(t) {\n      return new Lh(t);\n    }), this.register(function(t) {\n      return new Dh(t);\n    }), this.register(function(t) {\n      return new Th(t);\n    }), this.register(function(t) {\n      return new Uh(t);\n    }), this.register(function(t) {\n      return new Fh(t);\n    });\n  }\n  load(e, t, n, s) {\n    const i = this;\n    let o;\n    if (this.resourcePath !== \"\")\n      o = this.resourcePath;\n    else if (this.path !== \"\") {\n      const c = qn.extractUrlBase(e);\n      o = qn.resolveURL(c, this.path);\n    } else\n      o = qn.extractUrlBase(e);\n    this.manager.itemStart(e);\n    const a = function(c) {\n      s ? s(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);\n    }, l = new kn(this.manager);\n    l.setPath(this.path), l.setResponseType(\"arraybuffer\"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(\n      e,\n      function(c) {\n        try {\n          i.parse(\n            c,\n            o,\n            function(f) {\n              t(f), i.manager.itemEnd(e);\n            },\n            a\n          );\n        } catch (f) {\n          a(f);\n        }\n      },\n      n,\n      a\n    );\n  }\n  setDRACOLoader(e) {\n    return this.dracoLoader = e, this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(e) {\n    return this.ktx2Loader = e, this;\n  }\n  setMeshoptDecoder(e) {\n    return this.meshoptDecoder = e, this;\n  }\n  register(e) {\n    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;\n  }\n  unregister(e) {\n    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;\n  }\n  parse(e, t, n, s) {\n    let i;\n    const o = {}, a = {};\n    if (typeof e == \"string\")\n      i = JSON.parse(e);\n    else if (e instanceof ArrayBuffer)\n      if (ns(new Uint8Array(e.slice(0, 4))) === Ja) {\n        try {\n          o[Oe.KHR_BINARY_GLTF] = new zh(e);\n        } catch (f) {\n          s && s(f);\n          return;\n        }\n        i = JSON.parse(o[Oe.KHR_BINARY_GLTF].content);\n      } else\n        i = JSON.parse(ns(new Uint8Array(e)));\n    else\n      i = e;\n    if (i.asset === void 0 || i.asset.version[0] < 2) {\n      s && s(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const l = new Jh(i, {\n      path: t || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    l.fileLoader.setRequestHeader(this.requestHeader);\n    for (let c = 0; c < this.pluginCallbacks.length; c++) {\n      const f = this.pluginCallbacks[c](l);\n      f.name || console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\"), a[f.name] = f, o[f.name] = !0;\n    }\n    if (i.extensionsUsed)\n      for (let c = 0; c < i.extensionsUsed.length; ++c) {\n        const f = i.extensionsUsed[c], u = i.extensionsRequired || [];\n        switch (f) {\n          case Oe.KHR_MATERIALS_UNLIT:\n            o[f] = new bh();\n            break;\n          case Oe.KHR_DRACO_MESH_COMPRESSION:\n            o[f] = new Gh(i, this.dracoLoader);\n            break;\n          case Oe.KHR_TEXTURE_TRANSFORM:\n            o[f] = new Hh();\n            break;\n          case Oe.KHR_MESH_QUANTIZATION:\n            o[f] = new jh();\n            break;\n          default:\n            u.indexOf(f) >= 0 && a[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension \"' + f + '\".');\n        }\n      }\n    l.setExtensions(o), l.setPlugins(a), l.parse(n, s);\n  }\n  parseAsync(e, t) {\n    const n = this;\n    return new Promise(function(s, i) {\n      n.parse(e, t, s, i);\n    });\n  }\n}\nfunction wh() {\n  let r = {};\n  return {\n    get: function(e) {\n      return r[e];\n    },\n    add: function(e, t) {\n      r[e] = t;\n    },\n    remove: function(e) {\n      delete r[e];\n    },\n    removeAll: function() {\n      r = {};\n    }\n  };\n}\nconst Oe = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass Th {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const e = this.parser, t = this.parser.json.nodes || [];\n    for (let n = 0, s = t.length; n < s; n++) {\n      const i = t[n];\n      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);\n    }\n  }\n  _loadLight(e) {\n    const t = this.parser, n = \"light:\" + e;\n    let s = t.cache.get(n);\n    if (s)\n      return s;\n    const i = t.json, l = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];\n    let c;\n    const f = new be(16777215);\n    l.color !== void 0 && f.setRGB(l.color[0], l.color[1], l.color[2], sn);\n    const u = l.range !== void 0 ? l.range : 0;\n    switch (l.type) {\n      case \"directional\":\n        c = new wa(f), c.target.position.set(0, 0, -1), c.add(c.target);\n        break;\n      case \"point\":\n        c = new ro(f), c.distance = u;\n        break;\n      case \"spot\":\n        c = new xa(f), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + l.type);\n    }\n    return c.position.set(0, 0, 0), c.decay = 2, en(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || \"light_\" + e), s = Promise.resolve(c), t.cache.add(n, s), s;\n  }\n  getDependency(e, t) {\n    if (e === \"light\")\n      return this._loadLight(t);\n  }\n  createNodeAttachment(e) {\n    const t = this, n = this.parser, i = n.json.nodes[e], a = (i.extensions && i.extensions[this.name] || {}).light;\n    return a === void 0 ? null : this._loadLight(a).then(function(l) {\n      return n._getNodeRef(t.cache, a, l);\n    });\n  }\n}\nclass bh {\n  constructor() {\n    this.name = Oe.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return $t;\n  }\n  extendParams(e, t, n) {\n    const s = [];\n    e.color = new be(1, 1, 1), e.opacity = 1;\n    const i = t.pbrMetallicRoughness;\n    if (i) {\n      if (Array.isArray(i.baseColorFactor)) {\n        const o = i.baseColorFactor;\n        e.color.setRGB(o[0], o[1], o[2], sn), e.opacity = o[3];\n      }\n      i.baseColorTexture !== void 0 && s.push(n.assignTexture(e, \"map\", i.baseColorTexture, In));\n    }\n    return Promise.all(s);\n  }\n}\nclass Eh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(e, t) {\n    const s = this.parser.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = s.extensions[this.name].emissiveStrength;\n    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();\n  }\n}\nclass Mh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && i.push(n.assignTexture(t, \"clearcoatMap\", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && i.push(n.assignTexture(t, \"clearcoatRoughnessMap\", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (i.push(n.assignTexture(t, \"clearcoatNormalMap\", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {\n      const a = o.clearcoatNormalTexture.scale;\n      t.clearcoatNormalScale = new ve(a, a);\n    }\n    return Promise.all(i);\n  }\n}\nclass Sh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const s = this.parser.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = s.extensions[this.name];\n    return t.dispersion = i.dispersion !== void 0 ? i.dispersion : 0, Promise.resolve();\n  }\n}\nclass Ah {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && i.push(n.assignTexture(t, \"iridescenceMap\", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && i.push(\n      n.assignTexture(t, \"iridescenceThicknessMap\", o.iridescenceThicknessTexture)\n    ), Promise.all(i);\n  }\n}\nclass Ph {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [];\n    t.sheenColor = new be(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;\n    const o = s.extensions[this.name];\n    if (o.sheenColorFactor !== void 0) {\n      const a = o.sheenColorFactor;\n      t.sheenColor.setRGB(a[0], a[1], a[2], sn);\n    }\n    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && i.push(n.assignTexture(t, \"sheenColorMap\", o.sheenColorTexture, In)), o.sheenRoughnessTexture !== void 0 && i.push(n.assignTexture(t, \"sheenRoughnessMap\", o.sheenRoughnessTexture)), Promise.all(i);\n  }\n}\nclass Rh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && i.push(n.assignTexture(t, \"transmissionMap\", o.transmissionTexture)), Promise.all(i);\n  }\n}\nclass Ch {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && i.push(n.assignTexture(t, \"thicknessMap\", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;\n    const a = o.attenuationColor || [1, 1, 1];\n    return t.attenuationColor = new be().setRGB(\n      a[0],\n      a[1],\n      a[2],\n      sn\n    ), Promise.all(i);\n  }\n}\nclass Ih {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const s = this.parser.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = s.extensions[this.name];\n    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();\n  }\n}\nclass Oh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && i.push(n.assignTexture(t, \"specularIntensityMap\", o.specularTexture));\n    const a = o.specularColorFactor || [1, 1, 1];\n    return t.specularColor = new be().setRGB(a[0], a[1], a[2], sn), o.specularColorTexture !== void 0 && i.push(\n      n.assignTexture(t, \"specularColorMap\", o.specularColorTexture, In)\n    ), Promise.all(i);\n  }\n}\nclass Dh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && i.push(n.assignTexture(t, \"bumpMap\", o.bumpTexture)), Promise.all(i);\n  }\n}\nclass Lh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(e) {\n    const n = this.parser.json.materials[e];\n    return !n.extensions || !n.extensions[this.name] ? null : Kt;\n  }\n  extendMaterialParams(e, t) {\n    const n = this.parser, s = n.json.materials[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return Promise.resolve();\n    const i = [], o = s.extensions[this.name];\n    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && i.push(n.assignTexture(t, \"anisotropyMap\", o.anisotropyTexture)), Promise.all(i);\n  }\n}\nclass kh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(e) {\n    const t = this.parser, n = t.json, s = n.textures[e];\n    if (!s.extensions || !s.extensions[this.name])\n      return null;\n    const i = s.extensions[this.name], o = t.options.ktx2Loader;\n    if (!o) {\n      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      return null;\n    }\n    return t.loadTextureImage(e, i.source, o);\n  }\n}\nclass Nh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.EXT_TEXTURE_WEBP, this.isSupported = null;\n  }\n  loadTexture(e) {\n    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];\n    if (!i.extensions || !i.extensions[t])\n      return null;\n    const o = i.extensions[t], a = s.images[o.source];\n    let l = n.textureLoader;\n    if (a.uri) {\n      const c = n.options.manager.getHandler(a.uri);\n      c !== null && (l = c);\n    }\n    return this.detectSupport().then(function(c) {\n      if (c)\n        return n.loadTextureImage(e, o.source, l);\n      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      return n.loadTexture(e);\n    });\n  }\n  detectSupport() {\n    return this.isSupported || (this.isSupported = new Promise(function(e) {\n      const t = new Image();\n      t.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", t.onload = t.onerror = function() {\n        e(t.height === 1);\n      };\n    })), this.isSupported;\n  }\n}\nclass Bh {\n  constructor(e) {\n    this.parser = e, this.name = Oe.EXT_TEXTURE_AVIF, this.isSupported = null;\n  }\n  loadTexture(e) {\n    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];\n    if (!i.extensions || !i.extensions[t])\n      return null;\n    const o = i.extensions[t], a = s.images[o.source];\n    let l = n.textureLoader;\n    if (a.uri) {\n      const c = n.options.manager.getHandler(a.uri);\n      c !== null && (l = c);\n    }\n    return this.detectSupport().then(function(c) {\n      if (c)\n        return n.loadTextureImage(e, o.source, l);\n      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      return n.loadTexture(e);\n    });\n  }\n  detectSupport() {\n    return this.isSupported || (this.isSupported = new Promise(function(e) {\n      const t = new Image();\n      t.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\", t.onload = t.onerror = function() {\n        e(t.height === 1);\n      };\n    })), this.isSupported;\n  }\n}\nclass Uh {\n  constructor(e) {\n    this.name = Oe.EXT_MESHOPT_COMPRESSION, this.parser = e;\n  }\n  loadBufferView(e) {\n    const t = this.parser.json, n = t.bufferViews[e];\n    if (n.extensions && n.extensions[this.name]) {\n      const s = n.extensions[this.name], i = this.parser.getDependency(\"buffer\", s.buffer), o = this.parser.options.meshoptDecoder;\n      if (!o || !o.supported) {\n        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        return null;\n      }\n      return i.then(function(a) {\n        const l = s.byteOffset || 0, c = s.byteLength || 0, f = s.count, u = s.byteStride, d = new Uint8Array(a, l, c);\n        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(f, u, d, s.mode, s.filter).then(function(h) {\n          return h.buffer;\n        }) : o.ready.then(function() {\n          const h = new ArrayBuffer(f * u);\n          return o.decodeGltfBuffer(\n            new Uint8Array(h),\n            f,\n            u,\n            d,\n            s.mode,\n            s.filter\n          ), h;\n        });\n      });\n    } else\n      return null;\n  }\n}\nclass Fh {\n  constructor(e) {\n    this.name = Oe.EXT_MESH_GPU_INSTANCING, this.parser = e;\n  }\n  createNodeMesh(e) {\n    const t = this.parser.json, n = t.nodes[e];\n    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)\n      return null;\n    const s = t.meshes[n.mesh];\n    for (const c of s.primitives)\n      if (c.mode !== At.TRIANGLES && c.mode !== At.TRIANGLE_STRIP && c.mode !== At.TRIANGLE_FAN && c.mode !== void 0)\n        return null;\n    const o = n.extensions[this.name].attributes, a = [], l = {};\n    for (const c in o)\n      a.push(\n        this.parser.getDependency(\"accessor\", o[c]).then((f) => (l[c] = f, l[c]))\n      );\n    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {\n      const f = c.pop(), u = f.isGroup ? f.children : [f], d = c[0].count, h = [];\n      for (const m of u) {\n        const g = new Ie(), v = new $(), p = new je(), b = new $(1, 1, 1), _ = new Ta(m.geometry, m.material, d);\n        for (let M = 0; M < d; M++)\n          l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, M), l.ROTATION && p.fromBufferAttribute(l.ROTATION, M), l.SCALE && b.fromBufferAttribute(l.SCALE, M), _.setMatrixAt(M, g.compose(v, p, b));\n        for (const M in l)\n          if (M === \"_COLOR_0\") {\n            const R = l[M];\n            _.instanceColor = new Ll(R.array, R.itemSize, R.normalized);\n          } else M !== \"TRANSLATION\" && M !== \"ROTATION\" && M !== \"SCALE\" && m.geometry.setAttribute(M, l[M]);\n        Rt.prototype.copy.call(_, m), this.parser.assignFinalMaterial(_), h.push(_);\n      }\n      return f.isGroup ? (f.clear(), f.add(...h), f) : h[0];\n    }));\n  }\n}\nconst Ja = \"glTF\", ls = 12, fr = { JSON: 1313821514, BIN: 5130562 };\nclass zh {\n  constructor(e) {\n    this.name = Oe.KHR_BINARY_GLTF, this.content = null, this.body = null;\n    const t = new DataView(e, 0, ls);\n    if (this.header = {\n      magic: ns(new Uint8Array(e.slice(0, 4))),\n      version: t.getUint32(4, !0),\n      length: t.getUint32(8, !0)\n    }, this.header.magic !== Ja)\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    if (this.header.version < 2)\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    const n = this.header.length - ls, s = new DataView(e, ls);\n    let i = 0;\n    for (; i < n; ) {\n      const o = s.getUint32(i, !0);\n      i += 4;\n      const a = s.getUint32(i, !0);\n      if (i += 4, a === fr.JSON) {\n        const l = new Uint8Array(e, ls + i, o);\n        this.content = ns(l);\n      } else if (a === fr.BIN) {\n        const l = ls + i;\n        this.body = e.slice(l, l + o);\n      }\n      i += o;\n    }\n    if (this.content === null)\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n  }\n}\nclass Gh {\n  constructor(e, t) {\n    if (!t)\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    this.name = Oe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();\n  }\n  decodePrimitive(e, t) {\n    const n = this.json, s = this.dracoLoader, i = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, c = {};\n    for (const f in o) {\n      const u = _o[f] || f.toLowerCase();\n      a[u] = o[f];\n    }\n    for (const f in e.attributes) {\n      const u = _o[f] || f.toLowerCase();\n      if (o[f] !== void 0) {\n        const d = n.accessors[e.attributes[f]], h = Qn[d.componentType];\n        c[u] = h.name, l[u] = d.normalized === !0;\n      }\n    }\n    return t.getDependency(\"bufferView\", i).then(function(f) {\n      return new Promise(function(u, d) {\n        s.decodeDracoFile(\n          f,\n          function(h) {\n            for (const m in h.attributes) {\n              const g = h.attributes[m], v = l[m];\n              v !== void 0 && (g.normalized = v);\n            }\n            u(h);\n          },\n          a,\n          c,\n          sn,\n          d\n        );\n      });\n    });\n  }\n}\nclass Hh {\n  constructor() {\n    this.name = Oe.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(e, t) {\n    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;\n  }\n}\nclass jh {\n  constructor() {\n    this.name = Oe.KHR_MESH_QUANTIZATION;\n  }\n}\nclass el extends Fl {\n  constructor(e, t, n, s) {\n    super(e, t, n, s);\n  }\n  copySampleValue_(e) {\n    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, i = e * s * 3 + s;\n    for (let o = 0; o !== s; o++)\n      t[o] = n[i + o];\n    return t;\n  }\n  interpolate_(e, t, n, s) {\n    const i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, f = s - t, u = (n - t) / f, d = u * u, h = d * u, m = e * c, g = m - c, v = -2 * h + 3 * d, p = h - d, b = 1 - v, _ = p - d + u;\n    for (let M = 0; M !== a; M++) {\n      const R = o[g + M + a], w = o[g + M + l] * f, E = o[m + M + a], x = o[m + M] * f;\n      i[M] = b * R + _ * w + v * E + p * x;\n    }\n    return i;\n  }\n}\nconst Vh = new je();\nclass Yh extends el {\n  interpolate_(e, t, n, s) {\n    const i = super.interpolate_(e, t, n, s);\n    return Vh.fromArray(i).normalize().toArray(i), i;\n  }\n}\nconst At = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n}, Qn = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n}, dr = {\n  9728: Kn,\n  9729: wt,\n  9984: da,\n  9985: ma,\n  9986: pa,\n  9987: Eo\n}, pr = {\n  33071: Wt,\n  33648: ga,\n  10497: Ln\n}, Ri = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, _o = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...Ss >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n}, dn = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n}, Wh = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: Mo,\n  STEP: fa\n}, Ci = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction Xh(r) {\n  return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Es({\n    color: 16777215,\n    emissive: 0,\n    metalness: 1,\n    roughness: 1,\n    transparent: !1,\n    depthTest: !0,\n    side: ss\n  })), r.DefaultMaterial;\n}\nfunction An(r, e, t) {\n  for (const n in t.extensions)\n    r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);\n}\nfunction en(r, e) {\n  e.extras !== void 0 && (typeof e.extras == \"object\" ? Object.assign(r.userData, e.extras) : console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + e.extras));\n}\nfunction $h(r, e, t) {\n  let n = !1, s = !1, i = !1;\n  for (let c = 0, f = e.length; c < f; c++) {\n    const u = e[c];\n    if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (i = !0), n && s && i)\n      break;\n  }\n  if (!n && !s && !i)\n    return Promise.resolve(r);\n  const o = [], a = [], l = [];\n  for (let c = 0, f = e.length; c < f; c++) {\n    const u = e[c];\n    if (n) {\n      const d = u.POSITION !== void 0 ? t.getDependency(\"accessor\", u.POSITION) : r.attributes.position;\n      o.push(d);\n    }\n    if (s) {\n      const d = u.NORMAL !== void 0 ? t.getDependency(\"accessor\", u.NORMAL) : r.attributes.normal;\n      a.push(d);\n    }\n    if (i) {\n      const d = u.COLOR_0 !== void 0 ? t.getDependency(\"accessor\", u.COLOR_0) : r.attributes.color;\n      l.push(d);\n    }\n  }\n  return Promise.all([\n    Promise.all(o),\n    Promise.all(a),\n    Promise.all(l)\n  ]).then(function(c) {\n    const f = c[0], u = c[1], d = c[2];\n    return n && (r.morphAttributes.position = f), s && (r.morphAttributes.normal = u), i && (r.morphAttributes.color = d), r.morphTargetsRelative = !0, r;\n  });\n}\nfunction Zh(r, e) {\n  if (r.updateMorphTargets(), e.weights !== void 0)\n    for (let t = 0, n = e.weights.length; t < n; t++)\n      r.morphTargetInfluences[t] = e.weights[t];\n  if (e.extras && Array.isArray(e.extras.targetNames)) {\n    const t = e.extras.targetNames;\n    if (r.morphTargetInfluences.length === t.length) {\n      r.morphTargetDictionary = {};\n      for (let n = 0, s = t.length; n < s; n++)\n        r.morphTargetDictionary[t[n]] = n;\n    } else\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n  }\n}\nfunction Kh(r) {\n  let e;\n  const t = r.extensions && r.extensions[Oe.KHR_DRACO_MESH_COMPRESSION];\n  if (t ? e = \"draco:\" + t.bufferView + \":\" + t.indices + \":\" + Ii(t.attributes) : e = r.indices + \":\" + Ii(r.attributes) + \":\" + r.mode, r.targets !== void 0)\n    for (let n = 0, s = r.targets.length; n < s; n++)\n      e += \":\" + Ii(r.targets[n]);\n  return e;\n}\nfunction Ii(r) {\n  let e = \"\";\n  const t = Object.keys(r).sort();\n  for (let n = 0, s = t.length; n < s; n++)\n    e += t[n] + \":\" + r[t[n]] + \";\";\n  return e;\n}\nfunction xo(r) {\n  switch (r) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction qh(r) {\n  return r.search(/\\.jpe?g($|\\?)/i) > 0 || r.search(/^data\\:image\\/jpeg/) === 0 ? \"image/jpeg\" : r.search(/\\.webp($|\\?)/i) > 0 || r.search(/^data\\:image\\/webp/) === 0 ? \"image/webp\" : \"image/png\";\n}\nconst Qh = new Ie();\nclass Jh {\n  constructor(e = {}, t = {}) {\n    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new wh(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};\n    let n = !1, s = !1, i = -1;\n    typeof navigator < \"u\" && typeof navigator.userAgent < \"u\" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf(\"Firefox\") > -1, i = s ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1), typeof createImageBitmap > \"u\" || n || s && i < 98 ? this.textureLoader = new ai(this.options.manager) : this.textureLoader = new kl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new kn(this.options.manager), this.fileLoader.setResponseType(\"arraybuffer\"), this.options.crossOrigin === \"use-credentials\" && this.fileLoader.setWithCredentials(!0);\n  }\n  setExtensions(e) {\n    this.extensions = e;\n  }\n  setPlugins(e) {\n    this.plugins = e;\n  }\n  parse(e, t) {\n    const n = this, s = this.json, i = this.extensions;\n    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {\n      return o._markDefs && o._markDefs();\n    }), Promise.all(\n      this._invokeAll(function(o) {\n        return o.beforeRoot && o.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        n.getDependencies(\"scene\"),\n        n.getDependencies(\"animation\"),\n        n.getDependencies(\"camera\")\n      ]);\n    }).then(function(o) {\n      const a = {\n        scene: o[0][s.scene || 0],\n        scenes: o[0],\n        animations: o[1],\n        cameras: o[2],\n        asset: s.asset,\n        parser: n,\n        userData: {}\n      };\n      return An(i, a, s), en(a, s), Promise.all(\n        n._invokeAll(function(l) {\n          return l.afterRoot && l.afterRoot(a);\n        })\n      ).then(function() {\n        for (const l of a.scenes)\n          l.updateMatrixWorld();\n        e(a);\n      });\n    }).catch(t);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];\n    for (let s = 0, i = t.length; s < i; s++) {\n      const o = t[s].joints;\n      for (let a = 0, l = o.length; a < l; a++)\n        e[o[a]].isBone = !0;\n    }\n    for (let s = 0, i = e.length; s < i; s++) {\n      const o = e[s];\n      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(e, t) {\n    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(e, t, n) {\n    if (e.refs[t] <= 1)\n      return n;\n    const s = n.clone(), i = (o, a) => {\n      const l = this.associations.get(o);\n      l != null && this.associations.set(a, l);\n      for (const [c, f] of o.children.entries())\n        i(f, a.children[c]);\n    };\n    return i(n, s), s.name += \"_instance_\" + e.uses[t]++, s;\n  }\n  _invokeOne(e) {\n    const t = Object.values(this.plugins);\n    t.push(this);\n    for (let n = 0; n < t.length; n++) {\n      const s = e(t[n]);\n      if (s)\n        return s;\n    }\n    return null;\n  }\n  _invokeAll(e) {\n    const t = Object.values(this.plugins);\n    t.unshift(this);\n    const n = [];\n    for (let s = 0; s < t.length; s++) {\n      const i = e(t[s]);\n      i && n.push(i);\n    }\n    return n;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(e, t) {\n    const n = e + \":\" + t;\n    let s = this.cache.get(n);\n    if (!s) {\n      switch (e) {\n        case \"scene\":\n          s = this.loadScene(t);\n          break;\n        case \"node\":\n          s = this._invokeOne(function(i) {\n            return i.loadNode && i.loadNode(t);\n          });\n          break;\n        case \"mesh\":\n          s = this._invokeOne(function(i) {\n            return i.loadMesh && i.loadMesh(t);\n          });\n          break;\n        case \"accessor\":\n          s = this.loadAccessor(t);\n          break;\n        case \"bufferView\":\n          s = this._invokeOne(function(i) {\n            return i.loadBufferView && i.loadBufferView(t);\n          });\n          break;\n        case \"buffer\":\n          s = this.loadBuffer(t);\n          break;\n        case \"material\":\n          s = this._invokeOne(function(i) {\n            return i.loadMaterial && i.loadMaterial(t);\n          });\n          break;\n        case \"texture\":\n          s = this._invokeOne(function(i) {\n            return i.loadTexture && i.loadTexture(t);\n          });\n          break;\n        case \"skin\":\n          s = this.loadSkin(t);\n          break;\n        case \"animation\":\n          s = this._invokeOne(function(i) {\n            return i.loadAnimation && i.loadAnimation(t);\n          });\n          break;\n        case \"camera\":\n          s = this.loadCamera(t);\n          break;\n        default:\n          if (s = this._invokeOne(function(i) {\n            return i != this && i.getDependency && i.getDependency(e, t);\n          }), !s)\n            throw new Error(\"Unknown type: \" + e);\n          break;\n      }\n      this.cache.add(n, s);\n    }\n    return s;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(e) {\n    let t = this.cache.get(e);\n    if (!t) {\n      const n = this, s = this.json[e + (e === \"mesh\" ? \"es\" : \"s\")] || [];\n      t = Promise.all(\n        s.map(function(i, o) {\n          return n.getDependency(e, o);\n        })\n      ), this.cache.add(e, t);\n    }\n    return t;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(e) {\n    const t = this.json.buffers[e], n = this.fileLoader;\n    if (t.type && t.type !== \"arraybuffer\")\n      throw new Error(\"THREE.GLTFLoader: \" + t.type + \" buffer type is not supported.\");\n    if (t.uri === void 0 && e === 0)\n      return Promise.resolve(this.extensions[Oe.KHR_BINARY_GLTF].body);\n    const s = this.options;\n    return new Promise(function(i, o) {\n      n.load(qn.resolveURL(t.uri, s.path), i, void 0, function() {\n        o(new Error('THREE.GLTFLoader: Failed to load buffer \"' + t.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(e) {\n    const t = this.json.bufferViews[e];\n    return this.getDependency(\"buffer\", t.buffer).then(function(n) {\n      const s = t.byteLength || 0, i = t.byteOffset || 0;\n      return n.slice(i, i + s);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(e) {\n    const t = this, n = this.json, s = this.json.accessors[e];\n    if (s.bufferView === void 0 && s.sparse === void 0) {\n      const o = Ri[s.type], a = Qn[s.componentType], l = s.normalized === !0, c = new a(s.count * o);\n      return Promise.resolve(new ut(c, o, l));\n    }\n    const i = [];\n    return s.bufferView !== void 0 ? i.push(this.getDependency(\"bufferView\", s.bufferView)) : i.push(null), s.sparse !== void 0 && (i.push(this.getDependency(\"bufferView\", s.sparse.indices.bufferView)), i.push(this.getDependency(\"bufferView\", s.sparse.values.bufferView))), Promise.all(i).then(function(o) {\n      const a = o[0], l = Ri[s.type], c = Qn[s.componentType], f = c.BYTES_PER_ELEMENT, u = f * l, d = s.byteOffset || 0, h = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, m = s.normalized === !0;\n      let g, v;\n      if (h && h !== u) {\n        const p = Math.floor(d / h), b = \"InterleavedBuffer:\" + s.bufferView + \":\" + s.componentType + \":\" + p + \":\" + s.count;\n        let _ = t.cache.get(b);\n        _ || (g = new c(a, p * h, s.count * h / f), _ = new Ao(g, h / f), t.cache.add(b, _)), v = new nn(\n          _,\n          l,\n          d % h / f,\n          m\n        );\n      } else\n        a === null ? g = new c(s.count * l) : g = new c(a, d, s.count * l), v = new ut(g, l, m);\n      if (s.sparse !== void 0) {\n        const p = Ri.SCALAR, b = Qn[s.sparse.indices.componentType], _ = s.sparse.indices.byteOffset || 0, M = s.sparse.values.byteOffset || 0, R = new b(\n          o[1],\n          _,\n          s.sparse.count * p\n        ), w = new c(o[2], M, s.sparse.count * l);\n        a !== null && (v = new ut(\n          v.array.slice(),\n          v.itemSize,\n          v.normalized\n        ));\n        for (let E = 0, x = R.length; E < x; E++) {\n          const T = R[E];\n          if (v.setX(T, w[E * l]), l >= 2 && v.setY(T, w[E * l + 1]), l >= 3 && v.setZ(T, w[E * l + 2]), l >= 4 && v.setW(T, w[E * l + 3]), l >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return v;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(e) {\n    const t = this.json, n = this.options, i = t.textures[e].source, o = t.images[i];\n    let a = this.textureLoader;\n    if (o.uri) {\n      const l = n.manager.getHandler(o.uri);\n      l !== null && (a = l);\n    }\n    return this.loadTextureImage(e, i, a);\n  }\n  loadTextureImage(e, t, n) {\n    const s = this, i = this.json, o = i.textures[e], a = i.images[t], l = (a.uri || a.bufferView) + \":\" + o.sampler;\n    if (this.textureCache[l])\n      return this.textureCache[l];\n    const c = this.loadImageSource(t, n).then(function(f) {\n      f.flipY = !1, f.name = o.name || a.name || \"\", f.name === \"\" && typeof a.uri == \"string\" && a.uri.startsWith(\"data:image/\") === !1 && (f.name = a.uri);\n      const d = (i.samplers || {})[o.sampler] || {};\n      return f.magFilter = dr[d.magFilter] || wt, f.minFilter = dr[d.minFilter] || Eo, f.wrapS = pr[d.wrapS] || Ln, f.wrapT = pr[d.wrapT] || Ln, s.associations.set(f, { textures: e }), f;\n    }).catch(function() {\n      return null;\n    });\n    return this.textureCache[l] = c, c;\n  }\n  loadImageSource(e, t) {\n    const n = this, s = this.json, i = this.options;\n    if (this.sourceCache[e] !== void 0)\n      return this.sourceCache[e].then((u) => u.clone());\n    const o = s.images[e], a = self.URL || self.webkitURL;\n    let l = o.uri || \"\", c = !1;\n    if (o.bufferView !== void 0)\n      l = n.getDependency(\"bufferView\", o.bufferView).then(function(u) {\n        c = !0;\n        const d = new Blob([u], { type: o.mimeType });\n        return l = a.createObjectURL(d), l;\n      });\n    else if (o.uri === void 0)\n      throw new Error(\"THREE.GLTFLoader: Image \" + e + \" is missing URI and bufferView\");\n    const f = Promise.resolve(l).then(function(u) {\n      return new Promise(function(d, h) {\n        let m = d;\n        t.isImageBitmapLoader === !0 && (m = function(g) {\n          const v = new es(g);\n          v.needsUpdate = !0, d(v);\n        }), t.load(qn.resolveURL(u, i.path), m, void 0, h);\n      });\n    }).then(function(u) {\n      return c === !0 && a.revokeObjectURL(l), en(u, o), u.userData.mimeType = o.mimeType || qh(o.uri), u;\n    }).catch(function(u) {\n      throw console.error(\"THREE.GLTFLoader: Couldn't load texture\", l), u;\n    });\n    return this.sourceCache[e] = f, f;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(e, t, n, s) {\n    const i = this;\n    return this.getDependency(\"texture\", n.index).then(function(o) {\n      if (!o)\n        return null;\n      if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), i.extensions[Oe.KHR_TEXTURE_TRANSFORM]) {\n        const a = n.extensions !== void 0 ? n.extensions[Oe.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (a) {\n          const l = i.associations.get(o);\n          o = i.extensions[Oe.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), i.associations.set(o, l);\n        }\n      }\n      return s !== void 0 && (typeof s == \"number\" && (s = s === hr ? In : sn), \"colorSpace\" in o ? o.colorSpace = s : o.encoding = s === In ? hr : _h), e[t] = o, o;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(e) {\n    const t = e.geometry;\n    let n = e.material;\n    const s = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, o = t.attributes.normal === void 0;\n    if (e.isPoints) {\n      const a = \"PointsMaterial:\" + n.uuid;\n      let l = this.cache.get(a);\n      l || (l = new Nl(), vi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;\n    } else if (e.isLine) {\n      const a = \"LineBasicMaterial:\" + n.uuid;\n      let l = this.cache.get(a);\n      l || (l = new ws(), vi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;\n    }\n    if (s || i || o) {\n      let a = \"ClonedMaterial:\" + n.uuid + \":\";\n      s && (a += \"derivative-tangents:\"), i && (a += \"vertex-colors:\"), o && (a += \"flat-shading:\");\n      let l = this.cache.get(a);\n      l || (l = n.clone(), i && (l.vertexColors = !0), o && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;\n    }\n    e.material = n;\n  }\n  getMaterialType() {\n    return Es;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(e) {\n    const t = this, n = this.json, s = this.extensions, i = n.materials[e];\n    let o;\n    const a = {}, l = i.extensions || {}, c = [];\n    if (l[Oe.KHR_MATERIALS_UNLIT]) {\n      const u = s[Oe.KHR_MATERIALS_UNLIT];\n      o = u.getMaterialType(), c.push(u.extendParams(a, i, t));\n    } else {\n      const u = i.pbrMetallicRoughness || {};\n      if (a.color = new be(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {\n        const d = u.baseColorFactor;\n        a.color.setRGB(d[0], d[1], d[2], sn), a.opacity = d[3];\n      }\n      u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, \"map\", u.baseColorTexture, In)), a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, \"metalnessMap\", u.metallicRoughnessTexture)), c.push(t.assignTexture(a, \"roughnessMap\", u.metallicRoughnessTexture))), o = this._invokeOne(function(d) {\n        return d.getMaterialType && d.getMaterialType(e);\n      }), c.push(\n        Promise.all(\n          this._invokeAll(function(d) {\n            return d.extendMaterialParams && d.extendMaterialParams(e, a);\n          })\n        )\n      );\n    }\n    i.doubleSided === !0 && (a.side = on);\n    const f = i.alphaMode || Ci.OPAQUE;\n    if (f === Ci.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, f === Ci.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && o !== $t && (c.push(t.assignTexture(a, \"normalMap\", i.normalTexture)), a.normalScale = new ve(1, 1), i.normalTexture.scale !== void 0)) {\n      const u = i.normalTexture.scale;\n      a.normalScale.set(u, u);\n    }\n    if (i.occlusionTexture !== void 0 && o !== $t && (c.push(t.assignTexture(a, \"aoMap\", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && o !== $t) {\n      const u = i.emissiveFactor;\n      a.emissive = new be().setRGB(\n        u[0],\n        u[1],\n        u[2],\n        sn\n      );\n    }\n    return i.emissiveTexture !== void 0 && o !== $t && c.push(t.assignTexture(a, \"emissiveMap\", i.emissiveTexture, In)), Promise.all(c).then(function() {\n      const u = new o(a);\n      return i.name && (u.name = i.name), en(u, i), t.associations.set(u, { materials: e }), i.extensions && An(s, u, i), u;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(e) {\n    const t = rn.sanitizeNodeName(e || \"\");\n    return t in this.nodeNamesUsed ? t + \"_\" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(e) {\n    const t = this, n = this.extensions, s = this.primitiveCache;\n    function i(a) {\n      return n[Oe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {\n        return mr(l, a, t);\n      });\n    }\n    const o = [];\n    for (let a = 0, l = e.length; a < l; a++) {\n      const c = e[a], f = Kh(c), u = s[f];\n      if (u)\n        o.push(u.promise);\n      else {\n        let d;\n        c.extensions && c.extensions[Oe.KHR_DRACO_MESH_COMPRESSION] ? d = i(c) : d = mr(new ht(), c, t), s[f] = { primitive: c, promise: d }, o.push(d);\n      }\n    }\n    return Promise.all(o);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(e) {\n    const t = this, n = this.json, s = this.extensions, i = n.meshes[e], o = i.primitives, a = [];\n    for (let l = 0, c = o.length; l < c; l++) {\n      const f = o[l].material === void 0 ? Xh(this.cache) : this.getDependency(\"material\", o[l].material);\n      a.push(f);\n    }\n    return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {\n      const c = l.slice(0, l.length - 1), f = l[l.length - 1], u = [];\n      for (let h = 0, m = f.length; h < m; h++) {\n        const g = f[h], v = o[h];\n        let p;\n        const b = c[h];\n        if (v.mode === At.TRIANGLES || v.mode === At.TRIANGLE_STRIP || v.mode === At.TRIANGLE_FAN || v.mode === void 0)\n          p = i.isSkinnedMesh === !0 ? new Po(g, b) : new de(g, b), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), v.mode === At.TRIANGLE_STRIP ? p.geometry = er(p.geometry, ha) : v.mode === At.TRIANGLE_FAN && (p.geometry = er(p.geometry, oo));\n        else if (v.mode === At.LINES)\n          p = new Bl(g, b);\n        else if (v.mode === At.LINE_STRIP)\n          p = new ke(g, b);\n        else if (v.mode === At.LINE_LOOP)\n          p = new Ul(g, b);\n        else if (v.mode === At.POINTS)\n          p = new ba(g, b);\n        else\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + v.mode);\n        Object.keys(p.geometry.morphAttributes).length > 0 && Zh(p, i), p.name = t.createUniqueName(i.name || \"mesh_\" + e), en(p, i), v.extensions && An(s, p, v), t.assignFinalMaterial(p), u.push(p);\n      }\n      for (let h = 0, m = u.length; h < m; h++)\n        t.associations.set(u[h], {\n          meshes: e,\n          primitives: h\n        });\n      if (u.length === 1)\n        return i.extensions && An(s, u[0], i), u[0];\n      const d = new Zt();\n      i.extensions && An(s, d, i), t.associations.set(d, { meshes: e });\n      for (let h = 0, m = u.length; h < m; h++)\n        d.add(u[h]);\n      return d;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(e) {\n    let t;\n    const n = this.json.cameras[e], s = n[n.type];\n    if (!s) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    return n.type === \"perspective\" ? t = new kt(\n      Ye.radToDeg(s.yfov),\n      s.aspectRatio || 1,\n      s.znear || 1,\n      s.zfar || 2e6\n    ) : n.type === \"orthographic\" && (t = new _n(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), en(t, n), Promise.resolve(t);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(e) {\n    const t = this.json.skins[e], n = [];\n    for (let s = 0, i = t.joints.length; s < i; s++)\n      n.push(this._loadNodeShallow(t.joints[s]));\n    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency(\"accessor\", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {\n      const i = s.pop(), o = s, a = [], l = [];\n      for (let c = 0, f = o.length; c < f; c++) {\n        const u = o[c];\n        if (u) {\n          a.push(u);\n          const d = new Ie();\n          i !== null && d.fromArray(i.array, c * 16), l.push(d);\n        } else\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', t.joints[c]);\n      }\n      return new Ea(a, l);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(e) {\n    const t = this.json, n = this, s = t.animations[e], i = s.name ? s.name : \"animation_\" + e, o = [], a = [], l = [], c = [], f = [];\n    for (let u = 0, d = s.channels.length; u < d; u++) {\n      const h = s.channels[u], m = s.samplers[h.sampler], g = h.target, v = g.node, p = s.parameters !== void 0 ? s.parameters[m.input] : m.input, b = s.parameters !== void 0 ? s.parameters[m.output] : m.output;\n      g.node !== void 0 && (o.push(this.getDependency(\"node\", v)), a.push(this.getDependency(\"accessor\", p)), l.push(this.getDependency(\"accessor\", b)), c.push(m), f.push(g));\n    }\n    return Promise.all([\n      Promise.all(o),\n      Promise.all(a),\n      Promise.all(l),\n      Promise.all(c),\n      Promise.all(f)\n    ]).then(function(u) {\n      const d = u[0], h = u[1], m = u[2], g = u[3], v = u[4], p = [];\n      for (let b = 0, _ = d.length; b < _; b++) {\n        const M = d[b], R = h[b], w = m[b], E = g[b], x = v[b];\n        if (M === void 0)\n          continue;\n        M.updateMatrix && M.updateMatrix();\n        const T = n._createAnimationTracks(M, R, w, E, x);\n        if (T)\n          for (let y = 0; y < T.length; y++)\n            p.push(T[y]);\n      }\n      return new Ma(i, void 0, p);\n    });\n  }\n  createNodeMesh(e) {\n    const t = this.json, n = this, s = t.nodes[e];\n    return s.mesh === void 0 ? null : n.getDependency(\"mesh\", s.mesh).then(function(i) {\n      const o = n._getNodeRef(n.meshCache, s.mesh, i);\n      return s.weights !== void 0 && o.traverse(function(a) {\n        if (a.isMesh)\n          for (let l = 0, c = s.weights.length; l < c; l++)\n            a.morphTargetInfluences[l] = s.weights[l];\n      }), o;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(e) {\n    const t = this.json, n = this, s = t.nodes[e], i = n._loadNodeShallow(e), o = [], a = s.children || [];\n    for (let c = 0, f = a.length; c < f; c++)\n      o.push(n.getDependency(\"node\", a[c]));\n    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency(\"skin\", s.skin);\n    return Promise.all([i, Promise.all(o), l]).then(function(c) {\n      const f = c[0], u = c[1], d = c[2];\n      d !== null && f.traverse(function(h) {\n        h.isSkinnedMesh && h.bind(d, Qh);\n      });\n      for (let h = 0, m = u.length; h < m; h++)\n        f.add(u[h]);\n      return f;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(e) {\n    const t = this.json, n = this.extensions, s = this;\n    if (this.nodeCache[e] !== void 0)\n      return this.nodeCache[e];\n    const i = t.nodes[e], o = i.name ? s.createUniqueName(i.name) : \"\", a = [], l = s._invokeOne(function(c) {\n      return c.createNodeMesh && c.createNodeMesh(e);\n    });\n    return l && a.push(l), i.camera !== void 0 && a.push(\n      s.getDependency(\"camera\", i.camera).then(function(c) {\n        return s._getNodeRef(s.cameraCache, i.camera, c);\n      })\n    ), s._invokeAll(function(c) {\n      return c.createNodeAttachment && c.createNodeAttachment(e);\n    }).forEach(function(c) {\n      a.push(c);\n    }), this.nodeCache[e] = Promise.all(a).then(function(c) {\n      let f;\n      if (i.isBone === !0 ? f = new ao() : c.length > 1 ? f = new Zt() : c.length === 1 ? f = c[0] : f = new Rt(), f !== c[0])\n        for (let u = 0, d = c.length; u < d; u++)\n          f.add(c[u]);\n      if (i.name && (f.userData.name = i.name, f.name = o), en(f, i), i.extensions && An(n, f, i), i.matrix !== void 0) {\n        const u = new Ie();\n        u.fromArray(i.matrix), f.applyMatrix4(u);\n      } else\n        i.translation !== void 0 && f.position.fromArray(i.translation), i.rotation !== void 0 && f.quaternion.fromArray(i.rotation), i.scale !== void 0 && f.scale.fromArray(i.scale);\n      return s.associations.has(f) || s.associations.set(f, {}), s.associations.get(f).nodes = e, f;\n    }), this.nodeCache[e];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(e) {\n    const t = this.extensions, n = this.json.scenes[e], s = this, i = new Zt();\n    n.name && (i.name = s.createUniqueName(n.name)), en(i, n), n.extensions && An(t, i, n);\n    const o = n.nodes || [], a = [];\n    for (let l = 0, c = o.length; l < c; l++)\n      a.push(s.getDependency(\"node\", o[l]));\n    return Promise.all(a).then(function(l) {\n      for (let f = 0, u = l.length; f < u; f++)\n        i.add(l[f]);\n      const c = (f) => {\n        const u = /* @__PURE__ */ new Map();\n        for (const [d, h] of s.associations)\n          (d instanceof vi || d instanceof es) && u.set(d, h);\n        return f.traverse((d) => {\n          const h = s.associations.get(d);\n          h != null && u.set(d, h);\n        }), u;\n      };\n      return s.associations = c(i), i;\n    });\n  }\n  _createAnimationTracks(e, t, n, s, i) {\n    const o = [], a = e.name ? e.name : e.uuid, l = [];\n    dn[i.path] === dn.weights ? e.traverse(function(d) {\n      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);\n    }) : l.push(a);\n    let c;\n    switch (dn[i.path]) {\n      case dn.weights:\n        c = co;\n        break;\n      case dn.rotation:\n        c = uo;\n        break;\n      case dn.position:\n      case dn.scale:\n        c = lo;\n        break;\n      default:\n        switch (n.itemSize) {\n          case 1:\n            c = co;\n            break;\n          case 2:\n          case 3:\n          default:\n            c = lo;\n            break;\n        }\n        break;\n    }\n    const f = s.interpolation !== void 0 ? Wh[s.interpolation] : Mo, u = this._getArrayFromAccessor(n);\n    for (let d = 0, h = l.length; d < h; d++) {\n      const m = new c(\n        l[d] + \".\" + dn[i.path],\n        t.array,\n        u,\n        f\n      );\n      s.interpolation === \"CUBICSPLINE\" && this._createCubicSplineTrackInterpolant(m), o.push(m);\n    }\n    return o;\n  }\n  _getArrayFromAccessor(e) {\n    let t = e.array;\n    if (e.normalized) {\n      const n = xo(t.constructor), s = new Float32Array(t.length);\n      for (let i = 0, o = t.length; i < o; i++)\n        s[i] = t[i] * n;\n      t = s;\n    }\n    return t;\n  }\n  _createCubicSplineTrackInterpolant(e) {\n    e.createInterpolant = function(n) {\n      const s = this instanceof uo ? Yh : el;\n      return new s(this.times, this.values, this.getValueSize() / 3, n);\n    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;\n  }\n}\nfunction ef(r, e, t) {\n  const n = e.attributes, s = new _t();\n  if (n.POSITION !== void 0) {\n    const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;\n    if (l !== void 0 && c !== void 0) {\n      if (s.set(new $(l[0], l[1], l[2]), new $(c[0], c[1], c[2])), a.normalized) {\n        const f = xo(Qn[a.componentType]);\n        s.min.multiplyScalar(f), s.max.multiplyScalar(f);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else\n    return;\n  const i = e.targets;\n  if (i !== void 0) {\n    const a = new $(), l = new $();\n    for (let c = 0, f = i.length; c < f; c++) {\n      const u = i[c];\n      if (u.POSITION !== void 0) {\n        const d = t.json.accessors[u.POSITION], h = d.min, m = d.max;\n        if (h !== void 0 && m !== void 0) {\n          if (l.setX(Math.max(Math.abs(h[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(h[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(h[2]), Math.abs(m[2]))), d.normalized) {\n            const g = xo(Qn[d.componentType]);\n            l.multiplyScalar(g);\n          }\n          a.max(l);\n        } else\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      }\n    }\n    s.expandByVector(a);\n  }\n  r.boundingBox = s;\n  const o = new Ms();\n  s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, r.boundingSphere = o;\n}\nfunction mr(r, e, t) {\n  const n = e.attributes, s = [];\n  function i(o, a) {\n    return t.getDependency(\"accessor\", o).then(function(l) {\n      r.setAttribute(a, l);\n    });\n  }\n  for (const o in n) {\n    const a = _o[o] || o.toLowerCase();\n    a in r.attributes || s.push(i(n[o], a));\n  }\n  if (e.indices !== void 0 && !r.index) {\n    const o = t.getDependency(\"accessor\", e.indices).then(function(a) {\n      r.setIndex(a);\n    });\n    s.push(o);\n  }\n  return en(r, e), ef(r, e, t), Promise.all(s).then(function() {\n    return e.targets !== void 0 ? $h(r, e.targets, t) : r;\n  });\n}\nconst cs = new $();\nfunction Mt(r, e, t, n, s, i) {\n  const o = 2 * Math.PI * s / 4, a = Math.max(i - 2 * s, 0), l = Math.PI / 4;\n  cs.copy(e), cs[n] = 0, cs.normalize();\n  const c = 0.5 * o / (o + a), f = 1 - cs.angleTo(r) / l;\n  return Math.sign(cs[t]) === 1 ? f * c : a / (o + a) + c + c * (1 - f);\n}\nclass tf extends Ht {\n  constructor(e = 1, t = 1, n = 1, s = 2, i = 0.1) {\n    if (s = s * 2 + 1, i = Math.min(e / 2, t / 2, n / 2, i), super(1, 1, 1, s, s, s), s === 1)\n      return;\n    const o = this.toNonIndexed();\n    this.index = null, this.attributes.position = o.attributes.position, this.attributes.normal = o.attributes.normal, this.attributes.uv = o.attributes.uv;\n    const a = new $(), l = new $(), c = new $(e, t, n).divideScalar(2).subScalar(i), f = this.attributes.position.array, u = this.attributes.normal.array, d = this.attributes.uv.array, h = f.length / 6, m = new $(), g = 0.5 / s;\n    for (let v = 0, p = 0; v < f.length; v += 3, p += 2)\n      switch (a.fromArray(f, v), l.copy(a), l.x -= Math.sign(l.x) * g, l.y -= Math.sign(l.y) * g, l.z -= Math.sign(l.z) * g, l.normalize(), f[v + 0] = c.x * Math.sign(a.x) + l.x * i, f[v + 1] = c.y * Math.sign(a.y) + l.y * i, f[v + 2] = c.z * Math.sign(a.z) + l.z * i, u[v + 0] = l.x, u[v + 1] = l.y, u[v + 2] = l.z, Math.floor(v / h)) {\n        case 0:\n          m.set(1, 0, 0), d[p + 0] = Mt(m, l, \"z\", \"y\", i, n), d[p + 1] = 1 - Mt(m, l, \"y\", \"z\", i, t);\n          break;\n        case 1:\n          m.set(-1, 0, 0), d[p + 0] = 1 - Mt(m, l, \"z\", \"y\", i, n), d[p + 1] = 1 - Mt(m, l, \"y\", \"z\", i, t);\n          break;\n        case 2:\n          m.set(0, 1, 0), d[p + 0] = 1 - Mt(m, l, \"x\", \"z\", i, e), d[p + 1] = Mt(m, l, \"z\", \"x\", i, n);\n          break;\n        case 3:\n          m.set(0, -1, 0), d[p + 0] = 1 - Mt(m, l, \"x\", \"z\", i, e), d[p + 1] = 1 - Mt(m, l, \"z\", \"x\", i, n);\n          break;\n        case 4:\n          m.set(0, 0, 1), d[p + 0] = 1 - Mt(m, l, \"x\", \"y\", i, e), d[p + 1] = 1 - Mt(m, l, \"y\", \"x\", i, t);\n          break;\n        case 5:\n          m.set(0, 0, -1), d[p + 0] = Mt(m, l, \"x\", \"y\", i, e), d[p + 1] = 1 - Mt(m, l, \"y\", \"x\", i, t);\n          break;\n      }\n  }\n}\nclass gr extends zl {\n  constructor(e, t = {}) {\n    const {\n      bevelEnabled: n = !1,\n      bevelSize: s = 8,\n      bevelThickness: i = 10,\n      font: o,\n      height: a = 50,\n      size: l = 100,\n      lineHeight: c = 1,\n      letterSpacing: f = 0,\n      ...u\n    } = t;\n    if (o === void 0)\n      super();\n    else {\n      const d = o.generateShapes(e, l, { lineHeight: c, letterSpacing: f });\n      super(d, { ...u, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });\n    }\n    this.type = \"TextGeometry\";\n  }\n}\nconst nf = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n  )\n}, sf = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n  )\n};\nfunction tl(r, e, t) {\n  const n = t.length - r - 1;\n  if (e >= t[n])\n    return n - 1;\n  if (e <= t[r])\n    return r;\n  let s = r, i = n, o = Math.floor((s + i) / 2);\n  for (; e < t[o] || e >= t[o + 1]; )\n    e < t[o] ? i = o : s = o, o = Math.floor((s + i) / 2);\n  return o;\n}\nfunction of(r, e, t, n) {\n  const s = [], i = [], o = [];\n  s[0] = 1;\n  for (let a = 1; a <= t; ++a) {\n    i[a] = e - n[r + 1 - a], o[a] = n[r + a] - e;\n    let l = 0;\n    for (let c = 0; c < a; ++c) {\n      const f = o[c + 1], u = i[a - c], d = s[c] / (f + u);\n      s[c] = l + f * d, l = u * d;\n    }\n    s[a] = l;\n  }\n  return s;\n}\nfunction rf(r, e, t, n) {\n  const s = tl(r, n, e), i = of(s, n, r, e), o = new at(0, 0, 0, 0);\n  for (let a = 0; a <= r; ++a) {\n    const l = t[s - r + a], c = i[a], f = l.w * c;\n    o.x += l.x * f, o.y += l.y * f, o.z += l.z * f, o.w += l.w * c;\n  }\n  return o;\n}\nfunction af(r, e, t, n, s) {\n  const i = [];\n  for (let u = 0; u <= t; ++u)\n    i[u] = 0;\n  const o = [];\n  for (let u = 0; u <= n; ++u)\n    o[u] = i.slice(0);\n  const a = [];\n  for (let u = 0; u <= t; ++u)\n    a[u] = i.slice(0);\n  a[0][0] = 1;\n  const l = i.slice(0), c = i.slice(0);\n  for (let u = 1; u <= t; ++u) {\n    l[u] = e - s[r + 1 - u], c[u] = s[r + u] - e;\n    let d = 0;\n    for (let h = 0; h < u; ++h) {\n      const m = c[h + 1], g = l[u - h];\n      a[u][h] = m + g;\n      const v = a[h][u - 1] / a[u][h];\n      a[h][u] = d + m * v, d = g * v;\n    }\n    a[u][u] = d;\n  }\n  for (let u = 0; u <= t; ++u)\n    o[0][u] = a[u][t];\n  for (let u = 0; u <= t; ++u) {\n    let d = 0, h = 1;\n    const m = [];\n    for (let g = 0; g <= t; ++g)\n      m[g] = i.slice(0);\n    m[0][0] = 1;\n    for (let g = 1; g <= n; ++g) {\n      let v = 0;\n      const p = u - g, b = t - g;\n      u >= g && (m[h][0] = m[d][0] / a[b + 1][p], v = m[h][0] * a[p][b]);\n      const _ = p >= -1 ? 1 : -p, M = u - 1 <= b ? g - 1 : t - u;\n      for (let w = _; w <= M; ++w)\n        m[h][w] = (m[d][w] - m[d][w - 1]) / a[b + 1][p + w], v += m[h][w] * a[p + w][b];\n      u <= b && (m[h][g] = -m[d][g - 1] / a[b + 1][u], v += m[h][g] * a[u][b]), o[g][u] = v;\n      const R = d;\n      d = h, h = R;\n    }\n  }\n  let f = t;\n  for (let u = 1; u <= n; ++u) {\n    for (let d = 0; d <= t; ++d)\n      o[u][d] *= f;\n    f *= t - u;\n  }\n  return o;\n}\nfunction lf(r, e, t, n, s) {\n  const i = s < r ? s : r, o = [], a = tl(r, n, e), l = af(a, n, r, i, e), c = [];\n  for (let f = 0; f < t.length; ++f) {\n    const u = t[f].clone(), d = u.w;\n    u.x *= d, u.y *= d, u.z *= d, c[f] = u;\n  }\n  for (let f = 0; f <= i; ++f) {\n    const u = c[a - r].clone().multiplyScalar(l[f][0]);\n    for (let d = 1; d <= r; ++d)\n      u.add(c[a - r + d].clone().multiplyScalar(l[f][d]));\n    o[f] = u;\n  }\n  for (let f = i + 1; f <= s + 1; ++f)\n    o[f] = new at(0, 0, 0);\n  return o;\n}\nfunction cf(r, e) {\n  let t = 1;\n  for (let s = 2; s <= r; ++s)\n    t *= s;\n  let n = 1;\n  for (let s = 2; s <= e; ++s)\n    n *= s;\n  for (let s = 2; s <= r - e; ++s)\n    n *= s;\n  return t / n;\n}\nfunction uf(r) {\n  const e = r.length, t = [], n = [];\n  for (let i = 0; i < e; ++i) {\n    const o = r[i];\n    t[i] = new $(o.x, o.y, o.z), n[i] = o.w;\n  }\n  const s = [];\n  for (let i = 0; i < e; ++i) {\n    const o = t[i].clone();\n    for (let a = 1; a <= i; ++a)\n      o.sub(s[i - a].clone().multiplyScalar(cf(i, a) * n[a]));\n    s[i] = o.divideScalar(n[0]);\n  }\n  return s;\n}\nfunction hf(r, e, t, n, s) {\n  const i = lf(r, e, t, n, s);\n  return uf(i);\n}\nclass vr extends Gl {\n  constructor(e, t, n, s, i) {\n    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = i || this.knots.length - 1;\n    for (let o = 0; o < n.length; ++o) {\n      const a = n[o];\n      this.controlPoints[o] = new at(a.x, a.y, a.z, a.w);\n    }\n  }\n  getPoint(e, t) {\n    const n = t || new $(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = rf(this.degree, this.knots, this.controlPoints, s);\n    return i.w != 1 && i.divideScalar(i.w), n.set(i.x, i.y, i.z);\n  }\n  getTangent(e, t) {\n    const n = t || new $(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = hf(this.degree, this.knots, this.controlPoints, s, 1);\n    return n.copy(i[1]).normalize(), n;\n  }\n}\nlet Ce, Qe, mt;\nclass ff extends Un {\n  constructor(e) {\n    super(e);\n  }\n  load(e, t, n, s) {\n    const i = this, o = i.path === \"\" ? qn.extractUrlBase(e) : i.path, a = new kn(this.manager);\n    a.setPath(i.path), a.setResponseType(\"arraybuffer\"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(\n      e,\n      function(l) {\n        try {\n          t(i.parse(l, o));\n        } catch (c) {\n          s ? s(c) : console.error(c), i.manager.itemError(e);\n        }\n      },\n      n,\n      s\n    );\n  }\n  parse(e, t) {\n    if (yf(e))\n      Ce = new vf().parse(e);\n    else {\n      const s = ol(e);\n      if (!_f(s))\n        throw new Error(\"THREE.FBXLoader: Unknown format.\");\n      if (_r(s) < 7e3)\n        throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + _r(s));\n      Ce = new gf().parse(s);\n    }\n    const n = new ai(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);\n    return new df(n, this.manager).parse(Ce);\n  }\n}\nclass df {\n  constructor(e, t) {\n    this.textureLoader = e, this.manager = t;\n  }\n  parse() {\n    Qe = this.parseConnections();\n    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new pf().parse(s);\n    return this.parseScene(s, i, n), mt;\n  }\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const e = /* @__PURE__ */ new Map();\n    return \"Connections\" in Ce && Ce.Connections.connections.forEach(function(n) {\n      const s = n[0], i = n[1], o = n[2];\n      e.has(s) || e.set(s, {\n        parents: [],\n        children: []\n      });\n      const a = { ID: i, relationship: o };\n      e.get(s).parents.push(a), e.has(i) || e.set(i, {\n        parents: [],\n        children: []\n      });\n      const l = { ID: s, relationship: o };\n      e.get(i).children.push(l);\n    }), e;\n  }\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const e = {}, t = {};\n    if (\"Video\" in Ce.Objects) {\n      const n = Ce.Objects.Video;\n      for (const s in n) {\n        const i = n[s], o = parseInt(s);\n        if (e[o] = i.RelativeFilename || i.Filename, \"Content\" in i) {\n          const a = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, l = typeof i.Content == \"string\" && i.Content !== \"\";\n          if (a || l) {\n            const c = this.parseImage(n[s]);\n            t[i.RelativeFilename || i.Filename] = c;\n          }\n        }\n      }\n    }\n    for (const n in e) {\n      const s = e[n];\n      t[s] !== void 0 ? e[n] = t[s] : e[n] = e[n].split(\"\\\\\").pop();\n    }\n    return e;\n  }\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(e) {\n    const t = e.Content, n = e.RelativeFilename || e.Filename, s = n.slice(n.lastIndexOf(\".\") + 1).toLowerCase();\n    let i;\n    switch (s) {\n      case \"bmp\":\n        i = \"image/bmp\";\n        break;\n      case \"jpg\":\n      case \"jpeg\":\n        i = \"image/jpeg\";\n        break;\n      case \"png\":\n        i = \"image/png\";\n        break;\n      case \"tif\":\n        i = \"image/tiff\";\n        break;\n      case \"tga\":\n        this.manager.getHandler(\".tga\") === null && console.warn(\"FBXLoader: TGA loader not found, skipping \", n), i = \"image/tga\";\n        break;\n      default:\n        console.warn('FBXLoader: Image type \"' + s + '\" is not supported.');\n        return;\n    }\n    if (typeof t == \"string\")\n      return \"data:\" + i + \";base64,\" + t;\n    {\n      const o = new Uint8Array(t);\n      return window.URL.createObjectURL(new Blob([o], { type: i }));\n    }\n  }\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(e) {\n    const t = /* @__PURE__ */ new Map();\n    if (\"Texture\" in Ce.Objects) {\n      const n = Ce.Objects.Texture;\n      for (const s in n) {\n        const i = this.parseTexture(n[s], e);\n        t.set(parseInt(s), i);\n      }\n    }\n    return t;\n  }\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(e, t) {\n    const n = this.loadTexture(e, t);\n    n.ID = e.id, n.name = e.attrName;\n    const s = e.WrapModeU, i = e.WrapModeV, o = s !== void 0 ? s.value : 0, a = i !== void 0 ? i.value : 0;\n    if (n.wrapS = o === 0 ? Ln : Wt, n.wrapT = a === 0 ? Ln : Wt, \"Scaling\" in e) {\n      const l = e.Scaling.value;\n      n.repeat.x = l[0], n.repeat.y = l[1];\n    }\n    return n;\n  }\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(e, t) {\n    let n;\n    const s = this.textureLoader.path, i = Qe.get(e.id).children;\n    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (n = t[i[0].ID], (n.indexOf(\"blob:\") === 0 || n.indexOf(\"data:\") === 0) && this.textureLoader.setPath(void 0));\n    let o;\n    const a = e.FileName.slice(-3).toLowerCase();\n    if (a === \"tga\") {\n      const l = this.manager.getHandler(\".tga\");\n      l === null ? (console.warn(\"FBXLoader: TGA loader not found, creating placeholder texture for\", e.RelativeFilename), o = new es()) : (l.setPath(this.textureLoader.path), o = l.load(n));\n    } else a === \"psd\" ? (console.warn(\n      \"FBXLoader: PSD textures are not supported, creating placeholder texture for\",\n      e.RelativeFilename\n    ), o = new es()) : o = this.textureLoader.load(n);\n    return this.textureLoader.setPath(s), o;\n  }\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(e) {\n    const t = /* @__PURE__ */ new Map();\n    if (\"Material\" in Ce.Objects) {\n      const n = Ce.Objects.Material;\n      for (const s in n) {\n        const i = this.parseMaterial(n[s], e);\n        i !== null && t.set(parseInt(s), i);\n      }\n    }\n    return t;\n  }\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(e, t) {\n    const n = e.id, s = e.attrName;\n    let i = e.ShadingModel;\n    if (typeof i == \"object\" && (i = i.value), !Qe.has(n))\n      return null;\n    const o = this.parseParameters(e, t, n);\n    let a;\n    switch (i.toLowerCase()) {\n      case \"phong\":\n        a = new yi();\n        break;\n      case \"lambert\":\n        a = new Hl();\n        break;\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', i), a = new yi();\n        break;\n    }\n    return a.setValues(o), a.name = s, a;\n  }\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(e, t, n) {\n    const s = {};\n    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new be().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === \"Color\" || e.DiffuseColor.type === \"ColorRGB\") && (s.color = new be().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new be().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === \"Color\" || e.EmissiveColor.type === \"ColorRGB\") && (s.emissive = new be().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new be().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === \"Color\" && (s.specular = new be().fromArray(e.SpecularColor.value));\n    const i = this;\n    return Qe.get(n).children.forEach(function(o) {\n      const a = o.relationship;\n      switch (a) {\n        case \"Bump\":\n          s.bumpMap = i.getTexture(t, o.ID);\n          break;\n        case \"Maya|TEX_ao_map\":\n          s.aoMap = i.getTexture(t, o.ID);\n          break;\n        case \"DiffuseColor\":\n        case \"Maya|TEX_color_map\":\n          s.map = i.getTexture(t, o.ID), s.map !== void 0 && (\"colorSpace\" in s.map ? s.map.colorSpace = \"srgb\" : s.map.encoding = 3001);\n          break;\n        case \"DisplacementColor\":\n          s.displacementMap = i.getTexture(t, o.ID);\n          break;\n        case \"EmissiveColor\":\n          s.emissiveMap = i.getTexture(t, o.ID), s.emissiveMap !== void 0 && (\"colorSpace\" in s.emissiveMap ? s.emissiveMap.colorSpace = \"srgb\" : s.emissiveMap.encoding = 3001);\n          break;\n        case \"NormalMap\":\n        case \"Maya|TEX_normal_map\":\n          s.normalMap = i.getTexture(t, o.ID);\n          break;\n        case \"ReflectionColor\":\n          s.envMap = i.getTexture(t, o.ID), s.envMap !== void 0 && (s.envMap.mapping = ho, \"colorSpace\" in s.envMap ? s.envMap.colorSpace = \"srgb\" : s.envMap.encoding = 3001);\n          break;\n        case \"SpecularColor\":\n          s.specularMap = i.getTexture(t, o.ID), s.specularMap !== void 0 && (\"colorSpace\" in s.specularMap ? s.specularMap.colorSpace = \"srgb\" : s.specularMap.encoding = 3001);\n          break;\n        case \"TransparentColor\":\n        case \"TransparencyFactor\":\n          s.alphaMap = i.getTexture(t, o.ID), s.transparent = !0;\n          break;\n        case \"AmbientColor\":\n        case \"ShininessExponent\":\n        case \"SpecularFactor\":\n        case \"VectorDisplacementColor\":\n        default:\n          console.warn(\"THREE.FBXLoader: %s map is not supported in three.js, skipping texture.\", a);\n          break;\n      }\n    }), s;\n  }\n  // get a texture from the textureMap for use by a material.\n  getTexture(e, t) {\n    return \"LayeredTexture\" in Ce.Objects && t in Ce.Objects.LayeredTexture && (console.warn(\"THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.\"), t = Qe.get(t).children[0].ID), e.get(t);\n  }\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const e = {}, t = {};\n    if (\"Deformer\" in Ce.Objects) {\n      const n = Ce.Objects.Deformer;\n      for (const s in n) {\n        const i = n[s], o = Qe.get(parseInt(s));\n        if (i.attrType === \"Skin\") {\n          const a = this.parseSkeleton(o, n);\n          a.ID = s, o.parents.length > 1 && console.warn(\"THREE.FBXLoader: skeleton attached to more than one geometry is not supported.\"), a.geometryID = o.parents[0].ID, e[s] = a;\n        } else if (i.attrType === \"BlendShape\") {\n          const a = {\n            id: s\n          };\n          a.rawTargets = this.parseMorphTargets(o, n), a.id = s, o.parents.length > 1 && console.warn(\"THREE.FBXLoader: morph target attached to more than one geometry is not supported.\"), t[s] = a;\n        }\n      }\n    }\n    return {\n      skeletons: e,\n      morphTargets: t\n    };\n  }\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(e, t) {\n    const n = [];\n    return e.children.forEach(function(s) {\n      const i = t[s.ID];\n      if (i.attrType !== \"Cluster\")\n        return;\n      const o = {\n        ID: s.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Ie().fromArray(i.TransformLink.a)\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      };\n      \"Indexes\" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), n.push(o);\n    }), {\n      rawBones: n,\n      bones: []\n    };\n  }\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(e, t) {\n    const n = [];\n    for (let s = 0; s < e.children.length; s++) {\n      const i = e.children[s], o = t[i.ID], a = {\n        name: o.attrName,\n        initialWeight: o.DeformPercent,\n        id: o.id,\n        fullWeights: o.FullWeights.a\n      };\n      if (o.attrType !== \"BlendShapeChannel\")\n        return;\n      a.geoID = Qe.get(parseInt(i.ID)).children.filter(function(l) {\n        return l.relationship === void 0;\n      })[0].ID, n.push(a);\n    }\n    return n;\n  }\n  // create the main Group() to be returned by the loader\n  parseScene(e, t, n) {\n    mt = new Zt();\n    const s = this.parseModels(e.skeletons, t, n), i = Ce.Objects.Model, o = this;\n    s.forEach(function(l) {\n      const c = i[l.ID];\n      o.setLookAtProperties(l, c), Qe.get(l.ID).parents.forEach(function(u) {\n        const d = s.get(u.ID);\n        d !== void 0 && d.add(l);\n      }), l.parent === null && mt.add(l);\n    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), mt.traverse(function(l) {\n      if (l.userData.transformData) {\n        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);\n        const c = sl(l.userData.transformData);\n        l.applyMatrix4(c), l.updateWorldMatrix();\n      }\n    });\n    const a = new mf().parse();\n    mt.children.length === 1 && mt.children[0].isGroup && (mt.children[0].animations = a, mt = mt.children[0]), mt.animations = a;\n  }\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(e, t, n) {\n    const s = /* @__PURE__ */ new Map(), i = Ce.Objects.Model;\n    for (const o in i) {\n      const a = parseInt(o), l = i[o], c = Qe.get(a);\n      let f = this.buildSkeleton(c, e, a, l.attrName);\n      if (!f) {\n        switch (l.attrType) {\n          case \"Camera\":\n            f = this.createCamera(c);\n            break;\n          case \"Light\":\n            f = this.createLight(c);\n            break;\n          case \"Mesh\":\n            f = this.createMesh(c, t, n);\n            break;\n          case \"NurbsCurve\":\n            f = this.createCurve(c, t);\n            break;\n          case \"LimbNode\":\n          case \"Root\":\n            f = new ao();\n            break;\n          case \"Null\":\n          default:\n            f = new Zt();\n            break;\n        }\n        f.name = l.attrName ? rn.sanitizeNodeName(l.attrName) : \"\", f.ID = a;\n      }\n      this.getTransformData(f, l), s.set(a, f);\n    }\n    return s;\n  }\n  buildSkeleton(e, t, n, s) {\n    let i = null;\n    return e.parents.forEach(function(o) {\n      for (const a in t) {\n        const l = t[a];\n        l.rawBones.forEach(function(c, f) {\n          if (c.ID === o.ID) {\n            const u = i;\n            i = new ao(), i.matrixWorld.copy(c.transformLink), i.name = s ? rn.sanitizeNodeName(s) : \"\", i.ID = n, l.bones[f] = i, u !== null && i.add(u);\n          }\n        });\n      }\n    }), i;\n  }\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(e) {\n    let t, n;\n    if (e.children.forEach(function(s) {\n      const i = Ce.Objects.NodeAttribute[s.ID];\n      i !== void 0 && (n = i);\n    }), n === void 0)\n      t = new Rt();\n    else {\n      let s = 0;\n      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);\n      let i = 1;\n      n.NearPlane !== void 0 && (i = n.NearPlane.value / 1e3);\n      let o = 1e3;\n      n.FarPlane !== void 0 && (o = n.FarPlane.value / 1e3);\n      let a = window.innerWidth, l = window.innerHeight;\n      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, l = n.AspectHeight.value);\n      const c = a / l;\n      let f = 45;\n      n.FieldOfView !== void 0 && (f = n.FieldOfView.value);\n      const u = n.FocalLength ? n.FocalLength.value : null;\n      switch (s) {\n        case 0:\n          t = new kt(f, c, i, o), u !== null && t.setFocalLength(u);\n          break;\n        case 1:\n          t = new _n(\n            -a / 2,\n            a / 2,\n            l / 2,\n            -l / 2,\n            i,\n            o\n          );\n          break;\n        default:\n          console.warn(\"THREE.FBXLoader: Unknown camera type \" + s + \".\"), t = new Rt();\n          break;\n      }\n    }\n    return t;\n  }\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(e) {\n    let t, n;\n    if (e.children.forEach(function(s) {\n      const i = Ce.Objects.NodeAttribute[s.ID];\n      i !== void 0 && (n = i);\n    }), n === void 0)\n      t = new Rt();\n    else {\n      let s;\n      n.LightType === void 0 ? s = 0 : s = n.LightType.value;\n      let i = 16777215;\n      n.Color !== void 0 && (i = new be().fromArray(n.Color.value));\n      let o = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;\n      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (o = 0);\n      let a = 0;\n      n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);\n      const l = 1;\n      switch (s) {\n        case 0:\n          t = new ro(i, o, a, l);\n          break;\n        case 1:\n          t = new wa(i, o);\n          break;\n        case 2:\n          let c = Math.PI / 3;\n          n.InnerAngle !== void 0 && (c = Ye.degToRad(n.InnerAngle.value));\n          let f = 0;\n          n.OuterAngle !== void 0 && (f = Ye.degToRad(n.OuterAngle.value), f = Math.max(f, 1)), t = new xa(i, o, a, c, f, l);\n          break;\n        default:\n          console.warn(\n            \"THREE.FBXLoader: Unknown light type \" + n.LightType.value + \", defaulting to a PointLight.\"\n          ), t = new ro(i, o);\n          break;\n      }\n      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);\n    }\n    return t;\n  }\n  createMesh(e, t, n) {\n    let s, i = null, o = null;\n    const a = [];\n    return e.children.forEach(function(l) {\n      t.has(l.ID) && (i = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));\n    }), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new yi({ color: 13421772 }), a.push(o)), \"color\" in i.attributes && a.forEach(function(l) {\n      l.vertexColors = !0;\n    }), i.FBX_Deformer ? (s = new Po(i, o), s.normalizeSkinWeights()) : s = new de(i, o), s;\n  }\n  createCurve(e, t) {\n    const n = e.children.reduce(function(i, o) {\n      return t.has(o.ID) && (i = t.get(o.ID)), i;\n    }, null), s = new ws({ color: 3342591, linewidth: 1 });\n    return new ke(n, s);\n  }\n  // parse the model node for transform data\n  getTransformData(e, t) {\n    const n = {};\n    \"InheritType\" in t && (n.inheritType = parseInt(t.InheritType.value)), \"RotationOrder\" in t ? n.eulerOrder = il(t.RotationOrder.value) : n.eulerOrder = \"ZYX\", \"Lcl_Translation\" in t && (n.translation = t.Lcl_Translation.value), \"PreRotation\" in t && (n.preRotation = t.PreRotation.value), \"Lcl_Rotation\" in t && (n.rotation = t.Lcl_Rotation.value), \"PostRotation\" in t && (n.postRotation = t.PostRotation.value), \"Lcl_Scaling\" in t && (n.scale = t.Lcl_Scaling.value), \"ScalingOffset\" in t && (n.scalingOffset = t.ScalingOffset.value), \"ScalingPivot\" in t && (n.scalingPivot = t.ScalingPivot.value), \"RotationOffset\" in t && (n.rotationOffset = t.RotationOffset.value), \"RotationPivot\" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;\n  }\n  setLookAtProperties(e, t) {\n    \"LookAtProperty\" in t && Qe.get(e.ID).children.forEach(function(s) {\n      if (s.relationship === \"LookAtProperty\") {\n        const i = Ce.Objects.Model[s.ID];\n        if (\"Lcl_Translation\" in i) {\n          const o = i.Lcl_Translation.value;\n          e.target !== void 0 ? (e.target.position.fromArray(o), mt.add(e.target)) : e.lookAt(new $().fromArray(o));\n        }\n      }\n    });\n  }\n  bindSkeleton(e, t, n) {\n    const s = this.parsePoseNodes();\n    for (const i in e) {\n      const o = e[i];\n      Qe.get(parseInt(o.ID)).parents.forEach(function(l) {\n        if (t.has(l.ID)) {\n          const c = l.ID;\n          Qe.get(c).parents.forEach(function(u) {\n            n.has(u.ID) && n.get(u.ID).bind(new Ea(o.bones), s[u.ID]);\n          });\n        }\n      });\n    }\n  }\n  parsePoseNodes() {\n    const e = {};\n    if (\"Pose\" in Ce.Objects) {\n      const t = Ce.Objects.Pose;\n      for (const n in t)\n        if (t[n].attrType === \"BindPose\" && t[n].NbPoseNodes > 0) {\n          const s = t[n].PoseNode;\n          Array.isArray(s) ? s.forEach(function(i) {\n            e[i.Node] = new Ie().fromArray(i.Matrix.a);\n          }) : e[s.Node] = new Ie().fromArray(s.Matrix.a);\n        }\n    }\n    return e;\n  }\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  createAmbientLight() {\n    if (\"GlobalSettings\" in Ce && \"AmbientColor\" in Ce.GlobalSettings) {\n      const e = Ce.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];\n      if (t !== 0 || n !== 0 || s !== 0) {\n        const i = new be(t, n, s);\n        mt.add(new jl(i, 1));\n      }\n    }\n  }\n}\nclass pf {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(e) {\n    const t = /* @__PURE__ */ new Map();\n    if (\"Geometry\" in Ce.Objects) {\n      const n = Ce.Objects.Geometry;\n      for (const s in n) {\n        const i = Qe.get(parseInt(s)), o = this.parseGeometry(i, n[s], e);\n        t.set(parseInt(s), o);\n      }\n    }\n    return t;\n  }\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(e, t, n) {\n    switch (t.attrType) {\n      case \"Mesh\":\n        return this.parseMeshGeometry(e, t, n);\n      case \"NurbsCurve\":\n        return this.parseNurbsGeometry(t);\n    }\n  }\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(e, t, n) {\n    const s = n.skeletons, i = [], o = e.parents.map(function(u) {\n      return Ce.Objects.Model[u.ID];\n    });\n    if (o.length === 0)\n      return;\n    const a = e.children.reduce(function(u, d) {\n      return s[d.ID] !== void 0 && (u = s[d.ID]), u;\n    }, null);\n    e.children.forEach(function(u) {\n      n.morphTargets[u.ID] !== void 0 && i.push(n.morphTargets[u.ID]);\n    });\n    const l = o[0], c = {};\n    \"RotationOrder\" in l && (c.eulerOrder = il(l.RotationOrder.value)), \"InheritType\" in l && (c.inheritType = parseInt(l.InheritType.value)), \"GeometricTranslation\" in l && (c.translation = l.GeometricTranslation.value), \"GeometricRotation\" in l && (c.rotation = l.GeometricRotation.value), \"GeometricScaling\" in l && (c.scale = l.GeometricScaling.value);\n    const f = sl(c);\n    return this.genGeometry(t, a, i, f);\n  }\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(e, t, n, s) {\n    const i = new ht();\n    e.attrName && (i.name = e.attrName);\n    const o = this.parseGeoNode(e, t), a = this.genBuffers(o), l = new gt(a.vertex, 3);\n    if (l.applyMatrix4(s), i.setAttribute(\"position\", l), a.colors.length > 0 && i.setAttribute(\"color\", new gt(a.colors, 3)), t && (i.setAttribute(\"skinIndex\", new Vl(a.weightsIndices, 4)), i.setAttribute(\"skinWeight\", new gt(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {\n      const c = new Cn().getNormalMatrix(s), f = new gt(a.normal, 3);\n      f.applyNormalMatrix(c), i.setAttribute(\"normal\", f);\n    }\n    if (a.uvs.forEach(function(c, f) {\n      Bo === \"uv2\" && f++;\n      const u = f === 0 ? \"uv\" : `uv${f}`;\n      i.setAttribute(u, new gt(a.uvs[f], 2));\n    }), o.material && o.material.mappingType !== \"AllSame\") {\n      let c = a.materialIndex[0], f = 0;\n      if (a.materialIndex.forEach(function(u, d) {\n        u !== c && (i.addGroup(f, d - f, c), c = u, f = d);\n      }), i.groups.length > 0) {\n        const u = i.groups[i.groups.length - 1], d = u.start + u.count;\n        d !== a.materialIndex.length && i.addGroup(d, a.materialIndex.length - d, c);\n      }\n      i.groups.length === 0 && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]);\n    }\n    return this.addMorphTargets(i, e, n, s), i;\n  }\n  parseGeoNode(e, t) {\n    const n = {};\n    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {\n      n.uv = [];\n      let s = 0;\n      for (; e.LayerElementUV[s]; )\n        e.LayerElementUV[s].UV && n.uv.push(this.parseUVs(e.LayerElementUV[s])), s++;\n    }\n    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(s, i) {\n      s.indices.forEach(function(o, a) {\n        n.weightTable[o] === void 0 && (n.weightTable[o] = []), n.weightTable[o].push({\n          id: i,\n          weight: s.weights[a]\n        });\n      });\n    })), n;\n  }\n  genBuffers(e) {\n    const t = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    let n = 0, s = 0, i = !1, o = [], a = [], l = [], c = [], f = [], u = [];\n    const d = this;\n    return e.vertexIndices.forEach(function(h, m) {\n      let g, v = !1;\n      h < 0 && (h = h ^ -1, v = !0);\n      let p = [], b = [];\n      if (o.push(h * 3, h * 3 + 1, h * 3 + 2), e.color) {\n        const _ = Gs(m, n, h, e.color);\n        l.push(_[0], _[1], _[2]);\n      }\n      if (e.skeleton) {\n        if (e.weightTable[h] !== void 0 && e.weightTable[h].forEach(function(_) {\n          b.push(_.weight), p.push(_.id);\n        }), b.length > 4) {\n          i || (console.warn(\n            \"THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.\"\n          ), i = !0);\n          const _ = [0, 0, 0, 0], M = [0, 0, 0, 0];\n          b.forEach(function(R, w) {\n            let E = R, x = p[w];\n            M.forEach(function(T, y, A) {\n              if (E > T) {\n                A[y] = E, E = T;\n                const C = _[y];\n                _[y] = x, x = C;\n              }\n            });\n          }), p = _, b = M;\n        }\n        for (; b.length < 4; )\n          b.push(0), p.push(0);\n        for (let _ = 0; _ < 4; ++_)\n          f.push(b[_]), u.push(p[_]);\n      }\n      if (e.normal) {\n        const _ = Gs(m, n, h, e.normal);\n        a.push(_[0], _[1], _[2]);\n      }\n      e.material && e.material.mappingType !== \"AllSame\" && (g = Gs(m, n, h, e.material)[0]), e.uv && e.uv.forEach(function(_, M) {\n        const R = Gs(m, n, h, _);\n        c[M] === void 0 && (c[M] = []), c[M].push(R[0]), c[M].push(R[1]);\n      }), s++, v && (d.genFace(\n        t,\n        e,\n        o,\n        g,\n        a,\n        l,\n        c,\n        f,\n        u,\n        s\n      ), n++, s = 0, o = [], a = [], l = [], c = [], f = [], u = []);\n    }), t;\n  }\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(e, t, n, s, i, o, a, l, c, f) {\n    for (let u = 2; u < f; u++)\n      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[u * 3]]), e.vertex.push(t.vertexPositions[n[u * 3 + 1]]), e.vertex.push(t.vertexPositions[n[u * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(u - 1) * 4]), e.vertexWeights.push(l[(u - 1) * 4 + 1]), e.vertexWeights.push(l[(u - 1) * 4 + 2]), e.vertexWeights.push(l[(u - 1) * 4 + 3]), e.vertexWeights.push(l[u * 4]), e.vertexWeights.push(l[u * 4 + 1]), e.vertexWeights.push(l[u * 4 + 2]), e.vertexWeights.push(l[u * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(u - 1) * 4]), e.weightsIndices.push(c[(u - 1) * 4 + 1]), e.weightsIndices.push(c[(u - 1) * 4 + 2]), e.weightsIndices.push(c[(u - 1) * 4 + 3]), e.weightsIndices.push(c[u * 4]), e.weightsIndices.push(c[u * 4 + 1]), e.weightsIndices.push(c[u * 4 + 2]), e.weightsIndices.push(c[u * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(u - 1) * 3]), e.colors.push(o[(u - 1) * 3 + 1]), e.colors.push(o[(u - 1) * 3 + 2]), e.colors.push(o[u * 3]), e.colors.push(o[u * 3 + 1]), e.colors.push(o[u * 3 + 2])), t.material && t.material.mappingType !== \"AllSame\" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(u - 1) * 3]), e.normal.push(i[(u - 1) * 3 + 1]), e.normal.push(i[(u - 1) * 3 + 2]), e.normal.push(i[u * 3]), e.normal.push(i[u * 3 + 1]), e.normal.push(i[u * 3 + 2])), t.uv && t.uv.forEach(function(d, h) {\n        e.uvs[h] === void 0 && (e.uvs[h] = []), e.uvs[h].push(a[h][0]), e.uvs[h].push(a[h][1]), e.uvs[h].push(a[h][(u - 1) * 2]), e.uvs[h].push(a[h][(u - 1) * 2 + 1]), e.uvs[h].push(a[h][u * 2]), e.uvs[h].push(a[h][u * 2 + 1]);\n      });\n  }\n  addMorphTargets(e, t, n, s) {\n    if (n.length === 0)\n      return;\n    e.morphTargetsRelative = !0, e.morphAttributes.position = [];\n    const i = this;\n    n.forEach(function(o) {\n      o.rawTargets.forEach(function(a) {\n        const l = Ce.Objects.Geometry[a.geoID];\n        l !== void 0 && i.genMorphGeometry(e, t, l, s, a.name);\n      });\n    });\n  }\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(e, t, n, s, i) {\n    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, f = new Float32Array(c);\n    for (let m = 0; m < l.length; m++) {\n      const g = l[m] * 3;\n      f[g] = a[m * 3], f[g + 1] = a[m * 3 + 1], f[g + 2] = a[m * 3 + 2];\n    }\n    const u = {\n      vertexIndices: o,\n      vertexPositions: f\n    }, d = this.genBuffers(u), h = new gt(d.vertex, 3);\n    h.name = i || n.attrName, h.applyMatrix4(s), e.morphAttributes.position.push(h);\n  }\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(e) {\n    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Normals.a;\n    let i = [];\n    return n === \"IndexToDirect\" && (\"NormalIndex\" in e ? i = e.NormalIndex.a : \"NormalsIndex\" in e && (i = e.NormalsIndex.a)), {\n      dataSize: 3,\n      buffer: s,\n      indices: i,\n      mappingType: t,\n      referenceType: n\n    };\n  }\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(e) {\n    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.UV.a;\n    let i = [];\n    return n === \"IndexToDirect\" && (i = e.UVIndex.a), {\n      dataSize: 2,\n      buffer: s,\n      indices: i,\n      mappingType: t,\n      referenceType: n\n    };\n  }\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(e) {\n    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Colors.a;\n    let i = [];\n    return n === \"IndexToDirect\" && (i = e.ColorIndex.a), {\n      dataSize: 4,\n      buffer: s,\n      indices: i,\n      mappingType: t,\n      referenceType: n\n    };\n  }\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(e) {\n    const t = e.MappingInformationType, n = e.ReferenceInformationType;\n    if (t === \"NoMappingInformation\")\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: \"AllSame\",\n        referenceType: n\n      };\n    const s = e.Materials.a, i = [];\n    for (let o = 0; o < s.length; ++o)\n      i.push(o);\n    return {\n      dataSize: 1,\n      buffer: s,\n      indices: i,\n      mappingType: t,\n      referenceType: n\n    };\n  }\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(e) {\n    if (vr === void 0)\n      return console.error(\n        \"THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.\"\n      ), new ht();\n    const t = parseInt(e.Order);\n    if (isNaN(t))\n      return console.error(\"THREE.FBXLoader: Invalid Order %s given for geometry ID: %s\", e.Order, e.id), new ht();\n    const n = t - 1, s = e.KnotVector.a, i = [], o = e.Points.a;\n    for (let u = 0, d = o.length; u < d; u += 4)\n      i.push(new at().fromArray(o, u));\n    let a, l;\n    if (e.Form === \"Closed\")\n      i.push(i[0]);\n    else if (e.Form === \"Periodic\") {\n      a = n, l = s.length - 1 - a;\n      for (let u = 0; u < n; ++u)\n        i.push(i[u]);\n    }\n    const f = new vr(n, s, i, a, l).getPoints(i.length * 12);\n    return new ht().setFromPoints(f);\n  }\n}\nclass mf {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const e = [], t = this.parseClips();\n    if (t !== void 0)\n      for (const n in t) {\n        const s = t[n], i = this.addClip(s);\n        e.push(i);\n      }\n    return e;\n  }\n  parseClips() {\n    if (Ce.Objects.AnimationCurve === void 0)\n      return;\n    const e = this.parseAnimationCurveNodes();\n    this.parseAnimationCurves(e);\n    const t = this.parseAnimationLayers(e);\n    return this.parseAnimStacks(t);\n  }\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const e = Ce.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();\n    for (const n in e) {\n      const s = e[n];\n      if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const i = {\n          id: s.id,\n          attr: s.attrName,\n          curves: {}\n        };\n        t.set(i.id, i);\n      }\n    }\n    return t;\n  }\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(e) {\n    const t = Ce.Objects.AnimationCurve;\n    for (const n in t) {\n      const s = {\n        id: t[n].id,\n        times: t[n].KeyTime.a.map(xf),\n        values: t[n].KeyValueFloat.a\n      }, i = Qe.get(s.id);\n      if (i !== void 0) {\n        const o = i.parents[0].ID, a = i.parents[0].relationship;\n        a.match(/X/) ? e.get(o).curves.x = s : a.match(/Y/) ? e.get(o).curves.y = s : a.match(/Z/) ? e.get(o).curves.z = s : a.match(/d|DeformPercent/) && e.has(o) && (e.get(o).curves.morph = s);\n      }\n    }\n  }\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(e) {\n    const t = Ce.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();\n    for (const s in t) {\n      const i = [], o = Qe.get(parseInt(s));\n      o !== void 0 && (o.children.forEach(function(l, c) {\n        if (e.has(l.ID)) {\n          const f = e.get(l.ID);\n          if (f.curves.x !== void 0 || f.curves.y !== void 0 || f.curves.z !== void 0) {\n            if (i[c] === void 0) {\n              const u = Qe.get(l.ID).parents.filter(function(d) {\n                return d.relationship !== void 0;\n              })[0].ID;\n              if (u !== void 0) {\n                const d = Ce.Objects.Model[u.toString()];\n                if (d === void 0) {\n                  console.warn(\"THREE.FBXLoader: Encountered a unused curve.\", l);\n                  return;\n                }\n                const h = {\n                  modelName: d.attrName ? rn.sanitizeNodeName(d.attrName) : \"\",\n                  ID: d.id,\n                  initialPosition: [0, 0, 0],\n                  initialRotation: [0, 0, 0],\n                  initialScale: [1, 1, 1]\n                };\n                mt.traverse(function(m) {\n                  m.ID === d.id && (h.transform = m.matrix, m.userData.transformData && (h.eulerOrder = m.userData.transformData.eulerOrder));\n                }), h.transform || (h.transform = new Ie()), \"PreRotation\" in d && (h.preRotation = d.PreRotation.value), \"PostRotation\" in d && (h.postRotation = d.PostRotation.value), i[c] = h;\n              }\n            }\n            i[c] && (i[c][f.attr] = f);\n          } else if (f.curves.morph !== void 0) {\n            if (i[c] === void 0) {\n              const u = Qe.get(l.ID).parents.filter(function(p) {\n                return p.relationship !== void 0;\n              })[0].ID, d = Qe.get(u).parents[0].ID, h = Qe.get(d).parents[0].ID, m = Qe.get(h).parents[0].ID, g = Ce.Objects.Model[m], v = {\n                modelName: g.attrName ? rn.sanitizeNodeName(g.attrName) : \"\",\n                morphName: Ce.Objects.Deformer[u].attrName\n              };\n              i[c] = v;\n            }\n            i[c][f.attr] = f;\n          }\n        }\n      }), n.set(parseInt(s), i));\n    }\n    return n;\n  }\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(e) {\n    const t = Ce.Objects.AnimationStack, n = {};\n    for (const s in t) {\n      const i = Qe.get(parseInt(s)).children;\n      i.length > 1 && console.warn(\n        \"THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.\"\n      );\n      const o = e.get(i[0].ID);\n      n[s] = {\n        name: t[s].attrName,\n        layer: o\n      };\n    }\n    return n;\n  }\n  addClip(e) {\n    let t = [];\n    const n = this;\n    return e.layer.forEach(function(s) {\n      t = t.concat(n.generateTracks(s));\n    }), new Ma(e.name, -1, t);\n  }\n  generateTracks(e) {\n    const t = [];\n    let n = new $(), s = new je(), i = new $();\n    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new vt().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {\n      const o = this.generateVectorTrack(\n        e.modelName,\n        e.T.curves,\n        n,\n        \"position\"\n      );\n      o !== void 0 && t.push(o);\n    }\n    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {\n      const o = this.generateRotationTrack(\n        e.modelName,\n        e.R.curves,\n        s,\n        e.preRotation,\n        e.postRotation,\n        e.eulerOrder\n      );\n      o !== void 0 && t.push(o);\n    }\n    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {\n      const o = this.generateVectorTrack(e.modelName, e.S.curves, i, \"scale\");\n      o !== void 0 && t.push(o);\n    }\n    if (e.DeformPercent !== void 0) {\n      const o = this.generateMorphTrack(e);\n      o !== void 0 && t.push(o);\n    }\n    return t;\n  }\n  generateVectorTrack(e, t, n, s) {\n    const i = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(i, t, n);\n    return new lo(e + \".\" + s, i, o);\n  }\n  generateRotationTrack(e, t, n, s, i, o) {\n    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Ye.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Ye.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Ye.degToRad));\n    const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);\n    s !== void 0 && (s = s.map(Ye.degToRad), s.push(o), s = new vt().fromArray(s), s = new je().setFromEuler(s)), i !== void 0 && (i = i.map(Ye.degToRad), i.push(o), i = new vt().fromArray(i), i = new je().setFromEuler(i).invert());\n    const c = new je(), f = new vt(), u = [];\n    for (let d = 0; d < l.length; d += 3)\n      f.set(l[d], l[d + 1], l[d + 2], o), c.setFromEuler(f), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(u, d / 3 * 4);\n    return new uo(e + \".quaternion\", a, u);\n  }\n  generateMorphTrack(e) {\n    const t = e.DeformPercent.curves.morph, n = t.values.map(function(i) {\n      return i / 100;\n    }), s = mt.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];\n    return new co(\n      e.modelName + \".morphTargetInfluences[\" + s + \"]\",\n      t.times,\n      n\n    );\n  }\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(e) {\n    let t = [];\n    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, s) {\n      return n - s;\n    }), t.length > 1) {\n      let n = 1, s = t[0];\n      for (let i = 1; i < t.length; i++) {\n        const o = t[i];\n        o !== s && (t[n] = o, s = o, n++);\n      }\n      t = t.slice(0, n);\n    }\n    return t;\n  }\n  getKeyframeTrackValues(e, t, n) {\n    const s = n, i = [];\n    let o = -1, a = -1, l = -1;\n    return e.forEach(function(c) {\n      if (t.x && (o = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), o !== -1) {\n        const f = t.x.values[o];\n        i.push(f), s[0] = f;\n      } else\n        i.push(s[0]);\n      if (a !== -1) {\n        const f = t.y.values[a];\n        i.push(f), s[1] = f;\n      } else\n        i.push(s[1]);\n      if (l !== -1) {\n        const f = t.z.values[l];\n        i.push(f), s[2] = f;\n      } else\n        i.push(s[2]);\n    }), i;\n  }\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(e) {\n    for (let t = 1; t < e.values.length; t++) {\n      const n = e.values[t - 1], s = e.values[t] - n, i = Math.abs(s);\n      if (i >= 180) {\n        const o = i / 180, a = s / o;\n        let l = n + a;\n        const c = e.times[t - 1], u = (e.times[t] - c) / o;\n        let d = c + u;\n        const h = [], m = [];\n        for (; d < e.times[t]; )\n          h.push(d), d += u, m.push(l), l += a;\n        e.times = xr(e.times, t, h), e.values = xr(e.values, t, m);\n      }\n    }\n  }\n}\nclass gf {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2];\n  }\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1];\n  }\n  getCurrentProp() {\n    return this.currentProp;\n  }\n  pushStack(e) {\n    this.nodeStack.push(e), this.currentIndent += 1;\n  }\n  popStack() {\n    this.nodeStack.pop(), this.currentIndent -= 1;\n  }\n  setCurrentProp(e, t) {\n    this.currentProp = e, this.currentPropName = t;\n  }\n  parse(e) {\n    this.currentIndent = 0, this.allNodes = new nl(), this.nodeStack = [], this.currentProp = [], this.currentPropName = \"\";\n    const t = this, n = e.split(/[\\r\\n]+/);\n    return n.forEach(function(s, i) {\n      const o = s.match(/^[\\s\\t]*;/), a = s.match(/^[\\s\\t]*$/);\n      if (o || a)\n        return;\n      const l = s.match(\"^\\\\t{\" + t.currentIndent + \"}(\\\\w+):(.*){\", \"\"), c = s.match(\"^\\\\t{\" + t.currentIndent + \"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\"), f = s.match(\"^\\\\t{\" + (t.currentIndent - 1) + \"}}\");\n      l ? t.parseNodeBegin(s, l) : c ? t.parseNodeProperty(s, c, n[++i]) : f ? t.popStack() : s.match(/^[^\\s\\t}]/) && t.parseNodePropertyContinued(s);\n    }), this.allNodes;\n  }\n  parseNodeBegin(e, t) {\n    const n = t[1].trim().replace(/^\"/, \"\").replace(/\"$/, \"\"), s = t[2].split(\",\").map(function(l) {\n      return l.trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n    }), i = { name: n }, o = this.parseNodeAttr(s), a = this.getCurrentNode();\n    this.currentIndent === 0 ? this.allNodes.add(n, i) : n in a ? (n === \"PoseNode\" ? a.PoseNode.push(i) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), o.id !== \"\" && (a[n][o.id] = i)) : typeof o.id == \"number\" ? (a[n] = {}, a[n][o.id] = i) : n !== \"Properties70\" && (n === \"PoseNode\" ? a[n] = [i] : a[n] = i), typeof o.id == \"number\" && (i.id = o.id), o.name !== \"\" && (i.attrName = o.name), o.type !== \"\" && (i.attrType = o.type), this.pushStack(i);\n  }\n  parseNodeAttr(e) {\n    let t = e[0];\n    e[0] !== \"\" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));\n    let n = \"\", s = \"\";\n    return e.length > 1 && (n = e[1].replace(/^(\\w+)::/, \"\"), s = e[2]), { id: t, name: n, type: s };\n  }\n  parseNodeProperty(e, t, n) {\n    let s = t[1].replace(/^\"/, \"\").replace(/\"$/, \"\").trim(), i = t[2].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n    s === \"Content\" && i === \",\" && (i = n.replace(/\"/g, \"\").replace(/,$/, \"\").trim());\n    const o = this.getCurrentNode();\n    if (o.name === \"Properties70\") {\n      this.parseNodeSpecialProperty(e, s, i);\n      return;\n    }\n    if (s === \"C\") {\n      const l = i.split(\",\").slice(1), c = parseInt(l[0]), f = parseInt(l[1]);\n      let u = i.split(\",\").slice(3);\n      u = u.map(function(d) {\n        return d.trim().replace(/^\"/, \"\");\n      }), s = \"connections\", i = [c, f], Tf(i, u), o[s] === void 0 && (o[s] = []);\n    }\n    s === \"Node\" && (o.id = i), s in o && Array.isArray(o[s]) ? o[s].push(i) : s !== \"a\" ? o[s] = i : o.a = i, this.setCurrentProp(o, s), s === \"a\" && i.slice(-1) !== \",\" && (o.a = Di(i));\n  }\n  parseNodePropertyContinued(e) {\n    const t = this.getCurrentNode();\n    t.a += e, e.slice(-1) !== \",\" && (t.a = Di(t.a));\n  }\n  // parse \"Property70\"\n  parseNodeSpecialProperty(e, t, n) {\n    const s = n.split('\",').map(function(f) {\n      return f.trim().replace(/^\\\"/, \"\").replace(/\\s/, \"_\");\n    }), i = s[0], o = s[1], a = s[2], l = s[3];\n    let c = s[4];\n    switch (o) {\n      case \"int\":\n      case \"enum\":\n      case \"bool\":\n      case \"ULongLong\":\n      case \"double\":\n      case \"Number\":\n      case \"FieldOfView\":\n        c = parseFloat(c);\n        break;\n      case \"Color\":\n      case \"ColorRGB\":\n      case \"Vector3D\":\n      case \"Lcl_Translation\":\n      case \"Lcl_Rotation\":\n      case \"Lcl_Scaling\":\n        c = Di(c);\n        break;\n    }\n    this.getPrevNode()[i] = {\n      type: o,\n      type2: a,\n      flag: l,\n      value: c\n    }, this.setCurrentProp(this.getPrevNode(), i);\n  }\n}\nclass vf {\n  parse(e) {\n    const t = new yr(e);\n    t.skip(23);\n    const n = t.getUint32();\n    if (n < 6400)\n      throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + n);\n    const s = new nl();\n    for (; !this.endOfContent(t); ) {\n      const i = this.parseNode(t, n);\n      i !== null && s.add(i.name, i);\n    }\n    return s;\n  }\n  // Check if reader has reached the end of content.\n  endOfContent(e) {\n    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();\n  }\n  // recursively parse nodes until the end of the file is reached\n  parseNode(e, t) {\n    const n = {}, s = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();\n    t >= 7500 ? e.getUint64() : e.getUint32();\n    const o = e.getUint8(), a = e.getString(o);\n    if (s === 0)\n      return null;\n    const l = [];\n    for (let d = 0; d < i; d++)\n      l.push(this.parseProperty(e));\n    const c = l.length > 0 ? l[0] : \"\", f = l.length > 1 ? l[1] : \"\", u = l.length > 2 ? l[2] : \"\";\n    for (n.singleProperty = i === 1 && e.getOffset() === s; s > e.getOffset(); ) {\n      const d = this.parseNode(e, t);\n      d !== null && this.parseSubNode(a, n, d);\n    }\n    return n.propertyList = l, typeof c == \"number\" && (n.id = c), f !== \"\" && (n.attrName = f), u !== \"\" && (n.attrType = u), a !== \"\" && (n.name = a), n;\n  }\n  parseSubNode(e, t, n) {\n    if (n.singleProperty === !0) {\n      const s = n.propertyList[0];\n      Array.isArray(s) ? (t[n.name] = n, n.a = s) : t[n.name] = s;\n    } else if (e === \"Connections\" && n.name === \"C\") {\n      const s = [];\n      n.propertyList.forEach(function(i, o) {\n        o !== 0 && s.push(i);\n      }), t.connections === void 0 && (t.connections = []), t.connections.push(s);\n    } else if (n.name === \"Properties70\")\n      Object.keys(n).forEach(function(i) {\n        t[i] = n[i];\n      });\n    else if (e === \"Properties70\" && n.name === \"P\") {\n      let s = n.propertyList[0], i = n.propertyList[1];\n      const o = n.propertyList[2], a = n.propertyList[3];\n      let l;\n      s.indexOf(\"Lcl \") === 0 && (s = s.replace(\"Lcl \", \"Lcl_\")), i.indexOf(\"Lcl \") === 0 && (i = i.replace(\"Lcl \", \"Lcl_\")), i === \"Color\" || i === \"ColorRGB\" || i === \"Vector\" || i === \"Vector3D\" || i.indexOf(\"Lcl_\") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4], t[s] = {\n        type: i,\n        type2: o,\n        flag: a,\n        value: l\n      };\n    } else t[n.name] === void 0 ? typeof n.id == \"number\" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === \"PoseNode\" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);\n  }\n  parseProperty(e) {\n    const t = e.getString(1);\n    let n;\n    switch (t) {\n      case \"C\":\n        return e.getBoolean();\n      case \"D\":\n        return e.getFloat64();\n      case \"F\":\n        return e.getFloat32();\n      case \"I\":\n        return e.getInt32();\n      case \"L\":\n        return e.getInt64();\n      case \"R\":\n        return n = e.getUint32(), e.getArrayBuffer(n);\n      case \"S\":\n        return n = e.getUint32(), e.getString(n);\n      case \"Y\":\n        return e.getInt16();\n      case \"b\":\n      case \"c\":\n      case \"d\":\n      case \"f\":\n      case \"i\":\n      case \"l\":\n        const s = e.getUint32(), i = e.getUint32(), o = e.getUint32();\n        if (i === 0)\n          switch (t) {\n            case \"b\":\n            case \"c\":\n              return e.getBooleanArray(s);\n            case \"d\":\n              return e.getFloat64Array(s);\n            case \"f\":\n              return e.getFloat32Array(s);\n            case \"i\":\n              return e.getInt32Array(s);\n            case \"l\":\n              return e.getInt64Array(s);\n          }\n        const a = Wu(new Uint8Array(e.getArrayBuffer(o))), l = new yr(a.buffer);\n        switch (t) {\n          case \"b\":\n          case \"c\":\n            return l.getBooleanArray(s);\n          case \"d\":\n            return l.getFloat64Array(s);\n          case \"f\":\n            return l.getFloat32Array(s);\n          case \"i\":\n            return l.getInt32Array(s);\n          case \"l\":\n            return l.getInt64Array(s);\n        }\n      default:\n        throw new Error(\"THREE.FBXLoader: Unknown property type \" + t);\n    }\n  }\n}\nclass yr {\n  constructor(e, t) {\n    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;\n  }\n  getOffset() {\n    return this.offset;\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  skip(e) {\n    this.offset += e;\n  }\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1;\n  }\n  getBooleanArray(e) {\n    const t = [];\n    for (let n = 0; n < e; n++)\n      t.push(this.getBoolean());\n    return t;\n  }\n  getUint8() {\n    const e = this.dv.getUint8(this.offset);\n    return this.offset += 1, e;\n  }\n  getInt16() {\n    const e = this.dv.getInt16(this.offset, this.littleEndian);\n    return this.offset += 2, e;\n  }\n  getInt32() {\n    const e = this.dv.getInt32(this.offset, this.littleEndian);\n    return this.offset += 4, e;\n  }\n  getInt32Array(e) {\n    const t = [];\n    for (let n = 0; n < e; n++)\n      t.push(this.getInt32());\n    return t;\n  }\n  getUint32() {\n    const e = this.dv.getUint32(this.offset, this.littleEndian);\n    return this.offset += 4, e;\n  }\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let e, t;\n    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;\n  }\n  getInt64Array(e) {\n    const t = [];\n    for (let n = 0; n < e; n++)\n      t.push(this.getInt64());\n    return t;\n  }\n  // Note: see getInt64() comment\n  getUint64() {\n    let e, t;\n    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;\n  }\n  getFloat32() {\n    const e = this.dv.getFloat32(this.offset, this.littleEndian);\n    return this.offset += 4, e;\n  }\n  getFloat32Array(e) {\n    const t = [];\n    for (let n = 0; n < e; n++)\n      t.push(this.getFloat32());\n    return t;\n  }\n  getFloat64() {\n    const e = this.dv.getFloat64(this.offset, this.littleEndian);\n    return this.offset += 8, e;\n  }\n  getFloat64Array(e) {\n    const t = [];\n    for (let n = 0; n < e; n++)\n      t.push(this.getFloat64());\n    return t;\n  }\n  getArrayBuffer(e) {\n    const t = this.dv.buffer.slice(this.offset, this.offset + e);\n    return this.offset += e, t;\n  }\n  getString(e) {\n    let t = [];\n    for (let s = 0; s < e; s++)\n      t[s] = this.getUint8();\n    const n = t.indexOf(0);\n    return n >= 0 && (t = t.slice(0, n)), ns(new Uint8Array(t));\n  }\n}\nclass nl {\n  add(e, t) {\n    this[e] = t;\n  }\n}\nfunction yf(r) {\n  const e = \"Kaydara FBX Binary  \\0\";\n  return r.byteLength >= e.length && e === ol(r, 0, e.length);\n}\nfunction _f(r) {\n  const e = [\n    \"K\",\n    \"a\",\n    \"y\",\n    \"d\",\n    \"a\",\n    \"r\",\n    \"a\",\n    \"\\\\\",\n    \"F\",\n    \"B\",\n    \"X\",\n    \"\\\\\",\n    \"B\",\n    \"i\",\n    \"n\",\n    \"a\",\n    \"r\",\n    \"y\",\n    \"\\\\\",\n    \"\\\\\"\n  ];\n  let t = 0;\n  function n(s) {\n    const i = r[s - 1];\n    return r = r.slice(t + s), t++, i;\n  }\n  for (let s = 0; s < e.length; ++s)\n    if (n(1) === e[s])\n      return !1;\n  return !0;\n}\nfunction _r(r) {\n  const e = /FBXVersion: (\\d+)/, t = r.match(e);\n  if (t)\n    return parseInt(t[1]);\n  throw new Error(\"THREE.FBXLoader: Cannot find the version number for the file given.\");\n}\nfunction xf(r) {\n  return r / 46186158e3;\n}\nconst wf = [];\nfunction Gs(r, e, t, n) {\n  let s;\n  switch (n.mappingType) {\n    case \"ByPolygonVertex\":\n      s = r;\n      break;\n    case \"ByPolygon\":\n      s = e;\n      break;\n    case \"ByVertice\":\n      s = t;\n      break;\n    case \"AllSame\":\n      s = n.indices[0];\n      break;\n    default:\n      console.warn(\"THREE.FBXLoader: unknown attribute mapping type \" + n.mappingType);\n  }\n  n.referenceType === \"IndexToDirect\" && (s = n.indices[s]);\n  const i = s * n.dataSize, o = i + n.dataSize;\n  return bf(wf, n.buffer, i, o);\n}\nconst Oi = new vt(), Hn = new $();\nfunction sl(r) {\n  const e = new Ie(), t = new Ie(), n = new Ie(), s = new Ie(), i = new Ie(), o = new Ie(), a = new Ie(), l = new Ie(), c = new Ie(), f = new Ie(), u = new Ie(), d = new Ie(), h = r.inheritType ? r.inheritType : 0;\n  if (r.translation && e.setPosition(Hn.fromArray(r.translation)), r.preRotation) {\n    const y = r.preRotation.map(Ye.degToRad);\n    y.push(r.eulerOrder), t.makeRotationFromEuler(Oi.fromArray(y));\n  }\n  if (r.rotation) {\n    const y = r.rotation.map(Ye.degToRad);\n    y.push(r.eulerOrder), n.makeRotationFromEuler(Oi.fromArray(y));\n  }\n  if (r.postRotation) {\n    const y = r.postRotation.map(Ye.degToRad);\n    y.push(r.eulerOrder), s.makeRotationFromEuler(Oi.fromArray(y)), s.invert();\n  }\n  r.scale && i.scale(Hn.fromArray(r.scale)), r.scalingOffset && a.setPosition(Hn.fromArray(r.scalingOffset)), r.scalingPivot && o.setPosition(Hn.fromArray(r.scalingPivot)), r.rotationOffset && l.setPosition(Hn.fromArray(r.rotationOffset)), r.rotationPivot && c.setPosition(Hn.fromArray(r.rotationPivot)), r.parentMatrixWorld && (u.copy(r.parentMatrix), f.copy(r.parentMatrixWorld));\n  const m = t.clone().multiply(n).multiply(s), g = new Ie();\n  g.extractRotation(f);\n  const v = new Ie();\n  v.copyPosition(f);\n  const p = v.clone().invert().multiply(f), b = g.clone().invert().multiply(p), _ = i, M = new Ie();\n  if (h === 0)\n    M.copy(g).multiply(m).multiply(b).multiply(_);\n  else if (h === 1)\n    M.copy(g).multiply(b).multiply(m).multiply(_);\n  else {\n    const A = new Ie().scale(new $().setFromMatrixScale(u)).clone().invert(), C = b.clone().multiply(A);\n    M.copy(g).multiply(m).multiply(C).multiply(_);\n  }\n  const R = c.clone().invert(), w = o.clone().invert();\n  let E = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(R).multiply(a).multiply(o).multiply(i).multiply(w);\n  const x = new Ie().copyPosition(E), T = f.clone().multiply(x);\n  return d.copyPosition(T), E = d.clone().multiply(M), E.premultiply(f.invert()), E;\n}\nfunction il(r) {\n  r = r || 0;\n  const e = [\n    \"ZYX\",\n    // -> XYZ extrinsic\n    \"YZX\",\n    // -> XZY extrinsic\n    \"XZY\",\n    // -> YZX extrinsic\n    \"ZXY\",\n    // -> YXZ extrinsic\n    \"YXZ\",\n    // -> ZXY extrinsic\n    \"XYZ\"\n    // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ];\n  return r === 6 ? (console.warn(\"THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.\"), e[0]) : e[r];\n}\nfunction Di(r) {\n  return r.split(\",\").map(function(t) {\n    return parseFloat(t);\n  });\n}\nfunction ol(r, e, t) {\n  return e === void 0 && (e = 0), t === void 0 && (t = r.byteLength), ns(new Uint8Array(r, e, t));\n}\nfunction Tf(r, e) {\n  for (let t = 0, n = r.length, s = e.length; t < s; t++, n++)\n    r[n] = e[t];\n}\nfunction bf(r, e, t, n) {\n  for (let s = t, i = 0; s < n; s++, i++)\n    r[i] = e[s];\n  return r;\n}\nfunction xr(r, e, t) {\n  return r.slice(0, e).concat(t).concat(r.slice(e));\n}\nvar Ef = Object.defineProperty, Mf = (r, e, t) => e in r ? Ef(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, zo = (r, e, t) => (Mf(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nclass Sf extends Un {\n  constructor(e) {\n    super(e);\n  }\n  load(e, t, n, s) {\n    const i = new kn(this.manager);\n    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(\n      e,\n      (o) => {\n        if (typeof o != \"string\")\n          throw new Error(\"unsupported data type\");\n        const a = JSON.parse(o), l = this.parse(a);\n        t && t(l);\n      },\n      n,\n      s\n    );\n  }\n  loadAsync(e, t) {\n    return super.loadAsync(e, t);\n  }\n  parse(e) {\n    return new Go(e);\n  }\n}\nclass Go {\n  constructor(e) {\n    zo(this, \"data\"), this.data = e;\n  }\n  generateShapes(e, t = 100, n) {\n    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, o = Af(e, t, this.data, i);\n    for (let a = 0, l = o.length; a < l; a++)\n      Array.prototype.push.apply(s, o[a].toShapes(!1));\n    return s;\n  }\n}\nzo(Go, \"isFont\");\nzo(Go, \"type\");\nfunction Af(r, e, t, n) {\n  const s = Array.from(r), i = e / t.resolution, o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];\n  let l = 0, c = 0;\n  for (let f = 0; f < s.length; f++) {\n    const u = s[f];\n    if (u === `\n`)\n      l = 0, c -= o * n.lineHeight;\n    else {\n      const d = Pf(u, i, l, c, t);\n      d && (l += d.offsetX + n.letterSpacing, a.push(d.path));\n    }\n  }\n  return a;\n}\nfunction Pf(r, e, t, n, s) {\n  const i = s.glyphs[r] || s.glyphs[\"?\"];\n  if (!i) {\n    console.error('THREE.Font: character \"' + r + '\" does not exists in font family ' + s.familyName + \".\");\n    return;\n  }\n  const o = new pn();\n  let a, l, c, f, u, d, h, m;\n  if (i.o) {\n    const g = i._cachedOutline || (i._cachedOutline = i.o.split(\" \"));\n    for (let v = 0, p = g.length; v < p; )\n      switch (g[v++]) {\n        case \"m\":\n          a = parseInt(g[v++]) * e + t, l = parseInt(g[v++]) * e + n, o.moveTo(a, l);\n          break;\n        case \"l\":\n          a = parseInt(g[v++]) * e + t, l = parseInt(g[v++]) * e + n, o.lineTo(a, l);\n          break;\n        case \"q\":\n          c = parseInt(g[v++]) * e + t, f = parseInt(g[v++]) * e + n, u = parseInt(g[v++]) * e + t, d = parseInt(g[v++]) * e + n, o.quadraticCurveTo(u, d, c, f);\n          break;\n        case \"b\":\n          c = parseInt(g[v++]) * e + t, f = parseInt(g[v++]) * e + n, u = parseInt(g[v++]) * e + t, d = parseInt(g[v++]) * e + n, h = parseInt(g[v++]) * e + t, m = parseInt(g[v++]) * e + n, o.bezierCurveTo(u, d, h, m, c, f);\n          break;\n      }\n  }\n  return { offsetX: i.ha * e, path: o };\n}\nclass wr extends Yl {\n  constructor(e) {\n    super(e), this.type = Lt;\n  }\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse(e) {\n    const o = function(x, T) {\n      switch (x) {\n        case 1:\n          throw new Error(\"THREE.RGBELoader: Read Error: \" + (T || \"\"));\n        case 2:\n          throw new Error(\"THREE.RGBELoader: Write Error: \" + (T || \"\"));\n        case 3:\n          throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (T || \"\"));\n        default:\n        case 4:\n          throw new Error(\"THREE.RGBELoader: Memory Error: \" + (T || \"\"));\n      }\n    }, f = `\n`, u = function(x, T, y) {\n      T = T || 1024;\n      let C = x.pos, N = -1, U = 0, Y = \"\", V = String.fromCharCode.apply(null, new Uint16Array(x.subarray(C, C + 128)));\n      for (; 0 > (N = V.indexOf(f)) && U < T && C < x.byteLength; )\n        Y += V, U += V.length, C += 128, V += String.fromCharCode.apply(null, new Uint16Array(x.subarray(C, C + 128)));\n      return -1 < N ? (x.pos += U + N + 1, Y + V.slice(0, N)) : !1;\n    }, d = function(x) {\n      const T = /^#\\?(\\S+)/, y = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, A = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, C = /^\\s*FORMAT=(\\S+)\\s*$/, N = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, U = {\n        valid: 0,\n        string: \"\",\n        comments: \"\",\n        programtype: \"RGBE\",\n        format: \"\",\n        gamma: 1,\n        exposure: 1,\n        width: 0,\n        height: 0\n      };\n      let Y, V;\n      for ((x.pos >= x.byteLength || !(Y = u(x))) && o(1, \"no header found\"), (V = Y.match(T)) || o(3, \"bad initial token\"), U.valid |= 1, U.programtype = V[1], U.string += Y + `\n`; Y = u(x), Y !== !1; ) {\n        if (U.string += Y + `\n`, Y.charAt(0) === \"#\") {\n          U.comments += Y + `\n`;\n          continue;\n        }\n        if ((V = Y.match(y)) && (U.gamma = parseFloat(V[1])), (V = Y.match(A)) && (U.exposure = parseFloat(V[1])), (V = Y.match(C)) && (U.valid |= 2, U.format = V[1]), (V = Y.match(N)) && (U.valid |= 4, U.height = parseInt(V[1], 10), U.width = parseInt(V[2], 10)), U.valid & 2 && U.valid & 4)\n          break;\n      }\n      return U.valid & 2 || o(3, \"missing format specifier\"), U.valid & 4 || o(3, \"missing image size specifier\"), U;\n    }, h = function(x, T, y) {\n      const A = T;\n      if (\n        // run length encoding is not allowed so read flat\n        A < 8 || A > 32767 || // this file is not run length encoded\n        x[0] !== 2 || x[1] !== 2 || x[2] & 128\n      )\n        return new Uint8Array(x);\n      A !== (x[2] << 8 | x[3]) && o(3, \"wrong scanline width\");\n      const C = new Uint8Array(4 * T * y);\n      C.length || o(4, \"unable to allocate buffer space\");\n      let N = 0, U = 0;\n      const Y = 4 * A, V = new Uint8Array(4), ne = new Uint8Array(Y);\n      let Z = y;\n      for (; Z > 0 && U < x.byteLength; ) {\n        U + 4 > x.byteLength && o(1), V[0] = x[U++], V[1] = x[U++], V[2] = x[U++], V[3] = x[U++], (V[0] != 2 || V[1] != 2 || (V[2] << 8 | V[3]) != A) && o(3, \"bad rgbe scanline format\");\n        let ee = 0, te;\n        for (; ee < Y && U < x.byteLength; ) {\n          te = x[U++];\n          const he = te > 128;\n          if (he && (te -= 128), (te === 0 || ee + te > Y) && o(3, \"bad scanline data\"), he) {\n            const we = x[U++];\n            for (let I = 0; I < te; I++)\n              ne[ee++] = we;\n          } else\n            ne.set(x.subarray(U, U + te), ee), ee += te, U += te;\n        }\n        const fe = A;\n        for (let he = 0; he < fe; he++) {\n          let we = 0;\n          C[N] = ne[he + we], we += A, C[N + 1] = ne[he + we], we += A, C[N + 2] = ne[he + we], we += A, C[N + 3] = ne[he + we], N += 4;\n        }\n        Z--;\n      }\n      return C;\n    }, m = function(x, T, y, A) {\n      const C = x[T + 3], N = Math.pow(2, C - 128) / 255;\n      y[A + 0] = x[T + 0] * N, y[A + 1] = x[T + 1] * N, y[A + 2] = x[T + 2] * N, y[A + 3] = 1;\n    }, g = function(x, T, y, A) {\n      const C = x[T + 3], N = Math.pow(2, C - 128) / 255;\n      y[A + 0] = Ls.toHalfFloat(Math.min(x[T + 0] * N, 65504)), y[A + 1] = Ls.toHalfFloat(Math.min(x[T + 1] * N, 65504)), y[A + 2] = Ls.toHalfFloat(Math.min(x[T + 2] * N, 65504)), y[A + 3] = Ls.toHalfFloat(1);\n    }, v = new Uint8Array(e);\n    v.pos = 0;\n    const p = d(v), b = p.width, _ = p.height, M = h(v.subarray(v.pos), b, _);\n    let R, w, E;\n    switch (this.type) {\n      case qs:\n        E = M.length / 4;\n        const x = new Float32Array(E * 4);\n        for (let y = 0; y < E; y++)\n          m(M, y * 4, x, y * 4);\n        R = x, w = qs;\n        break;\n      case Lt:\n        E = M.length / 4;\n        const T = new Uint16Array(E * 4);\n        for (let y = 0; y < E; y++)\n          g(M, y * 4, T, y * 4);\n        R = T, w = Lt;\n        break;\n      default:\n        throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n    }\n    return {\n      width: b,\n      height: _,\n      data: R,\n      header: p.string,\n      gamma: p.gamma,\n      exposure: p.exposure,\n      type: w\n    };\n  }\n  setDataType(e) {\n    return this.type = e, this;\n  }\n  load(e, t, n, s) {\n    function i(o, a) {\n      switch (o.type) {\n        case qs:\n        case Lt:\n          \"colorSpace\" in o ? o.colorSpace = \"srgb-linear\" : o.encoding = 3e3, o.minFilter = wt, o.magFilter = wt, o.generateMipmaps = !1, o.flipY = !0;\n          break;\n      }\n      t && t(o, a);\n    }\n    return super.load(e, i, n, s);\n  }\n}\nconst Rf = \"srgb\";\nclass _s extends Un {\n  constructor(e) {\n    super(e), this.defaultDPI = 90, this.defaultUnit = \"px\";\n  }\n  load(e, t, n, s) {\n    const i = this, o = new kn(i.manager);\n    o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(\n      e,\n      function(a) {\n        try {\n          t(i.parse(a));\n        } catch (l) {\n          s ? s(l) : console.error(l), i.manager.itemError(e);\n        }\n      },\n      n,\n      s\n    );\n  }\n  parse(e) {\n    const t = this;\n    function n(I, B) {\n      if (I.nodeType !== 1)\n        return;\n      const D = M(I);\n      let O = !1, z = null;\n      switch (I.nodeName) {\n        case \"svg\":\n          B = m(I, B);\n          break;\n        case \"style\":\n          i(I);\n          break;\n        case \"g\":\n          B = m(I, B);\n          break;\n        case \"path\":\n          B = m(I, B), I.hasAttribute(\"d\") && (z = s(I));\n          break;\n        case \"rect\":\n          B = m(I, B), z = l(I);\n          break;\n        case \"polygon\":\n          B = m(I, B), z = c(I);\n          break;\n        case \"polyline\":\n          B = m(I, B), z = f(I);\n          break;\n        case \"circle\":\n          B = m(I, B), z = u(I);\n          break;\n        case \"ellipse\":\n          B = m(I, B), z = d(I);\n          break;\n        case \"line\":\n          B = m(I, B), z = h(I);\n          break;\n        case \"defs\":\n          O = !0;\n          break;\n        case \"use\":\n          B = m(I, B);\n          const L = (I.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\").substring(1), X = I.viewportElement.getElementById(L);\n          X ? n(X, B) : console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + L);\n          break;\n      }\n      z && (B.fill !== void 0 && B.fill !== \"none\" && z.color.setStyle(B.fill, Rf), w(z, fe), C.push(z), z.userData = { node: I, style: B });\n      const S = I.childNodes;\n      for (let P = 0; P < S.length; P++) {\n        const L = S[P];\n        O && L.nodeName !== \"style\" && L.nodeName !== \"defs\" || n(L, B);\n      }\n      D && (U.pop(), U.length > 0 ? fe.copy(U[U.length - 1]) : fe.identity());\n    }\n    function s(I) {\n      const B = new pn(), D = new ve(), O = new ve(), z = new ve();\n      let S = !0, P = !1;\n      const L = I.getAttribute(\"d\");\n      if (L === \"\" || L === \"none\")\n        return null;\n      const X = L.match(/[a-df-z][^a-df-z]*/gi);\n      for (let H = 0, j = X.length; H < j; H++) {\n        const K = X[H], se = K.charAt(0), ie = K.slice(1).trim();\n        S === !0 && (P = !0, S = !1);\n        let G;\n        switch (se) {\n          case \"M\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 2)\n              D.x = G[k + 0], D.y = G[k + 1], O.x = D.x, O.y = D.y, k === 0 ? B.moveTo(D.x, D.y) : B.lineTo(D.x, D.y), k === 0 && z.copy(D);\n            break;\n          case \"H\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k++)\n              D.x = G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"V\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k++)\n              D.y = G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"L\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 2)\n              D.x = G[k + 0], D.y = G[k + 1], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"C\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 6)\n              B.bezierCurveTo(\n                G[k + 0],\n                G[k + 1],\n                G[k + 2],\n                G[k + 3],\n                G[k + 4],\n                G[k + 5]\n              ), O.x = G[k + 2], O.y = G[k + 3], D.x = G[k + 4], D.y = G[k + 5], k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"S\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 4)\n              B.bezierCurveTo(\n                g(D.x, O.x),\n                g(D.y, O.y),\n                G[k + 0],\n                G[k + 1],\n                G[k + 2],\n                G[k + 3]\n              ), O.x = G[k + 0], O.y = G[k + 1], D.x = G[k + 2], D.y = G[k + 3], k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"Q\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 4)\n              B.quadraticCurveTo(G[k + 0], G[k + 1], G[k + 2], G[k + 3]), O.x = G[k + 0], O.y = G[k + 1], D.x = G[k + 2], D.y = G[k + 3], k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"T\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 2) {\n              const ge = g(D.x, O.x), Re = g(D.y, O.y);\n              B.quadraticCurveTo(ge, Re, G[k + 0], G[k + 1]), O.x = ge, O.y = Re, D.x = G[k + 0], D.y = G[k + 1], k === 0 && P === !0 && z.copy(D);\n            }\n            break;\n          case \"A\":\n            G = v(ie, [3, 4], 7);\n            for (let k = 0, oe = G.length; k < oe; k += 7) {\n              if (G[k + 5] == D.x && G[k + 6] == D.y)\n                continue;\n              const ge = D.clone();\n              D.x = G[k + 5], D.y = G[k + 6], O.x = D.x, O.y = D.y, o(\n                B,\n                G[k],\n                G[k + 1],\n                G[k + 2],\n                G[k + 3],\n                G[k + 4],\n                ge,\n                D\n              ), k === 0 && P === !0 && z.copy(D);\n            }\n            break;\n          case \"m\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 2)\n              D.x += G[k + 0], D.y += G[k + 1], O.x = D.x, O.y = D.y, k === 0 ? B.moveTo(D.x, D.y) : B.lineTo(D.x, D.y), k === 0 && z.copy(D);\n            break;\n          case \"h\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k++)\n              D.x += G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"v\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k++)\n              D.y += G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"l\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 2)\n              D.x += G[k + 0], D.y += G[k + 1], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"c\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 6)\n              B.bezierCurveTo(\n                D.x + G[k + 0],\n                D.y + G[k + 1],\n                D.x + G[k + 2],\n                D.y + G[k + 3],\n                D.x + G[k + 4],\n                D.y + G[k + 5]\n              ), O.x = D.x + G[k + 2], O.y = D.y + G[k + 3], D.x += G[k + 4], D.y += G[k + 5], k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"s\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 4)\n              B.bezierCurveTo(\n                g(D.x, O.x),\n                g(D.y, O.y),\n                D.x + G[k + 0],\n                D.y + G[k + 1],\n                D.x + G[k + 2],\n                D.y + G[k + 3]\n              ), O.x = D.x + G[k + 0], O.y = D.y + G[k + 1], D.x += G[k + 2], D.y += G[k + 3], k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"q\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 4)\n              B.quadraticCurveTo(\n                D.x + G[k + 0],\n                D.y + G[k + 1],\n                D.x + G[k + 2],\n                D.y + G[k + 3]\n              ), O.x = D.x + G[k + 0], O.y = D.y + G[k + 1], D.x += G[k + 2], D.y += G[k + 3], k === 0 && P === !0 && z.copy(D);\n            break;\n          case \"t\":\n            G = v(ie);\n            for (let k = 0, oe = G.length; k < oe; k += 2) {\n              const ge = g(D.x, O.x), Re = g(D.y, O.y);\n              B.quadraticCurveTo(ge, Re, D.x + G[k + 0], D.y + G[k + 1]), O.x = ge, O.y = Re, D.x = D.x + G[k + 0], D.y = D.y + G[k + 1], k === 0 && P === !0 && z.copy(D);\n            }\n            break;\n          case \"a\":\n            G = v(ie, [3, 4], 7);\n            for (let k = 0, oe = G.length; k < oe; k += 7) {\n              if (G[k + 5] == 0 && G[k + 6] == 0)\n                continue;\n              const ge = D.clone();\n              D.x += G[k + 5], D.y += G[k + 6], O.x = D.x, O.y = D.y, o(\n                B,\n                G[k],\n                G[k + 1],\n                G[k + 2],\n                G[k + 3],\n                G[k + 4],\n                ge,\n                D\n              ), k === 0 && P === !0 && z.copy(D);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            B.currentPath.autoClose = !0, B.currentPath.curves.length > 0 && (D.copy(z), B.currentPath.currentPoint.copy(D), S = !0);\n            break;\n          default:\n            console.warn(K);\n        }\n        P = !1;\n      }\n      return B;\n    }\n    function i(I) {\n      if (!(!I.sheet || !I.sheet.cssRules || !I.sheet.cssRules.length))\n        for (let B = 0; B < I.sheet.cssRules.length; B++) {\n          const D = I.sheet.cssRules[B];\n          if (D.type !== 1)\n            continue;\n          const O = D.selectorText.split(/,/gm).filter(Boolean).map((z) => z.trim());\n          for (let z = 0; z < O.length; z++) {\n            const S = Object.fromEntries(Object.entries(D.style).filter(([, P]) => P !== \"\"));\n            N[O[z]] = Object.assign(N[O[z]] || {}, S);\n          }\n        }\n    }\n    function o(I, B, D, O, z, S, P, L) {\n      if (B == 0 || D == 0) {\n        I.lineTo(L.x, L.y);\n        return;\n      }\n      O = O * Math.PI / 180, B = Math.abs(B), D = Math.abs(D);\n      const X = (P.x - L.x) / 2, H = (P.y - L.y) / 2, j = Math.cos(O) * X + Math.sin(O) * H, K = -Math.sin(O) * X + Math.cos(O) * H;\n      let se = B * B, ie = D * D;\n      const G = j * j, k = K * K, oe = G / se + k / ie;\n      if (oe > 1) {\n        const Bt = Math.sqrt(oe);\n        B = Bt * B, D = Bt * D, se = B * B, ie = D * D;\n      }\n      const ge = se * k + ie * G, Re = (se * ie - ge) / ge;\n      let Ke = Math.sqrt(Math.max(0, Re));\n      z === S && (Ke = -Ke);\n      const He = Ke * B * K / D, Et = -Ke * D * j / B, un = Math.cos(O) * He - Math.sin(O) * Et + (P.x + L.x) / 2, En = Math.sin(O) * He + Math.cos(O) * Et + (P.y + L.y) / 2, Nt = a(1, 0, (j - He) / B, (K - Et) / D), yt = a((j - He) / B, (K - Et) / D, (-j - He) / B, (-K - Et) / D) % (Math.PI * 2);\n      I.currentPath.absellipse(un, En, B, D, Nt, Nt + yt, S === 0, O);\n    }\n    function a(I, B, D, O) {\n      const z = I * D + B * O, S = Math.sqrt(I * I + B * B) * Math.sqrt(D * D + O * O);\n      let P = Math.acos(Math.max(-1, Math.min(1, z / S)));\n      return I * O - B * D < 0 && (P = -P), P;\n    }\n    function l(I) {\n      const B = _(I.getAttribute(\"x\") || 0), D = _(I.getAttribute(\"y\") || 0), O = _(I.getAttribute(\"rx\") || I.getAttribute(\"ry\") || 0), z = _(I.getAttribute(\"ry\") || I.getAttribute(\"rx\") || 0), S = _(I.getAttribute(\"width\")), P = _(I.getAttribute(\"height\")), L = 1 - 0.551915024494, X = new pn();\n      return X.moveTo(B + O, D), X.lineTo(B + S - O, D), (O !== 0 || z !== 0) && X.bezierCurveTo(B + S - O * L, D, B + S, D + z * L, B + S, D + z), X.lineTo(B + S, D + P - z), (O !== 0 || z !== 0) && X.bezierCurveTo(B + S, D + P - z * L, B + S - O * L, D + P, B + S - O, D + P), X.lineTo(B + O, D + P), (O !== 0 || z !== 0) && X.bezierCurveTo(B + O * L, D + P, B, D + P - z * L, B, D + P - z), X.lineTo(B, D + z), (O !== 0 || z !== 0) && X.bezierCurveTo(B, D + z * L, B + O * L, D, B + O, D), X;\n    }\n    function c(I) {\n      function B(S, P, L) {\n        const X = _(P), H = _(L);\n        z === 0 ? O.moveTo(X, H) : O.lineTo(X, H), z++;\n      }\n      const D = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g, O = new pn();\n      let z = 0;\n      return I.getAttribute(\"points\").replace(D, B), O.currentPath.autoClose = !0, O;\n    }\n    function f(I) {\n      function B(S, P, L) {\n        const X = _(P), H = _(L);\n        z === 0 ? O.moveTo(X, H) : O.lineTo(X, H), z++;\n      }\n      const D = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g, O = new pn();\n      let z = 0;\n      return I.getAttribute(\"points\").replace(D, B), O.currentPath.autoClose = !1, O;\n    }\n    function u(I) {\n      const B = _(I.getAttribute(\"cx\") || 0), D = _(I.getAttribute(\"cy\") || 0), O = _(I.getAttribute(\"r\") || 0), z = new _i();\n      z.absarc(B, D, O, 0, Math.PI * 2);\n      const S = new pn();\n      return S.subPaths.push(z), S;\n    }\n    function d(I) {\n      const B = _(I.getAttribute(\"cx\") || 0), D = _(I.getAttribute(\"cy\") || 0), O = _(I.getAttribute(\"rx\") || 0), z = _(I.getAttribute(\"ry\") || 0), S = new _i();\n      S.absellipse(B, D, O, z, 0, Math.PI * 2);\n      const P = new pn();\n      return P.subPaths.push(S), P;\n    }\n    function h(I) {\n      const B = _(I.getAttribute(\"x1\") || 0), D = _(I.getAttribute(\"y1\") || 0), O = _(I.getAttribute(\"x2\") || 0), z = _(I.getAttribute(\"y2\") || 0), S = new pn();\n      return S.moveTo(B, D), S.lineTo(O, z), S.currentPath.autoClose = !1, S;\n    }\n    function m(I, B) {\n      B = Object.assign({}, B);\n      let D = {};\n      if (I.hasAttribute(\"class\")) {\n        const P = I.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((L) => L.trim());\n        for (let L = 0; L < P.length; L++)\n          D = Object.assign(D, N[\".\" + P[L]]);\n      }\n      I.hasAttribute(\"id\") && (D = Object.assign(D, N[\"#\" + I.getAttribute(\"id\")]));\n      function O(P, L, X) {\n        X === void 0 && (X = function(j) {\n          return j.startsWith(\"url\") && console.warn(\"SVGLoader: url access in attributes is not implemented.\"), j;\n        }), I.hasAttribute(P) && (B[L] = X(I.getAttribute(P))), D[P] && (B[L] = X(D[P])), I.style && I.style[P] !== \"\" && (B[L] = X(I.style[P]));\n      }\n      function z(P) {\n        return Math.max(0, Math.min(1, _(P)));\n      }\n      function S(P) {\n        return Math.max(0, _(P));\n      }\n      return O(\"fill\", \"fill\"), O(\"fill-opacity\", \"fillOpacity\", z), O(\"fill-rule\", \"fillRule\"), O(\"opacity\", \"opacity\", z), O(\"stroke\", \"stroke\"), O(\"stroke-opacity\", \"strokeOpacity\", z), O(\"stroke-width\", \"strokeWidth\", S), O(\"stroke-linejoin\", \"strokeLineJoin\"), O(\"stroke-linecap\", \"strokeLineCap\"), O(\"stroke-miterlimit\", \"strokeMiterLimit\", S), O(\"visibility\", \"visibility\"), B;\n    }\n    function g(I, B) {\n      return I - (B - I);\n    }\n    function v(I, B, D) {\n      if (typeof I != \"string\")\n        throw new TypeError(\"Invalid input: \" + typeof I);\n      const O = {\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      }, z = 0, S = 1, P = 2, L = 3;\n      let X = z, H = !0, j = \"\", K = \"\";\n      const se = [];\n      function ie(ge, Re, Ke) {\n        const He = new SyntaxError('Unexpected character \"' + ge + '\" at index ' + Re + \".\");\n        throw He.partial = Ke, He;\n      }\n      function G() {\n        j !== \"\" && (K === \"\" ? se.push(Number(j)) : se.push(Number(j) * Math.pow(10, Number(K)))), j = \"\", K = \"\";\n      }\n      let k;\n      const oe = I.length;\n      for (let ge = 0; ge < oe; ge++) {\n        if (k = I[ge], Array.isArray(B) && B.includes(se.length % D) && O.FLAGS.test(k)) {\n          X = S, j = k, G();\n          continue;\n        }\n        if (X === z) {\n          if (O.WHITESPACE.test(k))\n            continue;\n          if (O.DIGIT.test(k) || O.SIGN.test(k)) {\n            X = S, j = k;\n            continue;\n          }\n          if (O.POINT.test(k)) {\n            X = P, j = k;\n            continue;\n          }\n          O.COMMA.test(k) && (H && ie(k, ge, se), H = !0);\n        }\n        if (X === S) {\n          if (O.DIGIT.test(k)) {\n            j += k;\n            continue;\n          }\n          if (O.POINT.test(k)) {\n            j += k, X = P;\n            continue;\n          }\n          if (O.EXP.test(k)) {\n            X = L;\n            continue;\n          }\n          O.SIGN.test(k) && j.length === 1 && O.SIGN.test(j[0]) && ie(k, ge, se);\n        }\n        if (X === P) {\n          if (O.DIGIT.test(k)) {\n            j += k;\n            continue;\n          }\n          if (O.EXP.test(k)) {\n            X = L;\n            continue;\n          }\n          O.POINT.test(k) && j[j.length - 1] === \".\" && ie(k, ge, se);\n        }\n        if (X === L) {\n          if (O.DIGIT.test(k)) {\n            K += k;\n            continue;\n          }\n          if (O.SIGN.test(k)) {\n            if (K === \"\") {\n              K += k;\n              continue;\n            }\n            K.length === 1 && O.SIGN.test(K) && ie(k, ge, se);\n          }\n        }\n        O.WHITESPACE.test(k) ? (G(), X = z, H = !1) : O.COMMA.test(k) ? (G(), X = z, H = !0) : O.SIGN.test(k) ? (G(), X = S, j = k) : O.POINT.test(k) ? (G(), X = P, j = k) : ie(k, ge, se);\n      }\n      return G(), se;\n    }\n    const p = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"], b = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function _(I) {\n      let B = \"px\";\n      if (typeof I == \"string\" || I instanceof String)\n        for (let O = 0, z = p.length; O < z; O++) {\n          const S = p[O];\n          if (I.endsWith(S)) {\n            B = S, I = I.substring(0, I.length - S.length);\n            break;\n          }\n        }\n      let D;\n      return B === \"px\" && t.defaultUnit !== \"px\" ? D = b.in[t.defaultUnit] / t.defaultDPI : (D = b[B][t.defaultUnit], D < 0 && (D = b[B].in * t.defaultDPI)), D * parseFloat(I);\n    }\n    function M(I) {\n      if (!(I.hasAttribute(\"transform\") || I.nodeName === \"use\" && (I.hasAttribute(\"x\") || I.hasAttribute(\"y\"))))\n        return null;\n      const B = R(I);\n      return U.length > 0 && B.premultiply(U[U.length - 1]), fe.copy(B), U.push(B), B;\n    }\n    function R(I) {\n      const B = new Cn(), D = Y;\n      if (I.nodeName === \"use\" && (I.hasAttribute(\"x\") || I.hasAttribute(\"y\"))) {\n        const O = _(I.getAttribute(\"x\")), z = _(I.getAttribute(\"y\"));\n        B.translate(O, z);\n      }\n      if (I.hasAttribute(\"transform\")) {\n        const O = I.getAttribute(\"transform\").split(\")\");\n        for (let z = O.length - 1; z >= 0; z--) {\n          const S = O[z].trim();\n          if (S === \"\")\n            continue;\n          const P = S.indexOf(\"(\"), L = S.length;\n          if (P > 0 && P < L) {\n            const X = S.slice(0, P), H = v(S.slice(P + 1));\n            switch (D.identity(), X) {\n              case \"translate\":\n                if (H.length >= 1) {\n                  const j = H[0];\n                  let K = 0;\n                  H.length >= 2 && (K = H[1]), D.translate(j, K);\n                }\n                break;\n              case \"rotate\":\n                if (H.length >= 1) {\n                  let j = 0, K = 0, se = 0;\n                  j = H[0] * Math.PI / 180, H.length >= 3 && (K = H[1], se = H[2]), V.makeTranslation(-K, -se), ne.makeRotation(j), Z.multiplyMatrices(ne, V), V.makeTranslation(K, se), D.multiplyMatrices(V, Z);\n                }\n                break;\n              case \"scale\":\n                if (H.length >= 1) {\n                  const j = H[0];\n                  let K = j;\n                  H.length >= 2 && (K = H[1]), D.scale(j, K);\n                }\n                break;\n              case \"skewX\":\n                H.length === 1 && D.set(1, Math.tan(H[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                break;\n              case \"skewY\":\n                H.length === 1 && D.set(1, 0, 0, Math.tan(H[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                break;\n              case \"matrix\":\n                H.length === 6 && D.set(H[0], H[2], H[4], H[1], H[3], H[5], 0, 0, 1);\n                break;\n            }\n          }\n          B.premultiply(D);\n        }\n      }\n      return B;\n    }\n    function w(I, B) {\n      function D(P) {\n        te.set(P.x, P.y, 1).applyMatrix3(B), P.set(te.x, te.y);\n      }\n      function O(P) {\n        const L = P.xRadius, X = P.yRadius, H = Math.cos(P.aRotation), j = Math.sin(P.aRotation), K = new $(L * H, L * j, 0), se = new $(-X * j, X * H, 0), ie = K.applyMatrix3(B), G = se.applyMatrix3(B), k = Y.set(ie.x, G.x, 0, ie.y, G.y, 0, 0, 0, 1), oe = V.copy(k).invert(), Ke = ne.copy(oe).transpose().multiply(oe).elements, He = A(Ke[0], Ke[1], Ke[4]), Et = Math.sqrt(He.rt1), un = Math.sqrt(He.rt2);\n        if (P.xRadius = 1 / Et, P.yRadius = 1 / un, P.aRotation = Math.atan2(He.sn, He.cs), !((P.aEndAngle - P.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {\n          const Nt = V.set(Et, 0, 0, 0, un, 0, 0, 0, 1), yt = ne.set(He.cs, He.sn, 0, -He.sn, He.cs, 0, 0, 0, 1), Bt = Nt.multiply(yt).multiply(k), is = (Cs) => {\n            const { x: di, y: Is } = new $(Math.cos(Cs), Math.sin(Cs), 0).applyMatrix3(Bt);\n            return Math.atan2(Is, di);\n          };\n          P.aStartAngle = is(P.aStartAngle), P.aEndAngle = is(P.aEndAngle), E(B) && (P.aClockwise = !P.aClockwise);\n        }\n      }\n      function z(P) {\n        const L = T(B), X = y(B);\n        P.xRadius *= L, P.yRadius *= X;\n        const H = L > Number.EPSILON ? Math.atan2(B.elements[1], B.elements[0]) : Math.atan2(-B.elements[3], B.elements[4]);\n        P.aRotation += H, E(B) && (P.aStartAngle *= -1, P.aEndAngle *= -1, P.aClockwise = !P.aClockwise);\n      }\n      const S = I.subPaths;\n      for (let P = 0, L = S.length; P < L; P++) {\n        const H = S[P].curves;\n        for (let j = 0; j < H.length; j++) {\n          const K = H[j];\n          K.isLineCurve ? (D(K.v1), D(K.v2)) : K.isCubicBezierCurve ? (D(K.v0), D(K.v1), D(K.v2), D(K.v3)) : K.isQuadraticBezierCurve ? (D(K.v0), D(K.v1), D(K.v2)) : K.isEllipseCurve && (ee.set(K.aX, K.aY), D(ee), K.aX = ee.x, K.aY = ee.y, x(B) ? O(K) : z(K));\n        }\n      }\n    }\n    function E(I) {\n      const B = I.elements;\n      return B[0] * B[4] - B[1] * B[3] < 0;\n    }\n    function x(I) {\n      const B = I.elements, D = B[0] * B[3] + B[1] * B[4];\n      if (D === 0)\n        return !1;\n      const O = T(I), z = y(I);\n      return Math.abs(D / (O * z)) > Number.EPSILON;\n    }\n    function T(I) {\n      const B = I.elements;\n      return Math.sqrt(B[0] * B[0] + B[1] * B[1]);\n    }\n    function y(I) {\n      const B = I.elements;\n      return Math.sqrt(B[3] * B[3] + B[4] * B[4]);\n    }\n    function A(I, B, D) {\n      let O, z, S, P, L;\n      const X = I + D, H = I - D, j = Math.sqrt(H * H + 4 * B * B);\n      return X > 0 ? (O = 0.5 * (X + j), L = 1 / O, z = I * L * D - B * L * B) : X < 0 ? z = 0.5 * (X - j) : (O = 0.5 * j, z = -0.5 * j), H > 0 ? S = H + j : S = H - j, Math.abs(S) > 2 * Math.abs(B) ? (L = -2 * B / S, P = 1 / Math.sqrt(1 + L * L), S = L * P) : Math.abs(B) === 0 ? (S = 1, P = 0) : (L = -0.5 * S / B, S = 1 / Math.sqrt(1 + L * L), P = L * S), H > 0 && (L = S, S = -P, P = L), { rt1: O, rt2: z, cs: S, sn: P };\n    }\n    const C = [], N = {}, U = [], Y = new Cn(), V = new Cn(), ne = new Cn(), Z = new Cn(), ee = new ve(), te = new $(), fe = new Cn(), he = new DOMParser().parseFromString(e, \"image/svg+xml\");\n    return n(he.documentElement, {\n      fill: \"#000\",\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4\n    }), { paths: C, xml: he.documentElement };\n  }\n  static createShapes(e) {\n    const n = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    }, s = {\n      loc: n.ORIGIN,\n      t: 0\n    };\n    function i(g, v, p, b) {\n      const _ = g.x, M = v.x, R = p.x, w = b.x, E = g.y, x = v.y, T = p.y, y = b.y, A = (w - R) * (E - T) - (y - T) * (_ - R), C = (M - _) * (E - T) - (x - E) * (_ - R), N = (y - T) * (M - _) - (w - R) * (x - E), U = A / N, Y = C / N;\n      if (N === 0 && A !== 0 || U <= 0 || U >= 1 || Y < 0 || Y > 1)\n        return null;\n      if (A === 0 && N === 0) {\n        for (let V = 0; V < 2; V++)\n          if (o(V === 0 ? p : b, g, v), s.loc == n.ORIGIN) {\n            const ne = V === 0 ? p : b;\n            return { x: ne.x, y: ne.y, t: s.t };\n          } else if (s.loc == n.BETWEEN) {\n            const ne = +(_ + s.t * (M - _)).toPrecision(10), Z = +(E + s.t * (x - E)).toPrecision(10);\n            return { x: ne, y: Z, t: s.t };\n          }\n        return null;\n      } else {\n        for (let Z = 0; Z < 2; Z++)\n          if (o(Z === 0 ? p : b, g, v), s.loc == n.ORIGIN) {\n            const ee = Z === 0 ? p : b;\n            return { x: ee.x, y: ee.y, t: s.t };\n          }\n        const V = +(_ + U * (M - _)).toPrecision(10), ne = +(E + U * (x - E)).toPrecision(10);\n        return { x: V, y: ne, t: U };\n      }\n    }\n    function o(g, v, p) {\n      const b = p.x - v.x, _ = p.y - v.y, M = g.x - v.x, R = g.y - v.y, w = b * R - M * _;\n      if (g.x === v.x && g.y === v.y) {\n        s.loc = n.ORIGIN, s.t = 0;\n        return;\n      }\n      if (g.x === p.x && g.y === p.y) {\n        s.loc = n.DESTINATION, s.t = 1;\n        return;\n      }\n      if (w < -Number.EPSILON) {\n        s.loc = n.LEFT;\n        return;\n      }\n      if (w > Number.EPSILON) {\n        s.loc = n.RIGHT;\n        return;\n      }\n      if (b * M < 0 || _ * R < 0) {\n        s.loc = n.BEHIND;\n        return;\n      }\n      if (Math.sqrt(b * b + _ * _) < Math.sqrt(M * M + R * R)) {\n        s.loc = n.BEYOND;\n        return;\n      }\n      let E;\n      b !== 0 ? E = M / b : E = R / _, s.loc = n.BETWEEN, s.t = E;\n    }\n    function a(g, v) {\n      const p = [], b = [];\n      for (let _ = 1; _ < g.length; _++) {\n        const M = g[_ - 1], R = g[_];\n        for (let w = 1; w < v.length; w++) {\n          const E = v[w - 1], x = v[w], T = i(M, R, E, x);\n          T !== null && p.find(\n            (y) => y.t <= T.t + Number.EPSILON && y.t >= T.t - Number.EPSILON\n          ) === void 0 && (p.push(T), b.push(new ve(T.x, T.y)));\n        }\n      }\n      return b;\n    }\n    function l(g, v, p) {\n      const b = new ve();\n      v.getCenter(b);\n      const _ = [];\n      return p.forEach((M) => {\n        M.boundingBox.containsPoint(b) && a(g, M.points).forEach((w) => {\n          _.push({ identifier: M.identifier, isCW: M.isCW, point: w });\n        });\n      }), _.sort((M, R) => M.point.x - R.point.x), _;\n    }\n    function c(g, v, p, b, _) {\n      (_ == null || _ === \"\") && (_ = \"nonzero\");\n      const M = new ve();\n      g.boundingBox.getCenter(M);\n      const R = [new ve(p, M.y), new ve(b, M.y)], w = l(R, g.boundingBox, v);\n      w.sort((C, N) => C.point.x - N.point.x);\n      const E = [], x = [];\n      w.forEach((C) => {\n        C.identifier === g.identifier ? E.push(C) : x.push(C);\n      });\n      const T = E[0].point.x, y = [];\n      let A = 0;\n      for (; A < x.length && x[A].point.x < T; )\n        y.length > 0 && y[y.length - 1] === x[A].identifier ? y.pop() : y.push(x[A].identifier), A++;\n      if (y.push(g.identifier), _ === \"evenodd\") {\n        const C = y.length % 2 === 0, N = y[y.length - 2];\n        return { identifier: g.identifier, isHole: C, for: N };\n      } else if (_ === \"nonzero\") {\n        let C = !0, N = null, U = null;\n        for (let Y = 0; Y < y.length; Y++) {\n          const V = y[Y];\n          C ? (U = v[V].isCW, C = !1, N = V) : U !== v[V].isCW && (U = v[V].isCW, C = !0);\n        }\n        return { identifier: g.identifier, isHole: C, for: N };\n      } else\n        console.warn('fill-rule: \"' + _ + '\" is currently not implemented.');\n    }\n    let f = 999999999, u = -999999999, d = e.subPaths.map((g) => {\n      const v = g.getPoints();\n      let p = -999999999, b = 999999999, _ = -999999999, M = 999999999;\n      for (let R = 0; R < v.length; R++) {\n        const w = v[R];\n        w.y > p && (p = w.y), w.y < b && (b = w.y), w.x > _ && (_ = w.x), w.x < M && (M = w.x);\n      }\n      return u <= _ && (u = _ + 1), f >= M && (f = M - 1), {\n        curves: g.curves,\n        points: v,\n        isCW: Wl.isClockWise(v),\n        identifier: -1,\n        boundingBox: new va(new ve(M, b), new ve(_, p))\n      };\n    });\n    d = d.filter((g) => g.points.length > 1);\n    for (let g = 0; g < d.length; g++)\n      d[g].identifier = g;\n    const h = d.map(\n      (g) => c(\n        g,\n        d,\n        f,\n        u,\n        e.userData ? e.userData.style.fillRule : void 0\n      )\n    ), m = [];\n    return d.forEach((g) => {\n      if (!h[g.identifier].isHole) {\n        const p = new Xl();\n        p.curves = g.curves, h.filter((_) => _.isHole && _.for === g.identifier).forEach((_) => {\n          const M = d[_.identifier], R = new _i();\n          R.curves = M.curves, p.holes.push(R);\n        }), m.push(p);\n      }\n    }), m;\n  }\n  static getStrokeStyle(e, t, n, s, i) {\n    return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : \"#000\", n = n !== void 0 ? n : \"miter\", s = s !== void 0 ? s : \"butt\", i = i !== void 0 ? i : 4, {\n      strokeColor: t,\n      strokeWidth: e,\n      strokeLineJoin: n,\n      strokeLineCap: s,\n      strokeMiterLimit: i\n    };\n  }\n  static pointsToStroke(e, t, n, s) {\n    const i = [], o = [], a = [];\n    if (_s.pointsToStrokeWithBuffers(e, t, n, s, i, o, a) === 0)\n      return null;\n    const l = new ht();\n    return l.setAttribute(\"position\", new gt(i, 3)), l.setAttribute(\"normal\", new gt(o, 3)), l.setAttribute(\"uv\", new gt(a, 2)), l;\n  }\n  static pointsToStrokeWithBuffers(e, t, n, s, i, o, a, l) {\n    const c = new ve(), f = new ve(), u = new ve(), d = new ve(), h = new ve(), m = new ve(), g = new ve(), v = new ve(), p = new ve(), b = new ve(), _ = new ve(), M = new ve(), R = new ve(), w = new ve(), E = new ve(), x = new ve(), T = new ve();\n    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = H(e);\n    const y = e.length;\n    if (y < 2)\n      return 0;\n    const A = e[0].equals(e[y - 1]);\n    let C, N = e[0], U;\n    const Y = t.strokeWidth / 2, V = 1 / (y - 1);\n    let ne = 0, Z, ee, te, fe, he = !1, we = 0, I = l * 3, B = l * 2;\n    D(e[0], e[1], c).multiplyScalar(Y), v.copy(e[0]).sub(c), p.copy(e[0]).add(c), b.copy(v), _.copy(p);\n    for (let j = 1; j < y; j++) {\n      C = e[j], j === y - 1 ? A ? U = e[1] : U = void 0 : U = e[j + 1];\n      const K = c;\n      if (D(N, C, K), u.copy(K).multiplyScalar(Y), M.copy(C).sub(u), R.copy(C).add(u), Z = ne + V, ee = !1, U !== void 0) {\n        D(C, U, f), u.copy(f).multiplyScalar(Y), w.copy(C).sub(u), E.copy(C).add(u), te = !0, u.subVectors(U, N), K.dot(u) < 0 && (te = !1), j === 1 && (he = te), u.subVectors(U, C), u.normalize();\n        const se = Math.abs(K.dot(u));\n        if (se > Number.EPSILON) {\n          const ie = Y / se;\n          u.multiplyScalar(-ie), d.subVectors(C, N), h.copy(d).setLength(ie).add(u), x.copy(h).negate();\n          const G = h.length(), k = d.length();\n          d.divideScalar(k), m.subVectors(U, C);\n          const oe = m.length();\n          switch (m.divideScalar(oe), d.dot(x) < k && m.dot(x) < oe && (ee = !0), T.copy(h).add(C), x.add(C), fe = !1, ee ? te ? (E.copy(x), R.copy(x)) : (w.copy(x), M.copy(x)) : S(), t.strokeLineJoin) {\n            case \"bevel\":\n              P(te, ee, Z);\n              break;\n            case \"round\":\n              L(te, ee), te ? z(C, M, w, Z, 0) : z(C, E, R, Z, 1);\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const ge = Y * t.strokeMiterLimit / G;\n              if (ge < 1)\n                if (t.strokeLineJoin !== \"miter-clip\") {\n                  P(te, ee, Z);\n                  break;\n                } else\n                  L(te, ee), te ? (m.subVectors(T, M).multiplyScalar(ge).add(M), g.subVectors(T, w).multiplyScalar(ge).add(w), O(M, Z, 0), O(m, Z, 0), O(C, Z, 0.5), O(C, Z, 0.5), O(m, Z, 0), O(g, Z, 0), O(C, Z, 0.5), O(g, Z, 0), O(w, Z, 0)) : (m.subVectors(T, R).multiplyScalar(ge).add(R), g.subVectors(T, E).multiplyScalar(ge).add(E), O(R, Z, 1), O(m, Z, 1), O(C, Z, 0.5), O(C, Z, 0.5), O(m, Z, 1), O(g, Z, 1), O(C, Z, 0.5), O(g, Z, 1), O(E, Z, 1));\n              else\n                ee ? (te ? (O(p, ne, 1), O(v, ne, 0), O(T, Z, 0), O(p, ne, 1), O(T, Z, 0), O(x, Z, 1)) : (O(p, ne, 1), O(v, ne, 0), O(T, Z, 1), O(v, ne, 0), O(x, Z, 0), O(T, Z, 1)), te ? w.copy(T) : E.copy(T)) : te ? (O(M, Z, 0), O(T, Z, 0), O(C, Z, 0.5), O(C, Z, 0.5), O(T, Z, 0), O(w, Z, 0)) : (O(R, Z, 1), O(T, Z, 1), O(C, Z, 0.5), O(C, Z, 0.5), O(T, Z, 1), O(E, Z, 1)), fe = !0;\n              break;\n          }\n        } else\n          S();\n      } else\n        S();\n      !A && j === y - 1 && X(e[0], b, _, te, !0, ne), ne = Z, N = C, v.copy(w), p.copy(E);\n    }\n    if (!A)\n      X(C, M, R, te, !1, Z);\n    else if (ee && i) {\n      let j = T, K = x;\n      he !== te && (j = x, K = T), te ? (fe || he) && (K.toArray(i, 0 * 3), K.toArray(i, 3 * 3), fe && j.toArray(i, 1 * 3)) : (fe || !he) && (K.toArray(i, 1 * 3), K.toArray(i, 3 * 3), fe && j.toArray(i, 0 * 3));\n    }\n    return we;\n    function D(j, K, se) {\n      return se.subVectors(K, j), se.set(-se.y, se.x).normalize();\n    }\n    function O(j, K, se) {\n      i && (i[I] = j.x, i[I + 1] = j.y, i[I + 2] = 0, o && (o[I] = 0, o[I + 1] = 0, o[I + 2] = 1), I += 3, a && (a[B] = K, a[B + 1] = se, B += 2)), we += 3;\n    }\n    function z(j, K, se, ie, G) {\n      c.copy(K).sub(j).normalize(), f.copy(se).sub(j).normalize();\n      let k = Math.PI;\n      const oe = c.dot(f);\n      Math.abs(oe) < 1 && (k = Math.abs(Math.acos(oe))), k /= n, u.copy(K);\n      for (let ge = 0, Re = n - 1; ge < Re; ge++)\n        d.copy(u).rotateAround(j, k), O(u, ie, G), O(d, ie, G), O(j, ie, 0.5), u.copy(d);\n      O(d, ie, G), O(se, ie, G), O(j, ie, 0.5);\n    }\n    function S() {\n      O(p, ne, 1), O(v, ne, 0), O(M, Z, 0), O(p, ne, 1), O(M, Z, 0), O(R, Z, 1);\n    }\n    function P(j, K, se) {\n      K ? j ? (O(p, ne, 1), O(v, ne, 0), O(M, Z, 0), O(p, ne, 1), O(M, Z, 0), O(x, Z, 1), O(M, se, 0), O(w, se, 0), O(x, se, 0.5)) : (O(p, ne, 1), O(v, ne, 0), O(R, Z, 1), O(v, ne, 0), O(x, Z, 0), O(R, Z, 1), O(R, se, 1), O(x, se, 0), O(E, se, 1)) : j ? (O(M, se, 0), O(w, se, 0), O(C, se, 0.5)) : (O(R, se, 1), O(E, se, 0), O(C, se, 0.5));\n    }\n    function L(j, K) {\n      K && (j ? (O(p, ne, 1), O(v, ne, 0), O(M, Z, 0), O(p, ne, 1), O(M, Z, 0), O(x, Z, 1), O(M, ne, 0), O(C, Z, 0.5), O(x, Z, 1), O(C, Z, 0.5), O(w, ne, 0), O(x, Z, 1)) : (O(p, ne, 1), O(v, ne, 0), O(R, Z, 1), O(v, ne, 0), O(x, Z, 0), O(R, Z, 1), O(R, ne, 1), O(x, Z, 0), O(C, Z, 0.5), O(C, Z, 0.5), O(x, Z, 0), O(E, ne, 1)));\n    }\n    function X(j, K, se, ie, G, k) {\n      switch (t.strokeLineCap) {\n        case \"round\":\n          G ? z(j, se, K, k, 0.5) : z(j, K, se, k, 0.5);\n          break;\n        case \"square\":\n          if (G)\n            c.subVectors(K, j), f.set(c.y, -c.x), u.addVectors(c, f).add(j), d.subVectors(f, c).add(j), ie ? (u.toArray(i, 1 * 3), d.toArray(i, 0 * 3), d.toArray(i, 3 * 3)) : (u.toArray(i, 1 * 3), a[3 * 2 + 1] === 1 ? d.toArray(i, 3 * 3) : u.toArray(i, 3 * 3), d.toArray(i, 0 * 3));\n          else {\n            c.subVectors(se, j), f.set(c.y, -c.x), u.addVectors(c, f).add(j), d.subVectors(f, c).add(j);\n            const oe = i.length;\n            ie ? (u.toArray(i, oe - 1 * 3), d.toArray(i, oe - 2 * 3), d.toArray(i, oe - 4 * 3)) : (d.toArray(i, oe - 2 * 3), u.toArray(i, oe - 1 * 3), d.toArray(i, oe - 4 * 3));\n          }\n          break;\n      }\n    }\n    function H(j) {\n      let K = !1;\n      for (let ie = 1, G = j.length - 1; ie < G; ie++)\n        if (j[ie].distanceTo(j[ie + 1]) < s) {\n          K = !0;\n          break;\n        }\n      if (!K)\n        return j;\n      const se = [];\n      se.push(j[0]);\n      for (let ie = 1, G = j.length - 1; ie < G; ie++)\n        j[ie].distanceTo(j[ie + 1]) >= s && se.push(j[ie]);\n      return se.push(j[j.length - 1]), se;\n    }\n  }\n}\nconst Li = /* @__PURE__ */ new WeakMap();\nclass Cf extends Un {\n  constructor(e) {\n    super(e), this.decoderPath = \"\", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = \"\", this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    }, this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(e) {\n    return this.decoderPath = e, this;\n  }\n  setDecoderConfig(e) {\n    return this.decoderConfig = e, this;\n  }\n  setWorkerLimit(e) {\n    return this.workerLimit = e, this;\n  }\n  load(e, t, n, s) {\n    const i = new kn(this.manager);\n    i.setPath(this.path), i.setResponseType(\"arraybuffer\"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(\n      e,\n      (o) => {\n        const a = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: !1\n        };\n        this.decodeGeometry(o, a).then(t).catch(s);\n      },\n      n,\n      s\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(e, t, n, s) {\n    const i = {\n      attributeIDs: n || this.defaultAttributeIDs,\n      attributeTypes: s || this.defaultAttributeTypes,\n      useUniqueIDs: !!n\n    };\n    this.decodeGeometry(e, i).then(t);\n  }\n  decodeGeometry(e, t) {\n    for (const l in t.attributeTypes) {\n      const c = t.attributeTypes[l];\n      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);\n    }\n    const n = JSON.stringify(t);\n    if (Li.has(e)) {\n      const l = Li.get(e);\n      if (l.key === n)\n        return l.promise;\n      if (e.byteLength === 0)\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n    }\n    let s;\n    const i = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(i, o).then((l) => (s = l, new Promise((c, f) => {\n      s._callbacks[i] = { resolve: c, reject: f }, s.postMessage({ type: \"decode\", id: i, taskConfig: t, buffer: e }, [e]);\n    }))).then((l) => this._createGeometry(l.geometry));\n    return a.catch(() => !0).then(() => {\n      s && i && this._releaseTask(s, i);\n    }), Li.set(e, {\n      key: n,\n      promise: a\n    }), a;\n  }\n  _createGeometry(e) {\n    const t = new ht();\n    e.index && t.setIndex(new ut(e.index.array, 1));\n    for (let n = 0; n < e.attributes.length; n++) {\n      const s = e.attributes[n], i = s.name, o = s.array, a = s.itemSize;\n      t.setAttribute(i, new ut(o, a));\n    }\n    return t;\n  }\n  _loadLibrary(e, t) {\n    const n = new kn(this.manager);\n    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, i) => {\n      n.load(e, s, void 0, i);\n    });\n  }\n  preload() {\n    return this._initDecoder(), this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const e = typeof WebAssembly != \"object\" || this.decoderConfig.type === \"js\", t = [];\n    return e ? t.push(this._loadLibrary(\"draco_decoder.js\", \"text\")) : (t.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\")), t.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"))), this.decoderPending = Promise.all(t).then((n) => {\n      const s = n[0];\n      e || (this.decoderConfig.wasmBinary = n[1]);\n      const i = If.toString(), o = [\n        \"/* draco decoder */\",\n        s,\n        \"\",\n        \"/* worker */\",\n        i.substring(i.indexOf(\"{\") + 1, i.lastIndexOf(\"}\"))\n      ].join(`\n`);\n      this.workerSourceURL = URL.createObjectURL(new Blob([o]));\n    }), this.decoderPending;\n  }\n  _getWorker(e, t) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const s = new Worker(this.workerSourceURL);\n        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: \"init\", decoderConfig: this.decoderConfig }), s.onmessage = function(i) {\n          const o = i.data;\n          switch (o.type) {\n            case \"decode\":\n              s._callbacks[o.id].resolve(o);\n              break;\n            case \"error\":\n              s._callbacks[o.id].reject(o);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + o.type + '\"');\n          }\n        }, this.workerPool.push(s);\n      } else\n        this.workerPool.sort(function(s, i) {\n          return s._taskLoad > i._taskLoad ? -1 : 1;\n        });\n      const n = this.workerPool[this.workerPool.length - 1];\n      return n._taskCosts[e] = t, n._taskLoad += t, n;\n    });\n  }\n  _releaseTask(e, t) {\n    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((e) => e._taskLoad)\n    );\n  }\n  dispose() {\n    for (let e = 0; e < this.workerPool.length; ++e)\n      this.workerPool[e].terminate();\n    return this.workerPool.length = 0, this;\n  }\n}\nfunction If() {\n  let r, e;\n  onmessage = function(o) {\n    const a = o.data;\n    switch (a.type) {\n      case \"init\":\n        r = a.decoderConfig, e = new Promise(function(f) {\n          r.onModuleLoaded = function(u) {\n            f({ draco: u });\n          }, DracoDecoderModule(r);\n        });\n        break;\n      case \"decode\":\n        const l = a.buffer, c = a.taskConfig;\n        e.then((f) => {\n          const u = f.draco, d = new u.Decoder(), h = new u.DecoderBuffer();\n          h.Init(new Int8Array(l), l.byteLength);\n          try {\n            const m = t(u, d, h, c), g = m.attributes.map((v) => v.array.buffer);\n            m.index && g.push(m.index.array.buffer), self.postMessage({ type: \"decode\", id: a.id, geometry: m }, g);\n          } catch (m) {\n            console.error(m), self.postMessage({ type: \"error\", id: a.id, error: m.message });\n          } finally {\n            u.destroy(h), u.destroy(d);\n          }\n        });\n        break;\n    }\n  };\n  function t(o, a, l, c) {\n    const f = c.attributeIDs, u = c.attributeTypes;\n    let d, h;\n    const m = a.GetEncodedGeometryType(l);\n    if (m === o.TRIANGULAR_MESH)\n      d = new o.Mesh(), h = a.DecodeBufferToMesh(l, d);\n    else if (m === o.POINT_CLOUD)\n      d = new o.PointCloud(), h = a.DecodeBufferToPointCloud(l, d);\n    else\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    if (!h.ok() || d.ptr === 0)\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + h.error_msg());\n    const g = { index: null, attributes: [] };\n    for (const v in f) {\n      const p = self[u[v]];\n      let b, _;\n      if (c.useUniqueIDs)\n        _ = f[v], b = a.GetAttributeByUniqueId(d, _);\n      else {\n        if (_ = a.GetAttributeId(d, o[f[v]]), _ === -1)\n          continue;\n        b = a.GetAttribute(d, _);\n      }\n      g.attributes.push(s(o, a, d, v, p, b));\n    }\n    return m === o.TRIANGULAR_MESH && (g.index = n(o, a, d)), o.destroy(d), g;\n  }\n  function n(o, a, l) {\n    const f = l.num_faces() * 3, u = f * 4, d = o._malloc(u);\n    a.GetTrianglesUInt32Array(l, u, d);\n    const h = new Uint32Array(o.HEAPF32.buffer, d, f).slice();\n    return o._free(d), { array: h, itemSize: 1 };\n  }\n  function s(o, a, l, c, f, u) {\n    const d = u.num_components(), m = l.num_points() * d, g = m * f.BYTES_PER_ELEMENT, v = i(o, f), p = o._malloc(g);\n    a.GetAttributeDataArrayForAllPoints(l, u, v, g, p);\n    const b = new f(o.HEAPF32.buffer, p, m).slice();\n    return o._free(p), {\n      name: c,\n      array: b,\n      itemSize: d\n    };\n  }\n  function i(o, a) {\n    switch (a) {\n      case Float32Array:\n        return o.DT_FLOAT32;\n      case Int8Array:\n        return o.DT_INT8;\n      case Int16Array:\n        return o.DT_INT16;\n      case Int32Array:\n        return o.DT_INT32;\n      case Uint8Array:\n        return o.DT_UINT8;\n      case Uint16Array:\n        return o.DT_UINT16;\n      case Uint32Array:\n        return o.DT_UINT32;\n    }\n  }\n}\nconst Tr = new _t(), Hs = new $();\nclass rl extends $l {\n  constructor() {\n    super(), this.isLineSegmentsGeometry = !0, this.type = \"LineSegmentsGeometry\";\n    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(n), this.setAttribute(\"position\", new gt(e, 3)), this.setAttribute(\"uv\", new gt(t, 2));\n  }\n  applyMatrix4(e) {\n    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;\n    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;\n  }\n  setPositions(e) {\n    let t;\n    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));\n    const n = new fo(t, 6, 1);\n    return this.setAttribute(\"instanceStart\", new nn(n, 3, 0)), this.setAttribute(\"instanceEnd\", new nn(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;\n  }\n  setColors(e, t = 3) {\n    let n;\n    e instanceof Float32Array ? n = e : Array.isArray(e) && (n = new Float32Array(e));\n    const s = new fo(n, t * 2, 1);\n    return this.setAttribute(\"instanceColorStart\", new nn(s, t, 0)), this.setAttribute(\"instanceColorEnd\", new nn(s, t, t)), this;\n  }\n  fromWireframeGeometry(e) {\n    return this.setPositions(e.attributes.position.array), this;\n  }\n  fromEdgesGeometry(e) {\n    return this.setPositions(e.attributes.position.array), this;\n  }\n  fromMesh(e) {\n    return this.fromWireframeGeometry(new Zl(e.geometry)), this;\n  }\n  fromLineSegments(e) {\n    const t = e.geometry;\n    return this.setPositions(t.attributes.position.array), this;\n  }\n  computeBoundingBox() {\n    this.boundingBox === null && (this.boundingBox = new _t());\n    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;\n    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Tr.setFromBufferAttribute(t), this.boundingBox.union(Tr));\n  }\n  computeBoundingSphere() {\n    this.boundingSphere === null && (this.boundingSphere = new Ms()), this.boundingBox === null && this.computeBoundingBox();\n    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;\n    if (e !== void 0 && t !== void 0) {\n      const n = this.boundingSphere.center;\n      this.boundingBox.getCenter(n);\n      let s = 0;\n      for (let i = 0, o = e.count; i < o; i++)\n        Hs.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(Hs)), Hs.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(Hs));\n      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error(\n        \"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\",\n        this\n      );\n    }\n  }\n  toJSON() {\n  }\n  applyMatrix(e) {\n    return console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\"), this.applyMatrix4(e);\n  }\n}\nclass al extends rl {\n  constructor() {\n    super(), this.isLineGeometry = !0, this.type = \"LineGeometry\";\n  }\n  setPositions(e) {\n    const t = e.length - 3, n = new Float32Array(2 * t);\n    for (let s = 0; s < t; s += 3)\n      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];\n    return super.setPositions(n), this;\n  }\n  setColors(e, t = 3) {\n    const n = e.length - t, s = new Float32Array(2 * n);\n    if (t === 3)\n      for (let i = 0; i < n; i += t)\n        s[2 * i] = e[i], s[2 * i + 1] = e[i + 1], s[2 * i + 2] = e[i + 2], s[2 * i + 3] = e[i + 3], s[2 * i + 4] = e[i + 4], s[2 * i + 5] = e[i + 5];\n    else\n      for (let i = 0; i < n; i += t)\n        s[2 * i] = e[i], s[2 * i + 1] = e[i + 1], s[2 * i + 2] = e[i + 2], s[2 * i + 3] = e[i + 3], s[2 * i + 4] = e[i + 4], s[2 * i + 5] = e[i + 5], s[2 * i + 6] = e[i + 6], s[2 * i + 7] = e[i + 7];\n    return super.setColors(s, t), this;\n  }\n  fromLine(e) {\n    const t = e.geometry;\n    return this.setPositions(t.attributes.position.array), this;\n  }\n}\nclass Ho extends bt {\n  constructor(e) {\n    super({\n      type: \"LineMaterial\",\n      uniforms: Dn.clone(\n        Dn.merge([\n          ni.common,\n          ni.fog,\n          {\n            worldUnits: { value: 1 },\n            linewidth: { value: 1 },\n            resolution: { value: new ve(1, 1) },\n            dashOffset: { value: 0 },\n            dashScale: { value: 1 },\n            dashSize: { value: 1 },\n            gapSize: { value: 1 }\n            // todo FIX - maybe change to totalSize\n          }\n        ])\n      ),\n      vertexShader: (\n        /* glsl */\n        `\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(Ts.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      clipping: !0\n      // required for clipping support\n    }), this.isLineMaterial = !0, this.onBeforeCompile = function() {\n      this.transparent ? this.defines.USE_LINE_COLOR_ALPHA = \"1\" : delete this.defines.USE_LINE_COLOR_ALPHA;\n    }, Object.defineProperties(this, {\n      color: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function(t) {\n          this.uniforms.diffuse.value = t;\n        }\n      },\n      worldUnits: {\n        enumerable: !0,\n        get: function() {\n          return \"WORLD_UNITS\" in this.defines;\n        },\n        set: function(t) {\n          t === !0 ? this.defines.WORLD_UNITS = \"\" : delete this.defines.WORLD_UNITS;\n        }\n      },\n      linewidth: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function(t) {\n          this.uniforms.linewidth.value = t;\n        }\n      },\n      dashed: {\n        enumerable: !0,\n        get: function() {\n          return \"USE_DASH\" in this.defines;\n        },\n        set(t) {\n          !!t != \"USE_DASH\" in this.defines && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = \"\" : delete this.defines.USE_DASH;\n        }\n      },\n      dashScale: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function(t) {\n          this.uniforms.dashScale.value = t;\n        }\n      },\n      dashSize: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function(t) {\n          this.uniforms.dashSize.value = t;\n        }\n      },\n      dashOffset: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function(t) {\n          this.uniforms.dashOffset.value = t;\n        }\n      },\n      gapSize: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function(t) {\n          this.uniforms.gapSize.value = t;\n        }\n      },\n      opacity: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(t) {\n          this.uniforms.opacity.value = t;\n        }\n      },\n      resolution: {\n        enumerable: !0,\n        get: function() {\n          return this.uniforms.resolution.value;\n        },\n        set: function(t) {\n          this.uniforms.resolution.value.copy(t);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: !0,\n        get: function() {\n          return \"USE_ALPHA_TO_COVERAGE\" in this.defines;\n        },\n        set: function(t) {\n          !!t != \"USE_ALPHA_TO_COVERAGE\" in this.defines && (this.needsUpdate = !0), t === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = \"\", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);\n        }\n      }\n    }), this.setValues(e);\n  }\n}\nconst ki = new at(), br = new $(), Er = new $(), it = new at(), ot = new at(), Ut = new at(), Ni = new $(), Bi = new Ie(), rt = new Kl(), Mr = new $(), js = new _t(), Vs = new Ms(), Ft = new at();\nlet Yt, On;\nfunction Sr(r, e, t) {\n  return Ft.set(0, 0, -e, 1).applyMatrix4(r.projectionMatrix), Ft.multiplyScalar(1 / Ft.w), Ft.x = On / t.width, Ft.y = On / t.height, Ft.applyMatrix4(r.projectionMatrixInverse), Ft.multiplyScalar(1 / Ft.w), Math.abs(Math.max(Ft.x, Ft.y));\n}\nfunction Of(r, e) {\n  const t = r.matrixWorld, n = r.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, o = Math.min(n.instanceCount, s.count);\n  for (let a = 0, l = o; a < l; a++) {\n    rt.start.fromBufferAttribute(s, a), rt.end.fromBufferAttribute(i, a), rt.applyMatrix4(t);\n    const c = new $(), f = new $();\n    Yt.distanceSqToSegment(rt.start, rt.end, f, c), f.distanceTo(c) < On * 0.5 && e.push({\n      point: f,\n      pointOnLine: c,\n      distance: Yt.origin.distanceTo(f),\n      object: r,\n      face: null,\n      faceIndex: a,\n      uv: null,\n      [Bo]: null\n    });\n  }\n}\nfunction Df(r, e, t) {\n  const n = e.projectionMatrix, i = r.material.resolution, o = r.matrixWorld, a = r.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, f = Math.min(a.instanceCount, l.count), u = -e.near;\n  Yt.at(1, Ut), Ut.w = 1, Ut.applyMatrix4(e.matrixWorldInverse), Ut.applyMatrix4(n), Ut.multiplyScalar(1 / Ut.w), Ut.x *= i.x / 2, Ut.y *= i.y / 2, Ut.z = 0, Ni.copy(Ut), Bi.multiplyMatrices(e.matrixWorldInverse, o);\n  for (let d = 0, h = f; d < h; d++) {\n    if (it.fromBufferAttribute(l, d), ot.fromBufferAttribute(c, d), it.w = 1, ot.w = 1, it.applyMatrix4(Bi), ot.applyMatrix4(Bi), it.z > u && ot.z > u)\n      continue;\n    if (it.z > u) {\n      const _ = it.z - ot.z, M = (it.z - u) / _;\n      it.lerp(ot, M);\n    } else if (ot.z > u) {\n      const _ = ot.z - it.z, M = (ot.z - u) / _;\n      ot.lerp(it, M);\n    }\n    it.applyMatrix4(n), ot.applyMatrix4(n), it.multiplyScalar(1 / it.w), ot.multiplyScalar(1 / ot.w), it.x *= i.x / 2, it.y *= i.y / 2, ot.x *= i.x / 2, ot.y *= i.y / 2, rt.start.copy(it), rt.start.z = 0, rt.end.copy(ot), rt.end.z = 0;\n    const g = rt.closestPointToPointParameter(Ni, !0);\n    rt.at(g, Mr);\n    const v = Ye.lerp(it.z, ot.z, g), p = v >= -1 && v <= 1, b = Ni.distanceTo(Mr) < On * 0.5;\n    if (p && b) {\n      rt.start.fromBufferAttribute(l, d), rt.end.fromBufferAttribute(c, d), rt.start.applyMatrix4(o), rt.end.applyMatrix4(o);\n      const _ = new $(), M = new $();\n      Yt.distanceSqToSegment(rt.start, rt.end, M, _), t.push({\n        point: M,\n        pointOnLine: _,\n        distance: Yt.origin.distanceTo(M),\n        object: r,\n        face: null,\n        faceIndex: d,\n        uv: null,\n        [Bo]: null\n      });\n    }\n  }\n}\nclass Lf extends de {\n  constructor(e = new rl(), t = new Ho({ color: Math.random() * 16777215 })) {\n    super(e, t), this.isLineSegments2 = !0, this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);\n    for (let o = 0, a = 0, l = t.count; o < l; o++, a += 2)\n      br.fromBufferAttribute(t, o), Er.fromBufferAttribute(n, o), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + br.distanceTo(Er);\n    const i = new fo(s, 2, 1);\n    return e.setAttribute(\"instanceDistanceStart\", new nn(i, 1, 0)), e.setAttribute(\"instanceDistanceEnd\", new nn(i, 1, 1)), this;\n  }\n  raycast(e, t) {\n    const n = this.material.worldUnits, s = e.camera;\n    s === null && !n && console.error(\n      'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'\n    );\n    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;\n    Yt = e.ray;\n    const o = this.matrixWorld, a = this.geometry, l = this.material;\n    On = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), Vs.copy(a.boundingSphere).applyMatrix4(o);\n    let c;\n    if (n)\n      c = On * 0.5;\n    else {\n      const u = Math.max(s.near, Vs.distanceToPoint(Yt.origin));\n      c = Sr(s, u, l.resolution);\n    }\n    if (Vs.radius += c, Yt.intersectsSphere(Vs) === !1)\n      return;\n    a.boundingBox === null && a.computeBoundingBox(), js.copy(a.boundingBox).applyMatrix4(o);\n    let f;\n    if (n)\n      f = On * 0.5;\n    else {\n      const u = Math.max(s.near, js.distanceToPoint(Yt.origin));\n      f = Sr(s, u, l.resolution);\n    }\n    js.expandByScalar(f), Yt.intersectsBox(js) !== !1 && (n ? Of(this, t) : Df(this, s, t));\n  }\n  onBeforeRender(e) {\n    const t = this.material.uniforms;\n    t && t.resolution && (e.getViewport(ki), this.material.uniforms.resolution.value.set(ki.z, ki.w));\n  }\n}\nclass kf extends Lf {\n  constructor(e = new al(), t = new Ho({ color: Math.random() * 16777215 })) {\n    super(e, t), this.isLine2 = !0, this.type = \"Line2\";\n  }\n}\nclass Nf extends ke {\n  constructor(e, t = 1, n = 16, s = 2) {\n    const i = new ht(), o = n + s * 2, a = new Float32Array((o * 3 + 3) * 3);\n    i.setAttribute(\"position\", new ut(a, 3));\n    const l = new ws({ color: 65280 }), c = new ws({ color: 16776960 });\n    super(i, [c, l]), this.type = \"PositionalAudioHelper\", this.audio = e, this.range = t, this.divisionsInnerAngle = n, this.divisionsOuterAngle = s, this.update();\n  }\n  update() {\n    const e = this.audio, t = this.range, n = this.divisionsInnerAngle, s = this.divisionsOuterAngle, i = Ye.degToRad(e.panner.coneInnerAngle), o = Ye.degToRad(e.panner.coneOuterAngle), a = i / 2, l = o / 2;\n    let c = 0, f = 0, u, d;\n    const h = this.geometry, m = h.attributes.position;\n    h.clearGroups();\n    function g(v, p, b, _) {\n      const M = (p - v) / b;\n      for (m.setXYZ(c, 0, 0, 0), f++, u = v; u < p; u += M)\n        d = c + f, m.setXYZ(d, Math.sin(u) * t, 0, Math.cos(u) * t), m.setXYZ(\n          d + 1,\n          Math.sin(Math.min(u + M, p)) * t,\n          0,\n          Math.cos(Math.min(u + M, p)) * t\n        ), m.setXYZ(d + 2, 0, 0, 0), f += 3;\n      h.addGroup(c, f, _), c += f, f = 0;\n    }\n    g(-l, -a, s, 0), g(-a, a, n, 1), g(a, l, s, 0), m.needsUpdate = !0, i === o && (this.material[0].visible = !1);\n  }\n  dispose() {\n    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();\n  }\n}\nfunction Bf(r) {\n  return r;\n}\nfunction Uf(r) {\n  return r * r * r;\n}\nfunction Ff(r) {\n  return r < 0.5 ? 4 * r * r * r : 1 - (-2 * r + 2) ** 3 / 2;\n}\nfunction zf(r) {\n  return r * r * r * r;\n}\nfunction Gf(r) {\n  return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;\n}\nconst cn = \"https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/\", jo = `${cn}circle.png`, hi = `${cn}circleBlur.png`, Hf = `${cn}circleRainbow.png`, jf = `${cn}line.png`, ll = `${cn}poly6.png`, cl = `${cn}polyStroke6.png`, Vf = `${cn}rays.png`, fi = `${cn}ring.png`, Yf = `${cn}starThin6.png`, Wf = {\n  texture: [jf, fi],\n  color: [\"white\"],\n  distance: [0, 0],\n  size: [750, 1024],\n  length: [0, 2]\n}, Xf = {\n  texture: [hi],\n  color: [\"white\"],\n  distance: [0, 0],\n  size: [180, 512],\n  length: [1, 1]\n}, $f = {\n  texture: [Vf],\n  color: [\"white\"],\n  distance: [0, 0],\n  size: [180, 512],\n  length: [1, 1]\n}, Zf = {\n  texture: [jo, Hf, fi, Yf],\n  color: [\"white\"],\n  distance: [0, 0],\n  size: [180, 512],\n  length: [2, 3]\n}, [ul, hl] = [3679071, 132442], Kf = {\n  texture: [hi, jo, fi, ll, cl],\n  color: [\"dimgray\", \"gray\", \"darkgray\", ul, hl],\n  distance: [0.5, 2.5],\n  size: [20, 180],\n  length: [5, 21]\n}, qf = {\n  texture: [hi, jo, fi, ll, cl],\n  color: [\"dimgray\", \"gray\", \"darkgray\", ul, hl],\n  distance: [-0.6, -0.1],\n  size: [180, 360],\n  length: [0, 5]\n}, wo = [Wf, Xf, $f, Zf, Kf, qf], oi = {\n  color: \"white\",\n  distance: 0,\n  size: 512,\n  texture: hi\n}, Ar = Ye.clamp;\nclass Pr {\n  /**\n   * Create a new seeded pseudorandom number generator.\n   * @param [seed] - the seed for the generator\n   * @param [getSeededRandomGenerator] - a function that returns a pseudorandom number generator\n   * @constructor\n   */\n  constructor(e = 0, t) {\n    pe(this, \"_getNext\");\n    pe(this, \"_getGenerator\");\n    this._getGenerator = t ?? this.getMulberry32, this._getNext = this._getGenerator(e);\n  }\n  /**\n   * Reseed the pseudorandom number generator\n   */\n  seed(e) {\n    this._getNext = this._getGenerator(e);\n  }\n  /**\n   * Return the next pseudorandom number in the interval [0, 1]\n   */\n  rand() {\n    return this._getNext();\n  }\n  /**\n   * Random float from <low, high> interval\n   * @param low - Low value of the interval\n   * @param high - High value of the interval\n   */\n  float(e, t) {\n    return e + this._getNext() * (t - e);\n  }\n  /**\n   * Random float from <-range/2, range/2> interval\n   * @param range - Interval range\n   */\n  floatSpread(e) {\n    return this.float(-0.5 * e, 0.5 * e);\n  }\n  /**\n   * Random integer from <low, high> interval\n   * @param low Low value of the interval\n   * @param high High value of the interval\n   */\n  int(e, t) {\n    return e + Math.floor(this._getNext() * (t - e + 1));\n  }\n  /**\n   * Choose an element from an array.\n   * @param array The array to choose from\n   * @returns An element from the array or null if the array is empty\n   */\n  choice(e) {\n    return e.length ? e[Math.floor(this._getNext() * e.length)] : null;\n  }\n  /**\n   * Choose an element from an array or return defaultValue if array is empty.\n   * @param array The array to choose from\n   * @param defaultValue The value to return if the array is empty\n   * @returns An element from the array or defaultValue if the array is empty\n   */\n  defaultChoice(e, t) {\n    return e.length ? e[Math.floor(this._getNext() * e.length)] : t;\n  }\n  /**\n   * Return n elements from an array.\n   * @param array The array to sample\n   * @param sampleSizeMin The minimum sample size\n   * @param sampleSizeMax The maximum sample size\n   */\n  sample(e, t, n) {\n    const s = e.length;\n    t = Ar(t, 0, s - 1), n = Ar(n ?? s - 1, 0, s - 1);\n    const i = this.int(t, n), o = this.shuffle(e.map((l, c) => c)), a = Math.min(e.length, i);\n    return o.slice(0, a).sort().map((l) => e[l]);\n  }\n  /**\n   * Shuffle an array. Not in-place.\n   * @param array The array to shuffle\n   */\n  shuffle(e) {\n    return e.map((t) => ({ value: t, sort: this._getNext() })).sort((t, n) => t.sort - n.sort).map(({ value: t }) => t);\n  }\n  /**\n   * The default pseudorandom generator.\n   */\n  getMulberry32(e = 0) {\n    return e > 0 && e < 1 && (e = Math.floor(e * 2 ** 16)), () => {\n      e += 1831565813;\n      let t = e;\n      return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;\n    };\n  }\n}\nconst Qf = [\n  Bf,\n  Uf,\n  Ff,\n  zf,\n  Gf\n], Rr = Ye.lerp, Cr = (r = 0, e = wo) => {\n  const n = new Pr(r).choice(Qf);\n  return e.map((s, i) => {\n    const o = new Pr(\n      r * (i * 7907 + 1) + (typeof s.seed == \"number\" ? s.seed : 0)\n    ), a = o.int(s.length[0], s.length[1]);\n    return Array.from({ length: a }).fill(0).map(() => {\n      const l = n(o.rand());\n      return {\n        texture: o.defaultChoice(\n          s.texture,\n          oi.texture\n        ),\n        size: Rr(s.size[0], s.size[1], n(1 - l)),\n        distance: Rr(s.distance[0], s.distance[1], l),\n        color: o.defaultChoice(\n          s.color,\n          oi.color\n        )\n      };\n    });\n  }).flat();\n}, Ir = (r, e, t = void 0, n = void 0, s = oi) => {\n  if (r !== void 0 && r.length > 0 && (typeof t == \"number\" || typeof n < \"u\")) {\n    const a = Cr(t ?? 0, n ?? wo), l = a.length, c = r.length;\n    return l >= c ? a.map(\n      (f, u) => Object.assign(f, e, u < c ? r[u] : {})\n    ) : r.map(\n      (f, u) => Object.assign({}, s, u < l ? a[u] : {}, e, f)\n    );\n  }\n  if (r !== void 0 && r.length > 0) {\n    const a = Object.assign({}, s, e);\n    return r.map((l) => Object.assign({}, a, l));\n  }\n  const i = n === void 0 || n.length === 0 ? wo : n;\n  return Cr(t ?? 0, i).map((a) => Object.assign({}, a, e));\n};\nfunction Jf(r) {\n  return ed(r, (e, t) => t in oi && e !== void 0);\n}\nfunction ed(r, e) {\n  const t = {};\n  return Object.keys(r).forEach((n) => {\n    e(r[n], n) && (t[n] = r[n]);\n  }), t;\n}\nconst jg = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    scale: { default: 1 },\n    elements: { default: void 0 },\n    seed: { default: void 0 },\n    seedProps: { default: void 0 },\n    color: { default: void 0 },\n    distance: { default: void 0 },\n    size: { default: void 0 },\n    texture: { default: void 0 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), s = re([]), i = re(Jf(t));\n    e({\n      instance: n\n    });\n    const o = new ai(), a = new Xa(), l = [], c = () => {\n      var h, m, g;\n      for (; l.length; )\n        l.pop();\n      (h = n.value) == null || h.children.forEach((v) => {\n        \"dispose\" in v && v.dispose();\n      }), (m = n.value) == null || m.remove(...n.value.children), (g = n.value) == null || g.dispose();\n    }, f = (h) => {\n      if (typeof h.texture == \"string\") {\n        const m = h.texture;\n        h.texture = o.load(m), h.texture.name = m;\n      }\n      return h.color = tn(h.color), h;\n    }, u = () => {\n      for (let h = s.value.length - 1; h < l.length; h++)\n        l[h].size = 0;\n      s.value.forEach((h, m) => {\n        l[m].size = h.size * t.scale;\n      });\n    }, d = () => {\n      for (; s.value.length > l.length; ) {\n        const m = { ...f(s.value[l.length]) };\n        l.push(m), a.addElement(m);\n      }\n      s.value.forEach((h, m) => {\n        const g = l[m], { texture: v, size: p, distance: b, color: _ } = h;\n        if (typeof v == \"string\") {\n          if (g.texture.name !== v) {\n            g.texture.dispose();\n            const M = v;\n            g.texture = o.load(M), g.texture.name = M;\n          }\n        } else\n          g.texture !== v && (g.texture.dispose(), g.texture = v);\n        g.size = p, g.distance = b, g.color = tn(_);\n      }), u();\n    };\n    return tt(() => {\n      c();\n    }), bn(() => {\n      var h;\n      (h = n.value) == null || h.add(a), s.value = Ir(t.elements, i.value, t.seed, t.seedProps);\n    }), J(() => [t.color, t.distance, t.size, t.texture], () => {\n      i.value = {\n        color: t.color,\n        distance: t.distance,\n        size: t.size,\n        texture: t.texture\n      };\n    }), J(() => [i.value, t.elements, t.seed, t.seedProps], () => {\n      s.value = Ir(t.elements, i.value, t.seed, t.seedProps);\n    }), J(() => t.scale, () => {\n      u();\n    }), J(() => s.value, () => {\n      d();\n    }), (h, m) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"lensflareRef\",\n      ref: n\n    }, null, 512));\n  }\n}), Vg = /* @__PURE__ */ ue({\n  __name: \"Levioso\",\n  props: {\n    speed: { default: 1 },\n    rotationFactor: { default: 1 },\n    floatFactor: { default: 1 },\n    range: { default: () => [-0.1, 0.1] }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re();\n    e({\n      instance: n\n    });\n    {\n      const l = Math.random() * 1e4, { onBeforeRender: c } = Ve();\n      let f = l;\n      c(({ delta: u, invalidate: d }) => {\n        if (!n.value)\n          return;\n        f += u * t.speed;\n        const h = f * 0.25, m = n.value;\n        m.rotation.x = Math.cos(h) * 0.125 * t.rotationFactor, m.rotation.y = Math.sin(h) * 0.125 * t.rotationFactor, m.rotation.z = Math.sin(h) * 0.05 * t.rotationFactor, m.position.y = Ye.mapLinear(Math.sin(h), -1, 1, t.range[0], t.range[1]) * t.floatFactor, d();\n      });\n    }\n    return (s, i) => (ae(), ce(\"TresGroup\", $e(s.$attrs, {\n      ref_key: \"groupRef\",\n      ref: n\n    }), [\n      Ne(s.$slots, \"default\")\n    ], 16));\n  }\n}), td = [\"render-order\"], Yg = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    id: { default: 1 },\n    colorWrite: { type: Boolean, default: !0 },\n    depthWrite: { type: Boolean, default: !1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re();\n    function s() {\n      var o, a;\n      const i = Array.isArray((o = n.value) == null ? void 0 : o.material) ? n.value.material[0] : (a = n.value) == null ? void 0 : a.material;\n      i && (i.colorWrite = t.colorWrite, i.depthWrite = t.depthWrite, i.stencilWrite = !0, i.stencilRef = t.id, i.stencilFunc = ql, i.stencilFail = xi, i.stencilZFail = xi, i.stencilZPass = xi);\n    }\n    return et(s), e({ instance: n }), (i, o) => (ae(), ce(\"TresMesh\", {\n      ref_key: \"meshRef\",\n      ref: n,\n      \"render-order\": -t.id\n    }, [\n      Ne(i.$slots, \"default\")\n    ], 8, td));\n  }\n}), Wg = /* @__PURE__ */ ue({\n  __name: \"MouseParallax\",\n  props: {\n    disabled: { type: Boolean, default: !1 },\n    factor: { default: 2.5 },\n    ease: { default: 0.1 },\n    local: { type: Boolean, default: !1 }\n  },\n  setup(r) {\n    const e = r, { camera: t, renderer: n } = xe(), { disabled: s, factor: i, ease: o, local: a } = Le(e), l = {};\n    a.value && (l.target = n.value.domElement, l.type = \"client\");\n    const { x: c, y: f } = nu(l), { width: u, height: d } = a.value ? qc(n.value.domElement) : Na(), h = re(), m = me(), g = me();\n    J(\n      [i, o],\n      () => {\n        m.value = Array.isArray(i.value) ? i.value : [i.value, i.value], g.value = Array.isArray(o.value) ? o.value : [o.value, o.value];\n      },\n      { immediate: !0 }\n    );\n    const v = Pe(() => (c.value / u.value - 0.5) * m.value[0]), p = Pe(() => -(f.value / d.value - 0.5) * m.value[1]), { onBeforeRender: b } = Ve();\n    return b(({ delta: _, invalidate: M }) => {\n      s.value || !h.value || Number.isNaN(v.value) || Number.isNaN(p.value) || (h.value.position.x += (v.value - h.value.position.x) * g.value[0] * _, h.value.position.y += (p.value - h.value.position.y) * g.value[1] * _, M());\n    }), J(\n      () => h.value,\n      (_) => _ == null ? void 0 : _.add(t.value)\n    ), (_, M) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"cameraGroupRef\",\n      ref: h\n    }, null, 512));\n  }\n}), nd = No(\n  {\n    screenspace: !1,\n    color: new be(\"black\"),\n    opacity: 1,\n    thickness: 0.05,\n    size: new ve(1, 1)\n  },\n  `#include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   uniform bool screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n       #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n     #include <morphtarget_vertex>\n     #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }`,\n  `uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <colorspace_fragment>\n   }`\n), Xg = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    color: { default: \"black\" },\n    screenspace: { type: Boolean, default: !1 },\n    opacity: { default: 1 },\n    transparent: { type: Boolean, default: !1 },\n    thickness: { default: 0.05 },\n    angle: { default: Math.PI },\n    toneMapped: { type: Boolean, default: !0 },\n    polygonOffset: { type: Boolean, default: !1 },\n    polygonOffsetFactor: { default: 0 },\n    renderOrder: { default: 0 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re();\n    e({ instance: n });\n    const s = new nd({ ...t }), i = new ve(1, 1);\n    let o = 0, a = null;\n    function l(u) {\n      var h;\n      const d = u.parent;\n      if (!(!d || !d.geometry) && (o !== t.angle || a !== d.geometry)) {\n        o = t.angle, a = d.geometry;\n        let m = (h = u.children) == null ? void 0 : h[0];\n        m && (t.angle && m.geometry.dispose(), u.remove(m)), d.skeleton ? (m = new Po(), m.material = s, m.bind(d.skeleton, d.bindMatrix), u.add(m)) : d.isInstancedMesh ? (m = new Ta(d.geometry, s, d.count), m.instanceMatrix = d.instanceMatrix, u.add(m)) : (m = new de(), m.material = s, u.add(m)), m.geometry = t.angle ? hu(d.geometry, t.angle) : d.geometry;\n      }\n    }\n    function c() {\n      s.side = li, s.transparent = t.transparent, s.thickness = t.thickness, s.color = tn(t.color), s.opacity = t.opacity, s.size = i, s.screenspace = t.screenspace, s.toneMapped = t.toneMapped, s.polygonOffset = t.polygonOffset, s.polygonOffsetFactor = t.polygonOffsetFactor;\n    }\n    const f = xn().sizes;\n    return J(() => [f.width.value, f.height.value], ([u, d]) => {\n      i.set(u, d);\n    }), J(() => [t.angle], () => {\n      n.value && l(n.value);\n    }), J(\n      () => [t.transparent, t.thickness, t.color, t.opacity, i, t.screenspace, t.toneMapped, t.polygonOffset, t.polygonOffsetFactor],\n      () => c(),\n      { immediate: !0 }\n    ), bn(() => l(n.value)), tt(() => {\n      var d;\n      const u = (d = n.value) == null ? void 0 : d.children[0];\n      u && (u.geometry.dispose(), s.dispose(), u.removeFromParent());\n    }), (u, d) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"groupRef\",\n      ref: n\n    }, null, 512));\n  }\n}), sd = [\"args\"], $g = /* @__PURE__ */ ue({\n  __name: \"PositionalAudio\",\n  props: {\n    ready: { type: Boolean, default: !1 },\n    url: {},\n    distance: { default: 2 },\n    helper: { type: Boolean, default: !1 },\n    loop: { type: Boolean, default: !1 },\n    autoplay: { type: Boolean, default: !1 },\n    innerAngle: { default: 360 },\n    outerAngle: { default: 360 },\n    outerGain: { default: 0 }\n  },\n  emits: [\"isPlaying\"],\n  async setup(r, { expose: e, emit: t }) {\n    let n, s;\n    const i = r, o = t, { ready: a, url: l, distance: c, helper: f, loop: u, autoplay: d, innerAngle: h, outerAngle: m, outerGain: g } = Le(i), { camera: v } = xe(), p = re(null), b = re(null), _ = re(null), M = Pa(new ca()), R = () => {\n      var N, U, Y;\n      (N = p == null ? void 0 : p.value) != null && N.isPlaying || ((U = p == null ? void 0 : p.value) == null || U.play(), o(\"isPlaying\", (Y = p == null ? void 0 : p.value) == null ? void 0 : Y.isPlaying));\n    }, w = () => {\n      var N, U;\n      (N = p == null ? void 0 : p.value) != null && N.isPlaying && (p.value.pause(), o(\"isPlaying\", (U = p == null ? void 0 : p.value) == null ? void 0 : U.isPlaying));\n    }, E = () => {\n      var N;\n      p.value && (p.value.stop(), o(\"isPlaying\", (N = p == null ? void 0 : p.value) == null ? void 0 : N.isPlaying));\n    }, x = () => {\n      if (!(p != null && p.value))\n        return;\n      E();\n      const N = p.value;\n      N.source && N.disconnect();\n    }, T = () => {\n      var N, U;\n      !(p != null && p.value) || !(b != null && b.value) || ((N = b == null ? void 0 : b.value) == null || N.dispose(), (U = p == null ? void 0 : p.value) == null || U.remove(b == null ? void 0 : b.value));\n    }, y = () => {\n      var N;\n      if (p.value && (p.value.setBuffer(_.value), p.value.setRefDistance(c.value), p.value.setLoop(u.value), p.value.setDirectionalCone(h.value, m.value, g.value), (N = b == null ? void 0 : b.value) == null || N.update(), b != null && b.value)) {\n        const U = b.value.material[0];\n        !U.visible && m.value !== h.value && (U.visible = !0);\n      }\n    }, A = () => {\n      var V, ne;\n      y();\n      const N = (V = p.value) == null ? void 0 : V.parent, U = new _t().setFromObject(N), Y = (U.max.z - U.min.z) * 2;\n      b.value = new Nf(p.value, Y, 32, 16), (ne = p == null ? void 0 : p.value) == null || ne.add(b.value), b.value.update();\n    }, C = () => {\n      var N;\n      (N = v == null ? void 0 : v.value) == null || N.remove(M), x(), T();\n    };\n    return e({\n      instance: p,\n      play: R,\n      stop: E,\n      pause: w,\n      dispose: C\n    }), _.value = ([n, s] = Tn(() => Nn(ua, l.value)), n = await n, s(), n), J(p, () => {\n      p != null && p.value && (f.value && A(), a.value && d && R());\n    }), J(f, () => {\n      f.value ? A() : T();\n    }), J(a, () => {\n      a.value && y(), d.value && a.value && R(), !d.value && a.value && E();\n    }), J([c, u, _, h, m, g, d], () => {\n      y();\n    }), bn(() => {\n      var N;\n      (N = v == null ? void 0 : v.value) == null || N.add(M);\n    }), Co(() => {\n      C();\n    }), (N, U) => (ae(), ce(\"TresPositionalAudio\", $e({\n      ref_key: \"positionalAudioRef\",\n      ref: p,\n      args: [F(M)]\n    }, N.$attrs), null, 16, sd));\n  }\n}), id = [\"args\", \"material-uniforms-color-value\"], Zg = /* @__PURE__ */ ue({\n  __name: \"Reflector\",\n  props: {\n    color: { default: \"#333\" },\n    textureWidth: { default: 512 },\n    textureHeight: { default: 512 },\n    clipBias: { default: 0 },\n    multisample: { default: 4 },\n    shader: { default: vo.ReflectorShader }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { extend: n, invalidate: s } = xe(), i = re();\n    n({ Reflector: vo });\n    const { color: o, textureWidth: a, textureHeight: l, clipBias: c, multisample: f, shader: u } = Le(t);\n    return J(t, () => s()), e({\n      instance: i\n    }), (d, h) => (ae(), ce(\"TresReflector\", {\n      ref_key: \"reflectorRef\",\n      ref: i,\n      args: [void 0, { textureWidth: F(a), textureHeight: F(l), clipBias: F(c), multisample: F(f), shader: F(u) }],\n      \"material-uniforms-color-value\": F(o)\n    }, [\n      Ne(d.$slots, \"default\", {}, () => [\n        h[0] || (h[0] = ye(\"TresPlaneGeometry\", { args: [5, 5] }, null, -1))\n      ])\n    ], 8, id));\n  }\n}), od = [\"position-z\"], Kg = /* @__PURE__ */ ue({\n  __name: \"ScreenSpace\",\n  props: {\n    depth: { default: -1 }\n  },\n  setup(r, { expose: e }) {\n    const t = re();\n    return Ve().onBeforeRender(({ camera: n }) => {\n      t.value && (t.value.quaternion.copy(n.quaternion), t.value.position.copy(n.position));\n    }), e({ instance: t }), (n, s) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"outerRef\",\n      ref: t\n    }, [\n      ye(\"TresGroup\", {\n        \"position-z\": -n.depth\n      }, [\n        Ne(n.$slots, \"default\")\n      ], 8, od)\n    ], 512));\n  }\n}), rd = [\"args\", \"center\"], qg = /* @__PURE__ */ ue({\n  __name: \"Text3D\",\n  props: {\n    font: {},\n    text: {},\n    size: { default: 0.5 },\n    height: { default: 0.2 },\n    curveSegments: { default: 5 },\n    bevelEnabled: { type: Boolean, default: !0 },\n    bevelThickness: { default: 0.05 },\n    bevelSize: { default: 0.02 },\n    bevelOffset: { default: 0 },\n    bevelSegments: { default: 4 },\n    center: { type: Boolean, default: !1 },\n    needUpdates: { type: Boolean, default: !1 }\n  },\n  async setup(r, { expose: e }) {\n    let t, n;\n    const s = r, {\n      center: i,\n      font: o,\n      text: a,\n      needUpdates: l,\n      size: c,\n      height: f,\n      curveSegments: u,\n      bevelEnabled: d,\n      bevelThickness: h,\n      bevelSize: m,\n      bevelOffset: g,\n      bevelSegments: v\n    } = Le(s), { extend: p, invalidate: b } = xe();\n    J(s, () => b()), p({ TextGeometry: gr });\n    const _ = new Sf(), M = Io(), R = Pe(() => {\n      var T;\n      return a != null && a.value ? a.value : M.default ? (T = M.default()[0].children) == null ? void 0 : T.trim() : l.value ? \"\" : \"TresJS\";\n    }), w = re();\n    e({\n      instance: w\n    });\n    const E = ([t, n] = Tn(() => new Promise((T, y) => {\n      try {\n        typeof o.value == \"string\" ? _.load(o.value, (A) => {\n          T(A);\n        }) : T(o.value);\n      } catch (A) {\n        y(console.error(\"cientos\", A));\n      }\n    })), t = await t, n(), t), x = Pe(() => ({\n      font: E,\n      size: ze(c),\n      height: ze(f),\n      curveSegments: ze(u),\n      bevelEnabled: ze(d),\n      bevelThickness: ze(h),\n      bevelSize: ze(m),\n      bevelOffset: ze(g),\n      bevelSegments: ze(v)\n    }));\n    return et(() => {\n      w.value && l.value && (w.value.geometry.dispose(), w.value.geometry = new gr(R.value, x.value), i.value && w.value.geometry.center());\n    }), (T, y) => F(o) ? (ae(), ce(\"TresMesh\", {\n      key: 0,\n      ref_key: \"text3DRef\",\n      ref: w\n    }, [\n      R.value ? (ae(), ce(\"TresTextGeometry\", {\n        key: 0,\n        args: [R.value, x.value],\n        center: F(i)\n      }, null, 8, rd)) : an(\"\", !0),\n      Ne(T.$slots, \"default\")\n    ], 512)) : an(\"\", !0);\n  }\n});\nfunction Qg(r, e) {\n  const t = me(e), n = new Ql(t.value), s = Pa({});\n  r.forEach((o) => {\n    const a = n.clipAction(o, t.value);\n    s[o.name] = a;\n  });\n  const { onBeforeRender: i } = Ve();\n  return i(({ delta: o }) => {\n    n.update(o);\n  }), {\n    actions: s,\n    mixer: n\n  };\n}\nfunction Jg(r, e = !1) {\n  const t = ts({\n    stencilWrite: !0,\n    stencilRef: ze(r),\n    stencilFunc: ze(e) ? $o : Zo,\n    stencilFail: wi,\n    stencilZFail: wi,\n    stencilZPass: wi\n  });\n  return et(() => {\n    t.stencilRef = ze(r), t.stencilFunc = ze(e) ? $o : Zo;\n  }), t;\n}\nfunction ad(r) {\n  const e = me(null), { height: t, width: n, settings: s, depth: i, autoRender: o = me(!0) } = po(r) ? Le(r) : Le(ts(r)), { onBeforeRender: a } = Ve(), { camera: l, renderer: c, scene: f, sizes: u, invalidate: d } = xe();\n  return J(() => [n == null ? void 0 : n.value, u.width.value, t == null ? void 0 : t.value, u.height.value], () => {\n    var h;\n    (h = e.value) == null || h.dispose(), e.value = new Xt((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {\n      minFilter: wt,\n      magFilter: wt,\n      type: Lt,\n      ...s == null ? void 0 : s.value\n    }), i != null && i.value && (e.value.depthTexture = new Sa(\n      (n == null ? void 0 : n.value) || u.width.value,\n      (t == null ? void 0 : t.value) || u.height.value,\n      qs\n    )), d();\n  }, { immediate: !0 }), a(() => {\n    o.value && (c.value.setRenderTarget(e.value), c.value.clear(), c.value.render(f.value, l.value), c.value.setRenderTarget(null));\n  }, Number.POSITIVE_INFINITY), Co(() => {\n    var h;\n    (h = e.value) == null || h.dispose();\n  }), e;\n}\nconst ev = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    width: {},\n    height: {},\n    depth: { type: Boolean, default: !1 },\n    settings: { default: void 0 },\n    autoRender: { type: Boolean, default: !0 }\n  },\n  setup(r, { expose: e }) {\n    const n = ad(r);\n    return e({\n      instance: n\n    }), () => {\n    };\n  }\n}), ld = (r, e = 16, t, n, s) => {\n  const i = new Float32Array(e * 16), o = me(new Ao(i, 16));\n  return (() => {\n    if (!r)\n      return;\n    const l = new ih(r);\n    n && l.setWeightAttribute(n), l.build();\n    const c = new $(), f = new $(), u = new be(), d = new Rt();\n    r.updateMatrixWorld(!0);\n    for (let h = 0; h < e; h++)\n      l.sample(c, f, u), typeof s == \"function\" ? s(\n        {\n          dummy: d,\n          sampledMesh: r,\n          position: c,\n          normal: f,\n          color: u\n        },\n        h\n      ) : d.position.copy(c), d.updateMatrix(), t && t.setMatrixAt(h, d.matrix), d.matrix.toArray(o.value.array, h * 16);\n    t && (t.instanceMatrix.needsUpdate = !0), o.value.needsUpdate = !0;\n  })(), { buffer: o };\n}, tv = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    transform: { type: Function },\n    weight: {},\n    count: {},\n    mesh: {},\n    instanceMesh: {}\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = me(), s = me(), i = me(), { invalidate: o } = xe();\n    return J(t, () => o()), et(() => {\n      var a, l;\n      s.value = t.instanceMesh ?? ((a = n.value) == null ? void 0 : a.children.find((c) => Object.prototype.hasOwnProperty.call(c, \"instanceMatrix\"))), i.value = t.mesh ?? ((l = n.value) == null ? void 0 : l.children.find((c) => c.type === \"Mesh\")), ld(i.value, t.count, s.value, t.weight, t.transform);\n    }), e({\n      samplerRef: n\n    }), (a, l) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"samplerRef\",\n      ref: n\n    }, [\n      Ne(a.$slots, \"default\")\n    ], 512));\n  }\n}), cd = new Jn.Vector3(), ud = new Jn.Vector3(), hd = new Jn.Vector3(), fd = (r, e, t) => {\n  const n = t.width / 2, s = t.height / 2;\n  e.updateMatrixWorld(!1);\n  const i = r.project(e);\n  return i.x = i.x * n + n, i.y = -(i.y * s) + s, i;\n}, dd = (r, e, t, n = 1) => {\n  const s = cd.set(r.x / t.width * 2 - 1, -(r.y / t.height) * 2 + 1, n);\n  return s.unproject(e), s;\n}, pd = (r, e, t, n) => {\n  const s = fd(hd.copy(r), t, n);\n  let i = 0;\n  for (let o = 0; o < 2; ++o) {\n    const a = ud.copy(s).setComponent(o, s.getComponent(o) + e), l = dd(a, t, n, a.z);\n    i = Math.max(i, r.distanceTo(l));\n  }\n  return i;\n}, nv = /* @__PURE__ */ ue({\n  __name: \"ScreenSizer\",\n  setup(r, { expose: e }) {\n    const t = new $(), n = re(), s = re(), i = xn().sizes, o = Pe(() => ({ width: i.width.value, height: i.height.value }));\n    return Ve().onBeforeRender(({ camera: a }) => {\n      const l = s.value;\n      if (!l)\n        return;\n      const c = pd(l.getWorldPosition(t), 1, a, o.value);\n      l.scale.setScalar(c);\n    }), e({ instance: n }), (a, l) => (ae(), ce(\"TresObject3D\", {\n      ref_key: \"outerRef\",\n      ref: n\n    }, [\n      ye(\"TresObject3D\", {\n        ref_key: \"innerRef\",\n        ref: s\n      }, [\n        Ne(a.$slots, \"default\")\n      ], 512)\n    ], 512));\n  }\n}), md = [\"color\"], sv = /* @__PURE__ */ ue({\n  __name: \"Edges\",\n  props: {\n    color: { default: \"#ff0000\" },\n    threshold: { default: 15 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { color: n, threshold: s } = Le(t), i = re(), o = me(null), a = me(1);\n    return e({\n      instance: i\n    }), J(\n      () => [i.value, s.value],\n      () => {\n        if (i.value) {\n          const l = i.value.parent;\n          if (l && \"geometry\" in l && l.geometry instanceof ht) {\n            const c = l.geometry;\n            (c !== o.value || s.value !== a.value) && (o.value = c, a.value = s.value, i.value.geometry = new Jl(c, s.value));\n          }\n        }\n      }\n    ), (l, c) => (ae(), ce(\"TresLineSegments\", $e({\n      ref_key: \"lineSegmentsRef\",\n      ref: i\n    }, l.$attrs), [\n      Ne(l.$slots, \"default\", {}, () => [\n        ye(\"TresLineBasicMaterial\", { color: F(n) }, null, 8, md)\n      ])\n    ], 16));\n  }\n}), Ys = {\n  sunset: \"venice/venice_sunset_1k.hdr\",\n  studio: \"studio/poly_haven_studio_1k.hdr\",\n  city: \"city/canary_wharf_1k.hdr\",\n  umbrellas: \"outdoor/outdoor_umbrellas_1k.hdr\",\n  night: \"outdoor/satara_night_1k.hdr\",\n  forest: \"outood/mossy_forest_1k.hdr\",\n  snow: \"outdoor/snowy_forest_path_01_1k.hdr\",\n  dawn: \"kiara/kiara_1_dawn_1k.hdr\",\n  hangar: \"indoor/small_hangar_01_1k.hdr\",\n  urban: \"indoor/abandoned_games_room_02_1k.hdr\",\n  modern: \"city/modern_buildings_2_1k.hdr\",\n  shangai: \"city/shanghai_bund_1k.hdr\"\n}, gd = \"https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/\";\nfunction Ui(r) {\n  return r instanceof vt ? r : Array.isArray(r) ? new vt(r[0], r[1], r[2]) : typeof r == \"number\" ? new vt(r, r, r) : r instanceof $ ? new vt(r.x, r.y, r.z) : typeof r == \"object\" && \"x\" in r && \"y\" in r && \"z\" in r ? new vt(r.x, r.y, r.z) : null;\n}\nfunction Or(r) {\n  r.traverse((e) => {\n    e instanceof de && e.material && (e.material.needsUpdate = !0);\n  });\n}\nasync function vd(r, e) {\n  const { scene: t, invalidate: n } = xe(), {\n    preset: s,\n    blur: i,\n    files: o = me([]),\n    path: a = me(\"\"),\n    background: l,\n    backgroundIntensity: c = me(1),\n    environmentIntensity: f = me(1),\n    backgroundRotation: u = me([0, 0, 0]),\n    environmentRotation: d = me([0, 0, 0]),\n    syncMaterials: h = me(!1)\n  } = Le(r);\n  J(r, () => {\n    n();\n  });\n  const m = me(null), g = Pe(() => Array.isArray(o.value)), v = Pe(() => g.value ? ec : wr);\n  return J([o, a], async ([p, b]) => {\n    if (p && p.length > 0 && !(s != null && s.value)) {\n      try {\n        const _ = await Nn(\n          v.value,\n          g.value ? [...F(p)] : F(p),\n          (M) => {\n            b && M.setPath(F(b));\n          }\n        );\n        m.value = Array.isArray(_) ? _[0] : _;\n      } catch (_) {\n        throw new Error(`Failed to load environment map: ${_}`);\n      }\n      m.value && (m.value.mapping = g.value ? tc : ho);\n    }\n  }, {\n    immediate: !0\n  }), J(m, (p) => {\n    t.value && p && (t.value.environment = p);\n  }, {\n    immediate: !0\n  }), J([l, m], ([p, b]) => {\n    if (t.value) {\n      const _ = e != null && e.value ? e.value.texture : b;\n      _ && (t.value.background = p ? _ : null);\n    }\n  }, {\n    immediate: !0\n  }), J(() => i == null ? void 0 : i.value, (p) => {\n    t.value && p && (t.value.backgroundBlurriness = p);\n  }, {\n    immediate: !0\n  }), J(() => c == null ? void 0 : c.value, (p) => {\n    t.value && (t.value.backgroundIntensity = p ?? 1);\n  }, {\n    immediate: !0\n  }), J(() => f == null ? void 0 : f.value, (p) => {\n    t.value && (t.value.environmentIntensity = p ?? 1);\n  }, {\n    immediate: !0\n  }), J(() => u == null ? void 0 : u.value, (p) => {\n    if (t.value) {\n      const b = Ui(p);\n      b && (t.value.backgroundRotation = b);\n    }\n  }, {\n    immediate: !0\n  }), J(() => d == null ? void 0 : d.value, (p) => {\n    if (t.value && !(h != null && h.value)) {\n      const b = Ui(p);\n      b && (t.value.environmentRotation = b, Or(t.value));\n    }\n  }, {\n    immediate: !0\n  }), J(() => s == null ? void 0 : s.value, async (p) => {\n    if (p && p in Ys) {\n      const b = gd, _ = Ys[p];\n      try {\n        const M = await Nn(\n          wr,\n          _,\n          (R) => {\n            b && R.setPath(b);\n          }\n        );\n        m.value = Array.isArray(M) ? M[0] : M;\n      } catch (M) {\n        throw new Error(`Failed to load environment map: ${M}`);\n      }\n      m.value && (m.value.mapping = ho), n();\n    } else if (p && !(p in Ys))\n      throw new Error(`Preset must be one of: ${Object.keys(Ys).join(\", \")}`);\n  }, {\n    immediate: !0\n  }), J([h, u], ([p, b]) => {\n    if (p && t.value) {\n      const _ = Ui(b);\n      _ && (t.value.environmentRotation = _, Or(t.value));\n    }\n  }, {\n    immediate: !0\n  }), m;\n}\n/*!\n * camera-controls\n * https://github.com/yomotsu/camera-controls\n * (c) 2017 @yomotsu\n * Released under the MIT License.\n */\nconst qe = {\n  LEFT: 1,\n  RIGHT: 2,\n  MIDDLE: 4\n}, Q = Object.freeze({\n  NONE: 0,\n  ROTATE: 1,\n  TRUCK: 2,\n  OFFSET: 4,\n  DOLLY: 8,\n  ZOOM: 16,\n  TOUCH_ROTATE: 32,\n  TOUCH_TRUCK: 64,\n  TOUCH_OFFSET: 128,\n  TOUCH_DOLLY: 256,\n  TOUCH_ZOOM: 512,\n  TOUCH_DOLLY_TRUCK: 1024,\n  TOUCH_DOLLY_OFFSET: 2048,\n  TOUCH_DOLLY_ROTATE: 4096,\n  TOUCH_ZOOM_TRUCK: 8192,\n  TOUCH_ZOOM_OFFSET: 16384,\n  TOUCH_ZOOM_ROTATE: 32768\n}), jn = {\n  NONE: 0,\n  IN: 1,\n  OUT: -1\n};\nfunction Pn(r) {\n  return r.isPerspectiveCamera;\n}\nfunction mn(r) {\n  return r.isOrthographicCamera;\n}\nconst Vn = Math.PI * 2, Dr = Math.PI / 2, fl = 1e-5, us = Math.PI / 180;\nfunction Ot(r, e, t) {\n  return Math.max(e, Math.min(t, r));\n}\nfunction We(r, e = fl) {\n  return Math.abs(r) < e;\n}\nfunction Fe(r, e, t = fl) {\n  return We(r - e, t);\n}\nfunction Lr(r, e) {\n  return Math.round(r / e) * e;\n}\nfunction hs(r) {\n  return isFinite(r) ? r : r < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n}\nfunction fs(r) {\n  return Math.abs(r) < Number.MAX_VALUE ? r : r * (1 / 0);\n}\nfunction Ws(r, e, t, n, s = 1 / 0, i) {\n  n = Math.max(1e-4, n);\n  const o = 2 / n, a = o * i, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);\n  let c = r - e;\n  const f = e, u = s * n;\n  c = Ot(c, -u, u), e = r - c;\n  const d = (t.value + o * c) * i;\n  t.value = (t.value - o * d) * l;\n  let h = e + (c + d) * l;\n  return f - r > 0 == h > f && (h = f, t.value = (h - f) / i), h;\n}\nfunction kr(r, e, t, n, s = 1 / 0, i, o) {\n  n = Math.max(1e-4, n);\n  const a = 2 / n, l = a * i, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);\n  let f = e.x, u = e.y, d = e.z, h = r.x - f, m = r.y - u, g = r.z - d;\n  const v = f, p = u, b = d, _ = s * n, M = _ * _, R = h * h + m * m + g * g;\n  if (R > M) {\n    const Y = Math.sqrt(R);\n    h = h / Y * _, m = m / Y * _, g = g / Y * _;\n  }\n  f = r.x - h, u = r.y - m, d = r.z - g;\n  const w = (t.x + a * h) * i, E = (t.y + a * m) * i, x = (t.z + a * g) * i;\n  t.x = (t.x - a * w) * c, t.y = (t.y - a * E) * c, t.z = (t.z - a * x) * c, o.x = f + (h + w) * c, o.y = u + (m + E) * c, o.z = d + (g + x) * c;\n  const T = v - r.x, y = p - r.y, A = b - r.z, C = o.x - v, N = o.y - p, U = o.z - b;\n  return T * C + y * N + A * U > 0 && (o.x = v, o.y = p, o.z = b, t.x = (o.x - v) / i, t.y = (o.y - p) / i, t.z = (o.z - b) / i), o;\n}\nfunction Fi(r, e) {\n  e.set(0, 0), r.forEach((t) => {\n    e.x += t.clientX, e.y += t.clientY;\n  }), e.x /= r.length, e.y /= r.length;\n}\nfunction zi(r, e) {\n  return mn(r) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;\n}\nclass yd {\n  constructor() {\n    this._listeners = {};\n  }\n  /**\n   * Adds the specified event listener.\n   * @param type event name\n   * @param listener handler function\n   * @category Methods\n   */\n  addEventListener(e, t) {\n    const n = this._listeners;\n    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);\n  }\n  /**\n   * Presence of the specified event listener.\n   * @param type event name\n   * @param listener handler function\n   * @category Methods\n   */\n  hasEventListener(e, t) {\n    const n = this._listeners;\n    return n[e] !== void 0 && n[e].indexOf(t) !== -1;\n  }\n  /**\n   * Removes the specified event listener\n   * @param type event name\n   * @param listener handler function\n   * @category Methods\n   */\n  removeEventListener(e, t) {\n    const s = this._listeners[e];\n    if (s !== void 0) {\n      const i = s.indexOf(t);\n      i !== -1 && s.splice(i, 1);\n    }\n  }\n  /**\n   * Removes all event listeners\n   * @param type event name\n   * @category Methods\n   */\n  removeAllEventListeners(e) {\n    if (!e) {\n      this._listeners = {};\n      return;\n    }\n    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);\n  }\n  /**\n   * Fire an event type.\n   * @param event DispatcherEvent\n   * @category Methods\n   */\n  dispatchEvent(e) {\n    const n = this._listeners[e.type];\n    if (n !== void 0) {\n      e.target = this;\n      const s = n.slice(0);\n      for (let i = 0, o = s.length; i < o; i++)\n        s[i].call(this, e);\n    }\n  }\n}\nvar Gi;\nconst _d = \"2.9.0\", Xs = 1 / 8, xd = /Mac/.test((Gi = globalThis == null ? void 0 : globalThis.navigator) === null || Gi === void 0 ? void 0 : Gi.platform);\nlet Te, Nr, $s, Hi, ft, Ae, Be, Yn, ds, zt, Gt, Rn, Br, Ur, St, ps, Wn, Fr, ji, zr, Vi, Yi, Zs;\nclass lt extends yd {\n  /**\n       * Injects THREE as the dependency. You can then proceed to use CameraControls.\n       *\n       * e.g\n       * ```javascript\n       * CameraControls.install( { THREE: THREE } );\n       * ```\n       *\n       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.\n       *\n       * ```js\n       * import {\n       * \tVector2,\n       * \tVector3,\n       * \tVector4,\n       * \tQuaternion,\n       * \tMatrix4,\n       * \tSpherical,\n       * \tBox3,\n       * \tSphere,\n       * \tRaycaster,\n       * \tMathUtils,\n       * } from 'three';\n       *\n       * const subsetOfTHREE = {\n       * \tVector2   : Vector2,\n       * \tVector3   : Vector3,\n       * \tVector4   : Vector4,\n       * \tQuaternion: Quaternion,\n       * \tMatrix4   : Matrix4,\n       * \tSpherical : Spherical,\n       * \tBox3      : Box3,\n       * \tSphere    : Sphere,\n       * \tRaycaster : Raycaster,\n       * };\n  \n       * CameraControls.install( { THREE: subsetOfTHREE } );\n       * ```\n       * @category Statics\n       */\n  static install(e) {\n    Te = e.THREE, Nr = Object.freeze(new Te.Vector3(0, 0, 0)), $s = Object.freeze(new Te.Vector3(0, 1, 0)), Hi = Object.freeze(new Te.Vector3(0, 0, 1)), ft = new Te.Vector2(), Ae = new Te.Vector3(), Be = new Te.Vector3(), Yn = new Te.Vector3(), ds = new Te.Vector3(), zt = new Te.Vector3(), Gt = new Te.Vector3(), Rn = new Te.Vector3(), Br = new Te.Vector3(), Ur = new Te.Vector3(), St = new Te.Spherical(), ps = new Te.Spherical(), Wn = new Te.Box3(), Fr = new Te.Box3(), ji = new Te.Sphere(), zr = new Te.Quaternion(), Vi = new Te.Quaternion(), Yi = new Te.Matrix4(), Zs = new Te.Raycaster();\n  }\n  /**\n   * list all ACTIONs\n   * @category Statics\n   */\n  static get ACTION() {\n    return Q;\n  }\n  /**\n   * Creates a `CameraControls` instance.\n   *\n   * Note:\n   * You **must install** three.js before using camera-controls. see [#install](#install)\n   * Not doing so will lead to runtime errors (`undefined` references to THREE).\n   *\n   * e.g.\n   * ```\n   * CameraControls.install( { THREE } );\n   * const cameraControls = new CameraControls( camera, domElement );\n   * ```\n   *\n   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.\n   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.\n   * @category Constructor\n   */\n  constructor(e, t) {\n    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {\n    }, this._enabled = !0, this._state = Q.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = jn.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new Te.Vector3(), this._focalOffsetVelocity = new Te.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (p, b, _) => {\n      let M, R;\n      if (Pn(this._camera)) {\n        const w = Ae.copy(this._camera.position).sub(this._target), E = this._camera.getEffectiveFOV() * us, x = w.length() * Math.tan(E * 0.5);\n        M = this.truckSpeed * p * x / this._elementRect.height, R = this.truckSpeed * b * x / this._elementRect.height;\n      } else if (mn(this._camera)) {\n        const w = this._camera;\n        M = p * (w.right - w.left) / w.zoom / this._elementRect.width, R = b * (w.top - w.bottom) / w.zoom / this._elementRect.height;\n      } else\n        return;\n      this.verticalDragToForward ? (_ ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(M, 0, !0), this.forward(-R, !0)) : _ ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y + R, this._focalOffsetEnd.z, !0) : this.truck(M, R, !0);\n    }, this._rotateInternal = (p, b) => {\n      const _ = Vn * this.azimuthRotateSpeed * p / this._elementRect.height, M = Vn * this.polarRotateSpeed * b / this._elementRect.height;\n      this.rotate(_, M, !0);\n    }, this._dollyInternal = (p, b, _) => {\n      const M = Math.pow(0.95, -p * this.dollySpeed), R = this._sphericalEnd.radius, w = this._sphericalEnd.radius * M, E = Ot(w, this.minDistance, this.maxDistance), x = E - w;\n      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(w, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(x, !0), this._dollyToNoClamp(E, !0)) : this._dollyToNoClamp(E, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? w : E) - R, this._dollyControlCoord.set(b, _)), this._lastDollyDirection = Math.sign(-p);\n    }, this._zoomInternal = (p, b, _) => {\n      const M = Math.pow(0.95, p * this.dollySpeed), R = this._zoom, w = this._zoom * M;\n      this.zoomTo(w, !0), this.dollyToCursor && (this._changedZoom += w - R, this._dollyControlCoord.set(b, _));\n    }, typeof Te > \"u\" && console.error(\"camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.\"), this._camera = e, this._yAxisUpSpace = new Te.Quaternion().setFromUnitVectors(this._camera.up, $s), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Q.NONE, this._target = new Te.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new Te.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new Te.Spherical().setFromVector3(Ae.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [\n      new Te.Vector3(),\n      new Te.Vector3(),\n      new Te.Vector3(),\n      new Te.Vector3()\n    ], this._updateNearPlaneCorners(), this._boundary = new Te.Box3(new Te.Vector3(-1 / 0, -1 / 0, -1 / 0), new Te.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Te.Vector2(), this.mouseButtons = {\n      left: Q.ROTATE,\n      middle: Q.DOLLY,\n      right: Q.TRUCK,\n      wheel: Pn(this._camera) ? Q.DOLLY : mn(this._camera) ? Q.ZOOM : Q.NONE\n    }, this.touches = {\n      one: Q.TOUCH_ROTATE,\n      two: Pn(this._camera) ? Q.TOUCH_DOLLY_TRUCK : mn(this._camera) ? Q.TOUCH_ZOOM_TRUCK : Q.NONE,\n      three: Q.TOUCH_TRUCK\n    };\n    const n = new Te.Vector2(), s = new Te.Vector2(), i = new Te.Vector2(), o = (p) => {\n      if (!this._enabled || !this._domElement)\n        return;\n      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {\n        const M = this._domElement.getBoundingClientRect(), R = p.clientX / M.width, w = p.clientY / M.height;\n        if (R < this._interactiveArea.left || R > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)\n          return;\n      }\n      const b = p.pointerType !== \"mouse\" ? null : (p.buttons & qe.LEFT) === qe.LEFT ? qe.LEFT : (p.buttons & qe.MIDDLE) === qe.MIDDLE ? qe.MIDDLE : (p.buttons & qe.RIGHT) === qe.RIGHT ? qe.RIGHT : null;\n      if (b !== null) {\n        const M = this._findPointerByMouseButton(b);\n        M && this._disposePointer(M);\n      }\n      if ((p.buttons & qe.LEFT) === qe.LEFT && this._lockedPointer)\n        return;\n      const _ = {\n        pointerId: p.pointerId,\n        clientX: p.clientX,\n        clientY: p.clientY,\n        deltaX: 0,\n        deltaY: 0,\n        mouseButton: b\n      };\n      this._activePointers.push(_), this._domElement.ownerDocument.removeEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener(\"pointerup\", l), this._domElement.ownerDocument.addEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener(\"pointerup\", l), this._isDragging = !0, d(p);\n    }, a = (p) => {\n      p.cancelable && p.preventDefault();\n      const b = p.pointerId, _ = this._lockedPointer || this._findPointerById(b);\n      if (_) {\n        if (_.clientX = p.clientX, _.clientY = p.clientY, _.deltaX = p.movementX, _.deltaY = p.movementY, this._state = 0, p.pointerType === \"touch\")\n          switch (this._activePointers.length) {\n            case 1:\n              this._state = this.touches.one;\n              break;\n            case 2:\n              this._state = this.touches.two;\n              break;\n            case 3:\n              this._state = this.touches.three;\n              break;\n          }\n        else\n          (!this._isDragging && this._lockedPointer || this._isDragging && (p.buttons & qe.LEFT) === qe.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (p.buttons & qe.MIDDLE) === qe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (p.buttons & qe.RIGHT) === qe.RIGHT && (this._state = this._state | this.mouseButtons.right);\n        h();\n      }\n    }, l = (p) => {\n      const b = this._findPointerById(p.pointerId);\n      if (!(b && b === this._lockedPointer)) {\n        if (b && this._disposePointer(b), p.pointerType === \"touch\")\n          switch (this._activePointers.length) {\n            case 0:\n              this._state = Q.NONE;\n              break;\n            case 1:\n              this._state = this.touches.one;\n              break;\n            case 2:\n              this._state = this.touches.two;\n              break;\n            case 3:\n              this._state = this.touches.three;\n              break;\n          }\n        else\n          this._state = Q.NONE;\n        m();\n      }\n    };\n    let c = -1;\n    const f = (p) => {\n      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === Q.NONE)\n        return;\n      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {\n        const w = this._domElement.getBoundingClientRect(), E = p.clientX / w.width, x = p.clientY / w.height;\n        if (E < this._interactiveArea.left || E > this._interactiveArea.right || x < this._interactiveArea.top || x > this._interactiveArea.bottom)\n          return;\n      }\n      if (p.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Q.ROTATE || this.mouseButtons.wheel === Q.TRUCK) {\n        const w = performance.now();\n        c - w < 1e3 && this._getClientRect(this._elementRect), c = w;\n      }\n      const b = xd ? -1 : -3, _ = p.deltaMode === 1 ? p.deltaY / b : p.deltaY / (b * 10), M = this.dollyToCursor ? (p.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, R = this.dollyToCursor ? (p.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\n      switch (this.mouseButtons.wheel) {\n        case Q.ROTATE: {\n          this._rotateInternal(p.deltaX, p.deltaY), this._isUserControllingRotate = !0;\n          break;\n        }\n        case Q.TRUCK: {\n          this._truckInternal(p.deltaX, p.deltaY, !1), this._isUserControllingTruck = !0;\n          break;\n        }\n        case Q.OFFSET: {\n          this._truckInternal(p.deltaX, p.deltaY, !0), this._isUserControllingOffset = !0;\n          break;\n        }\n        case Q.DOLLY: {\n          this._dollyInternal(-_, M, R), this._isUserControllingDolly = !0;\n          break;\n        }\n        case Q.ZOOM: {\n          this._zoomInternal(-_, M, R), this._isUserControllingZoom = !0;\n          break;\n        }\n      }\n      this.dispatchEvent({ type: \"control\" });\n    }, u = (p) => {\n      if (!(!this._domElement || !this._enabled)) {\n        if (this.mouseButtons.right === lt.ACTION.NONE) {\n          const b = p instanceof PointerEvent ? p.pointerId : 0, _ = this._findPointerById(b);\n          _ && this._disposePointer(_), this._domElement.ownerDocument.removeEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener(\"pointerup\", l);\n          return;\n        }\n        p.preventDefault();\n      }\n    }, d = (p) => {\n      if (!this._enabled)\n        return;\n      if (Fi(this._activePointers, ft), this._getClientRect(this._elementRect), n.copy(ft), s.copy(ft), this._activePointers.length >= 2) {\n        const _ = ft.x - this._activePointers[1].clientX, M = ft.y - this._activePointers[1].clientY, R = Math.sqrt(_ * _ + M * M);\n        i.set(0, R);\n        const w = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, E = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;\n        s.set(w, E);\n      }\n      if (this._state = 0, !p)\n        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);\n      else if (\"pointerType\" in p && p.pointerType === \"touch\")\n        switch (this._activePointers.length) {\n          case 1:\n            this._state = this.touches.one;\n            break;\n          case 2:\n            this._state = this.touches.two;\n            break;\n          case 3:\n            this._state = this.touches.three;\n            break;\n        }\n      else\n        !this._lockedPointer && (p.buttons & qe.LEFT) === qe.LEFT && (this._state = this._state | this.mouseButtons.left), (p.buttons & qe.MIDDLE) === qe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (p.buttons & qe.RIGHT) === qe.RIGHT && (this._state = this._state | this.mouseButtons.right);\n      ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & Q.ZOOM) === Q.ZOOM || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: \"controlstart\" });\n    }, h = () => {\n      if (!this._enabled || !this._dragNeedsUpdate)\n        return;\n      this._dragNeedsUpdate = !1, Fi(this._activePointers, ft);\n      const b = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, _ = b ? -b.deltaX : s.x - ft.x, M = b ? -b.deltaY : s.y - ft.y;\n      if (s.copy(ft), ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(_, M), this._isUserControllingRotate = !0), (this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.ZOOM) === Q.ZOOM) {\n        const R = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, w = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, E = this.dollyDragInverted ? -1 : 1;\n        (this._state & Q.DOLLY) === Q.DOLLY ? (this._dollyInternal(E * M * Xs, R, w), this._isUserControllingDolly = !0) : (this._zoomInternal(E * M * Xs, R, w), this._isUserControllingZoom = !0);\n      }\n      if ((this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) {\n        const R = ft.x - this._activePointers[1].clientX, w = ft.y - this._activePointers[1].clientY, E = Math.sqrt(R * R + w * w), x = i.y - E;\n        i.set(0, E);\n        const T = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, y = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\n        (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(x * Xs, T, y), this._isUserControllingDolly = !0) : (this._zoomInternal(x * Xs, T, y), this._isUserControllingZoom = !0);\n      }\n      ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._truckInternal(_, M, !1), this._isUserControllingTruck = !0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._truckInternal(_, M, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: \"control\" });\n    }, m = () => {\n      Fi(this._activePointers, ft), s.copy(ft), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener(\"pointerup\", l), this.dispatchEvent({ type: \"controlend\" }));\n    };\n    this.lockPointer = () => {\n      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {\n        pointerId: -1,\n        clientX: 0,\n        clientY: 0,\n        deltaX: 0,\n        deltaY: 0,\n        mouseButton: null\n      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener(\"pointerup\", l), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener(\"pointerlockchange\", g), this._domElement.ownerDocument.addEventListener(\"pointerlockerror\", v), this._domElement.ownerDocument.addEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener(\"pointerup\", l), d());\n    }, this.unlockPointer = () => {\n      var p, b, _;\n      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (p = this._domElement) === null || p === void 0 || p.ownerDocument.exitPointerLock(), (b = this._domElement) === null || b === void 0 || b.ownerDocument.removeEventListener(\"pointerlockchange\", g), (_ = this._domElement) === null || _ === void 0 || _.ownerDocument.removeEventListener(\"pointerlockerror\", v), this.cancel();\n    };\n    const g = () => {\n      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();\n    }, v = () => {\n      this.unlockPointer();\n    };\n    this._addAllEventListeners = (p) => {\n      this._domElement = p, this._domElement.style.touchAction = \"none\", this._domElement.style.userSelect = \"none\", this._domElement.style.webkitUserSelect = \"none\", this._domElement.addEventListener(\"pointerdown\", o), this._domElement.addEventListener(\"pointercancel\", l), this._domElement.addEventListener(\"wheel\", f, { passive: !1 }), this._domElement.addEventListener(\"contextmenu\", u);\n    }, this._removeAllEventListeners = () => {\n      this._domElement && (this._domElement.style.touchAction = \"\", this._domElement.style.userSelect = \"\", this._domElement.style.webkitUserSelect = \"\", this._domElement.removeEventListener(\"pointerdown\", o), this._domElement.removeEventListener(\"pointercancel\", l), this._domElement.removeEventListener(\"wheel\", f, { passive: !1 }), this._domElement.removeEventListener(\"contextmenu\", u), this._domElement.ownerDocument.removeEventListener(\"pointermove\", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener(\"pointerup\", l), this._domElement.ownerDocument.removeEventListener(\"pointerlockchange\", g), this._domElement.ownerDocument.removeEventListener(\"pointerlockerror\", v));\n    }, this.cancel = () => {\n      this._state !== Q.NONE && (this._state = Q.NONE, this._activePointers.length = 0, m());\n    }, t && this.connect(t), this.update(0);\n  }\n  /**\n   * The camera to be controlled\n   * @category Properties\n   */\n  get camera() {\n    return this._camera;\n  }\n  set camera(e) {\n    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;\n  }\n  /**\n   * Whether or not the controls are enabled.\n   * `false` to disable user dragging/touch-move, but all methods works.\n   * @category Properties\n   */\n  get enabled() {\n    return this._enabled;\n  }\n  set enabled(e) {\n    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = \"none\", this._domElement.style.userSelect = \"none\", this._domElement.style.webkitUserSelect = \"none\") : (this.cancel(), this._domElement.style.touchAction = \"\", this._domElement.style.userSelect = \"\", this._domElement.style.webkitUserSelect = \"\"));\n  }\n  /**\n   * Returns `true` if the controls are active updating.\n   * readonly value.\n   * @category Properties\n   */\n  get active() {\n    return !this._hasRested;\n  }\n  /**\n   * Getter for the current `ACTION`.\n   * readonly value.\n   * @category Properties\n   */\n  get currentAction() {\n    return this._state;\n  }\n  /**\n   * get/set Current distance.\n   * @category Properties\n   */\n  get distance() {\n    return this._spherical.radius;\n  }\n  set distance(e) {\n    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);\n  }\n  // horizontal angle\n  /**\n   * get/set the azimuth angle (horizontal) in radians.\n   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.\n   * @category Properties\n   */\n  get azimuthAngle() {\n    return this._spherical.theta;\n  }\n  set azimuthAngle(e) {\n    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);\n  }\n  // vertical angle\n  /**\n   * get/set the polar angle (vertical) in radians.\n   * @category Properties\n   */\n  get polarAngle() {\n    return this._spherical.phi;\n  }\n  set polarAngle(e) {\n    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);\n  }\n  /**\n   * Whether camera position should be enclosed in the boundary or not.\n   * @category Properties\n   */\n  get boundaryEnclosesCamera() {\n    return this._boundaryEnclosesCamera;\n  }\n  set boundaryEnclosesCamera(e) {\n    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;\n  }\n  /**\n   * Set drag-start, touches and wheel enable area in the domElement.\n   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.\n   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.\n   * @category Properties\n   */\n  set interactiveArea(e) {\n    this._interactiveArea.width = Ot(e.width, 0, 1), this._interactiveArea.height = Ot(e.height, 0, 1), this._interactiveArea.x = Ot(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Ot(e.y, 0, 1 - this._interactiveArea.height);\n  }\n  /**\n   * Adds the specified event listener.\n   * Applicable event types (which is `K`) are:\n   * | Event name          | Timing |\n   * | ------------------- | ------ |\n   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. Â¹ |\n   * | `'control'`         | When the user controls the camera (dragging). |\n   * | `'controlend'`      | When the user ends to control the camera. Â¹ |\n   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |\n   * | `'update'`          | When the camera position is updated. |\n   * | `'wake'`            | When the camera starts moving. |\n   * | `'rest'`            | When the camera movement is below `.restThreshold` Â². |\n   * | `'sleep'`           | When the camera end moving. |\n   *\n   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means \"start\" and \"end\" cannot be detected.\n   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).\n   *\n   * e.g.\n   * ```\n   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\n   * ```\n   * @param type event name\n   * @param listener handler function\n   * @category Methods\n   */\n  addEventListener(e, t) {\n    super.addEventListener(e, t);\n  }\n  /**\n   * Removes the specified event listener\n   * e.g.\n   * ```\n   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\n   * ```\n   * @param type event name\n   * @param listener handler function\n   * @category Methods\n   */\n  removeEventListener(e, t) {\n    super.removeEventListener(e, t);\n  }\n  /**\n   * Rotate azimuthal angle(horizontal) and polar angle(vertical).\n   * Every value is added to the current value.\n   * @param azimuthAngle Azimuth rotate angle. In radian.\n   * @param polarAngle Polar rotate angle. In radian.\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  rotate(e, t, n = !1) {\n    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);\n  }\n  /**\n   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.\n   *\n   * e.g.\n   * ```\n   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );\n   * ```\n   * @param azimuthAngle Azimuth rotate angle. In radian.\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  rotateAzimuthTo(e, t = !1) {\n    return this.rotateTo(e, this._sphericalEnd.phi, t);\n  }\n  /**\n   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.\n   *\n   * e.g.\n   * ```\n   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );\n   * ```\n   * @param polarAngle Polar rotate angle. In radian.\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  rotatePolarTo(e, t = !1) {\n    return this.rotateTo(this._sphericalEnd.theta, e, t);\n  }\n  /**\n   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.\n   * Camera view will rotate over the orbit pivot absolutely:\n   *\n   * azimuthAngle\n   * ```\n   *       0Âº\n   *         \\\n   * 90Âº -----+----- -90Âº\n   *           \\\n   *           180Âº\n   * ```\n   * | direction | angle                  |\n   * | --------- | ---------------------- |\n   * | front     | 0Âº                     |\n   * | left      | 90Âº (`Math.PI / 2`)    |\n   * | right     | -90Âº (`- Math.PI / 2`) |\n   * | back      | 180Âº (`Math.PI`)       |\n   *\n   * polarAngle\n   * ```\n   *     180Âº\n   *      |\n   *      90Âº\n   *      |\n   *      0Âº\n   * ```\n   * | direction            | angle                  |\n   * | -------------------- | ---------------------- |\n   * | top/sky              | 180Âº (`Math.PI`)       |\n   * | horizontal from view | 90Âº (`Math.PI / 2`)    |\n   * | bottom/floor         | 0Âº                     |\n   *\n   * @param azimuthAngle Azimuth rotate angle to. In radian.\n   * @param polarAngle Polar rotate angle to. In radian.\n   * @param enableTransition  Whether to move smoothly or immediately\n   * @category Methods\n   */\n  rotateTo(e, t, n = !1) {\n    this._isUserControllingRotate = !1;\n    const s = Ot(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Ot(t, this.minPolarAngle, this.maxPolarAngle);\n    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);\n    const o = !n || Fe(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fe(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);\n    return this._createOnRestPromise(o);\n  }\n  /**\n   * Dolly in/out camera position.\n   * @param distance Distance of dollyIn. Negative number for dollyOut.\n   * @param enableTransition Whether to move smoothly or immediately.\n   * @category Methods\n   */\n  dolly(e, t = !1) {\n    return this.dollyTo(this._sphericalEnd.radius - e, t);\n  }\n  /**\n   * Dolly in/out camera position to given distance.\n   * @param distance Distance of dolly.\n   * @param enableTransition Whether to move smoothly or immediately.\n   * @category Methods\n   */\n  dollyTo(e, t = !1) {\n    return this._isUserControllingDolly = !1, this._lastDollyDirection = jn.NONE, this._changedDolly = 0, this._dollyToNoClamp(Ot(e, this.minDistance, this.maxDistance), t);\n  }\n  _dollyToNoClamp(e, t = !1) {\n    const n = this._sphericalEnd.radius;\n    if (this.colliderMeshes.length >= 1) {\n      const o = this._collisionTest(), a = Fe(o, this._spherical.radius);\n      if (!(n > e) && a)\n        return Promise.resolve();\n      this._sphericalEnd.radius = Math.min(e, o);\n    } else\n      this._sphericalEnd.radius = e;\n    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);\n    const i = !t || Fe(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\n    return this._createOnRestPromise(i);\n  }\n  /**\n   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.\n   * Specify a negative value for dolly out.\n   * @param distance Distance of dolly.\n   * @param enableTransition Whether to move smoothly or immediately.\n   * @category Methods\n   */\n  dollyInFixed(e, t = !1) {\n    this._targetEnd.add(this._getCameraDirection(ds).multiplyScalar(e)), t || this._target.copy(this._targetEnd);\n    const n = !t || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold);\n    return this._createOnRestPromise(n);\n  }\n  /**\n   * Zoom in/out camera. The value is added to camera zoom.\n   * Limits set with `.minZoom` and `.maxZoom`\n   * @param zoomStep zoom scale\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  zoom(e, t = !1) {\n    return this.zoomTo(this._zoomEnd + e, t);\n  }\n  /**\n   * Zoom in/out camera to given scale. The value overwrites camera zoom.\n   * Limits set with .minZoom and .maxZoom\n   * @param zoom\n   * @param enableTransition\n   * @category Methods\n   */\n  zoomTo(e, t = !1) {\n    this._isUserControllingZoom = !1, this._zoomEnd = Ot(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);\n    const n = !t || Fe(this._zoom, this._zoomEnd, this.restThreshold);\n    return this._changedZoom = 0, this._createOnRestPromise(n);\n  }\n  /**\n   * @deprecated `pan()` has been renamed to `truck()`\n   * @category Methods\n   */\n  pan(e, t, n = !1) {\n    return console.warn(\"`pan` has been renamed to `truck`\"), this.truck(e, t, n);\n  }\n  /**\n   * Truck and pedestal camera using current azimuthal angle\n   * @param x Horizontal translate amount\n   * @param y Vertical translate amount\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  truck(e, t, n = !1) {\n    this._camera.updateMatrix(), zt.setFromMatrixColumn(this._camera.matrix, 0), Gt.setFromMatrixColumn(this._camera.matrix, 1), zt.multiplyScalar(e), Gt.multiplyScalar(-t);\n    const s = Ae.copy(zt).add(Gt), i = Be.copy(this._targetEnd).add(s);\n    return this.moveTo(i.x, i.y, i.z, n);\n  }\n  /**\n   * Move forward / backward.\n   * @param distance Amount to move forward / backward. Negative value to move backward\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  forward(e, t = !1) {\n    Ae.setFromMatrixColumn(this._camera.matrix, 0), Ae.crossVectors(this._camera.up, Ae), Ae.multiplyScalar(e);\n    const n = Be.copy(this._targetEnd).add(Ae);\n    return this.moveTo(n.x, n.y, n.z, t);\n  }\n  /**\n   * Move up / down.\n   * @param height Amount to move up / down. Negative value to move down\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  elevate(e, t = !1) {\n    return Ae.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + Ae.x, this._targetEnd.y + Ae.y, this._targetEnd.z + Ae.z, t);\n  }\n  /**\n   * Move target position to given point.\n   * @param x x coord to move center position\n   * @param y y coord to move center position\n   * @param z z coord to move center position\n   * @param enableTransition Whether to move smoothly or immediately\n   * @category Methods\n   */\n  moveTo(e, t, n, s = !1) {\n    this._isUserControllingTruck = !1;\n    const i = Ae.set(e, t, n).sub(this._targetEnd);\n    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, s || this._target.copy(this._targetEnd);\n    const o = !s || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold);\n    return this._createOnRestPromise(o);\n  }\n  /**\n   * Look in the given point direction.\n   * @param x point x.\n   * @param y point y.\n   * @param z point z.\n   * @param enableTransition Whether to move smoothly or immediately.\n   * @returns Transition end promise\n   * @category Methods\n   */\n  lookInDirectionOf(e, t, n, s = !1) {\n    const a = Ae.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);\n    return this.setPosition(a.x, a.y, a.z, s);\n  }\n  /**\n   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.\n   * set `cover: true` to fill enter screen.\n   * e.g.\n   * ```\n   * cameraControls.fitToBox( myMesh );\n   * ```\n   * @param box3OrObject Axis aligned bounding box to fit the view.\n   * @param enableTransition Whether to move smoothly or immediately.\n   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }\n   * @returns Transition end promise\n   * @category Methods\n   */\n  fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: o = 0, paddingTop: a = 0 } = {}) {\n    const l = [], c = e.isBox3 ? Wn.copy(e) : Wn.setFromObject(e);\n    c.isEmpty() && (console.warn(\"camera-controls: fitTo() cannot be used with an empty box. Aborting\"), Promise.resolve());\n    const f = Lr(this._sphericalEnd.theta, Dr), u = Lr(this._sphericalEnd.phi, Dr);\n    l.push(this.rotateTo(f, u, t));\n    const d = Ae.setFromSpherical(this._sphericalEnd).normalize(), h = zr.setFromUnitVectors(d, Hi), m = Fe(Math.abs(d.y), 1);\n    m && h.multiply(Vi.setFromAxisAngle($s, f)), h.multiply(this._yAxisUpSpaceInverse);\n    const g = Fr.makeEmpty();\n    Be.copy(c.min).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.min).setX(c.max.x).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.min).setY(c.max.y).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).setZ(c.min.z).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.min).setZ(c.max.z).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).setY(c.min.y).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).setX(c.min.x).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).applyQuaternion(h), g.expandByPoint(Be), g.min.x -= s, g.min.y -= o, g.max.x += i, g.max.y += a, h.setFromUnitVectors(Hi, d), m && h.premultiply(Vi.invert()), h.premultiply(this._yAxisUpSpace);\n    const v = g.getSize(Ae), p = g.getCenter(Be).applyQuaternion(h);\n    if (Pn(this._camera)) {\n      const b = this.getDistanceToFitBox(v.x, v.y, v.z, n);\n      l.push(this.moveTo(p.x, p.y, p.z, t)), l.push(this.dollyTo(b, t)), l.push(this.setFocalOffset(0, 0, 0, t));\n    } else if (mn(this._camera)) {\n      const b = this._camera, _ = b.right - b.left, M = b.top - b.bottom, R = n ? Math.max(_ / v.x, M / v.y) : Math.min(_ / v.x, M / v.y);\n      l.push(this.moveTo(p.x, p.y, p.z, t)), l.push(this.zoomTo(R, t)), l.push(this.setFocalOffset(0, 0, 0, t));\n    }\n    return Promise.all(l);\n  }\n  /**\n   * Fit the viewport to the sphere or the bounding sphere of the object.\n   * @param sphereOrMesh\n   * @param enableTransition\n   * @category Methods\n   */\n  fitToSphere(e, t) {\n    const n = [], i = \"isObject3D\" in e ? lt.createBoundingSphere(e, ji) : ji.copy(e);\n    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), Pn(this._camera)) {\n      const o = this.getDistanceToFitSphere(i.radius);\n      n.push(this.dollyTo(o, t));\n    } else if (mn(this._camera)) {\n      const o = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * i.radius, c = Math.min(o / l, a / l);\n      n.push(this.zoomTo(c, t));\n    }\n    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);\n  }\n  /**\n   * Look at the `target` from the `position`.\n   * @param positionX\n   * @param positionY\n   * @param positionZ\n   * @param targetX\n   * @param targetY\n   * @param targetZ\n   * @param enableTransition\n   * @category Methods\n   */\n  setLookAt(e, t, n, s, i, o, a = !1) {\n    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = jn.NONE, this._changedDolly = 0;\n    const l = Be.set(s, i, o), c = Ae.set(e, t, n);\n    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));\n    const f = !a || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold) && Fe(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fe(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Fe(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\n    return this._createOnRestPromise(f);\n  }\n  /**\n   * Similar to setLookAt, but it interpolates between two states.\n   * @param positionAX\n   * @param positionAY\n   * @param positionAZ\n   * @param targetAX\n   * @param targetAY\n   * @param targetAZ\n   * @param positionBX\n   * @param positionBY\n   * @param positionBZ\n   * @param targetBX\n   * @param targetBY\n   * @param targetBZ\n   * @param t\n   * @param enableTransition\n   * @category Methods\n   */\n  lerpLookAt(e, t, n, s, i, o, a, l, c, f, u, d, h, m = !1) {\n    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = jn.NONE, this._changedDolly = 0;\n    const g = Ae.set(s, i, o), v = Be.set(e, t, n);\n    St.setFromVector3(v.sub(g).applyQuaternion(this._yAxisUpSpace));\n    const p = Yn.set(f, u, d), b = Be.set(a, l, c);\n    ps.setFromVector3(b.sub(p).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(g.lerp(p, h));\n    const _ = ps.theta - St.theta, M = ps.phi - St.phi, R = ps.radius - St.radius;\n    this._sphericalEnd.set(St.radius + R * h, St.phi + M * h, St.theta + _ * h), this.normalizeRotations(), this._needsUpdate = !0, m || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));\n    const w = !m || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold) && Fe(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fe(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Fe(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\n    return this._createOnRestPromise(w);\n  }\n  /**\n   * Set angle and distance by given position.\n   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target\n   * @param positionX\n   * @param positionY\n   * @param positionZ\n   * @param enableTransition\n   * @category Methods\n   */\n  setPosition(e, t, n, s = !1) {\n    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);\n  }\n  /**\n   * Set the target position where gaze at.\n   * An alias of `setLookAt()`, without position change. Thus keep the same position.\n   * @param targetX\n   * @param targetY\n   * @param targetZ\n   * @param enableTransition\n   * @category Methods\n   */\n  setTarget(e, t, n, s = !1) {\n    const i = this.getPosition(Ae), o = this.setLookAt(i.x, i.y, i.z, e, t, n, s);\n    return this._sphericalEnd.phi = Ot(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;\n  }\n  /**\n   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.\n   * @param x\n   * @param y\n   * @param z\n   * @param enableTransition\n   * @category Methods\n   */\n  setFocalOffset(e, t, n, s = !1) {\n    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, s || this._focalOffset.copy(this._focalOffsetEnd);\n    const i = !s || Fe(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Fe(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Fe(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);\n    return this._createOnRestPromise(i);\n  }\n  /**\n   * Set orbit point without moving the camera.\n   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.\n   * @param targetX\n   * @param targetY\n   * @param targetZ\n   * @category Methods\n   */\n  setOrbitPoint(e, t, n) {\n    this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Gt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Rn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);\n    const s = Ae.set(e, t, n), i = s.distanceTo(this._camera.position), o = s.sub(this._camera.position);\n    zt.multiplyScalar(o.x), Gt.multiplyScalar(o.y), Rn.multiplyScalar(o.z), Ae.copy(zt).add(Gt).add(Rn), Ae.z = Ae.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Ae.x, Ae.y, -Ae.z, !1), this.moveTo(e, t, n, !1);\n  }\n  /**\n   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3\n   * @param box3\n   * @category Methods\n   */\n  setBoundary(e) {\n    if (!e) {\n      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;\n      return;\n    }\n    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;\n  }\n  /**\n   * Set (or unset) the current viewport.\n   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.\n   * @param viewportOrX\n   * @param y\n   * @param width\n   * @param height\n   * @category Methods\n   */\n  setViewport(e, t, n, s) {\n    if (e === null) {\n      this._viewport = null;\n      return;\n    }\n    this._viewport = this._viewport || new Te.Vector4(), typeof e == \"number\" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);\n  }\n  /**\n   * Calculate the distance to fit the box.\n   * @param width box width\n   * @param height box height\n   * @param depth box depth\n   * @returns distance\n   * @category Methods\n   */\n  getDistanceToFitBox(e, t, n, s = !1) {\n    if (zi(this._camera, \"getDistanceToFitBox\"))\n      return this._spherical.radius;\n    const i = e / t, o = this._camera.getEffectiveFOV() * us, a = this._camera.aspect;\n    return ((s ? i > a : i < a) ? t : e / a) * 0.5 / Math.tan(o * 0.5) + n * 0.5;\n  }\n  /**\n   * Calculate the distance to fit the sphere.\n   * @param radius sphere radius\n   * @returns distance\n   * @category Methods\n   */\n  getDistanceToFitSphere(e) {\n    if (zi(this._camera, \"getDistanceToFitSphere\"))\n      return this._spherical.radius;\n    const t = this._camera.getEffectiveFOV() * us, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;\n    return e / Math.sin(s * 0.5);\n  }\n  /**\n   * Returns the orbit center position, where the camera looking at.\n   * @param out The receiving Vector3 instance to copy the result\n   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n   * @category Methods\n   */\n  getTarget(e, t = !0) {\n    return (e && e.isVector3 ? e : new Te.Vector3()).copy(t ? this._targetEnd : this._target);\n  }\n  /**\n   * Returns the camera position.\n   * @param out The receiving Vector3 instance to copy the result\n   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n   * @category Methods\n   */\n  getPosition(e, t = !0) {\n    return (e && e.isVector3 ? e : new Te.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);\n  }\n  /**\n   * Returns the spherical coordinates of the orbit.\n   * @param out The receiving Spherical instance to copy the result\n   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n   * @category Methods\n   */\n  getSpherical(e, t = !0) {\n    return (e || new Te.Spherical()).copy(t ? this._sphericalEnd : this._spherical);\n  }\n  /**\n   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.\n   * @param out The receiving Vector3 instance to copy the result\n   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\n   * @category Methods\n   */\n  getFocalOffset(e, t = !0) {\n    return (e && e.isVector3 ? e : new Te.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);\n  }\n  /**\n   * Normalize camera azimuth angle rotation between 0 and 360 degrees.\n   * @category Methods\n   */\n  normalizeRotations() {\n    this._sphericalEnd.theta = this._sphericalEnd.theta % Vn, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Vn), this._spherical.theta += Vn * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Vn);\n  }\n  /**\n   * stop all transitions.\n   */\n  stop() {\n    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;\n  }\n  /**\n   * Reset all rotation and position to defaults.\n   * @param enableTransition\n   * @category Methods\n   */\n  reset(e = !1) {\n    if (!Fe(this._camera.up.x, this._cameraUp0.x) || !Fe(this._camera.up.y, this._cameraUp0.y) || !Fe(this._camera.up.z, this._cameraUp0.z)) {\n      this._camera.up.copy(this._cameraUp0);\n      const n = this.getPosition(Ae);\n      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);\n    }\n    const t = [\n      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),\n      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),\n      this.zoomTo(this._zoom0, e)\n    ];\n    return Promise.all(t);\n  }\n  /**\n   * Set current camera position as the default position.\n   * @category Methods\n   */\n  saveState() {\n    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);\n  }\n  /**\n   * Sync camera-up direction.\n   * When camera-up vector is changed, `.updateCameraUp()` must be called.\n   * @category Methods\n   */\n  updateCameraUp() {\n    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, $s), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();\n  }\n  /**\n   * Apply current camera-up direction to the camera.\n   * The orbit system will be re-initialized with the current position.\n   * @category Methods\n   */\n  applyCameraUp() {\n    const e = Ae.subVectors(this._target, this._camera.position).normalize(), t = Be.crossVectors(e, this._camera.up);\n    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();\n    const n = this.getPosition(Ae);\n    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);\n  }\n  /**\n   * Update camera position and directions.\n   * This should be called in your tick loop every time, and returns true if re-rendering is needed.\n   * @param delta\n   * @returns updated\n   * @category Methods\n   */\n  update(e) {\n    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = Br.subVectors(this._targetEnd, this._target), o = Ur.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;\n    if (We(t))\n      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;\n    else {\n      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;\n      this._spherical.theta = Ws(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, u, 1 / 0, e), this._needsUpdate = !0;\n    }\n    if (We(n))\n      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;\n    else {\n      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;\n      this._spherical.phi = Ws(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, u, 1 / 0, e), this._needsUpdate = !0;\n    }\n    if (We(s))\n      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;\n    else {\n      const u = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;\n      this._spherical.radius = Ws(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, u, this.maxSpeed, e), this._needsUpdate = !0;\n    }\n    if (We(i.x) && We(i.y) && We(i.z))\n      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);\n    else {\n      const u = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;\n      kr(this._target, this._targetEnd, this._targetVelocity, u, this.maxSpeed, e, this._target), this._needsUpdate = !0;\n    }\n    if (We(o.x) && We(o.y) && We(o.z))\n      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);\n    else {\n      const u = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;\n      kr(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, u, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;\n    }\n    if (We(a))\n      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;\n    else {\n      const u = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;\n      this._zoom = Ws(this._zoom, this._zoomEnd, this._zoomVelocity, u, 1 / 0, e);\n    }\n    if (this.dollyToCursor) {\n      if (Pn(this._camera) && this._changedDolly !== 0) {\n        const u = this._spherical.radius - this._lastDistance, d = this._camera, h = this._getCameraDirection(ds), m = Ae.copy(h).cross(d.up).normalize();\n        m.lengthSq() === 0 && (m.x = 1);\n        const g = Be.crossVectors(m, h), v = this._sphericalEnd.radius * Math.tan(d.getEffectiveFOV() * us * 0.5), b = (this._sphericalEnd.radius - u - this._sphericalEnd.radius) / this._sphericalEnd.radius, _ = Yn.copy(this._targetEnd).add(m.multiplyScalar(this._dollyControlCoord.x * v * d.aspect)).add(g.multiplyScalar(this._dollyControlCoord.y * v)), M = Ae.copy(this._targetEnd).lerp(_, b), R = this._lastDollyDirection === jn.IN && this._spherical.radius <= this.minDistance, w = this._lastDollyDirection === jn.OUT && this.maxDistance <= this._spherical.radius;\n        if (this.infinityDolly && (R || w)) {\n          this._sphericalEnd.radius -= u, this._spherical.radius -= u;\n          const x = Be.copy(h).multiplyScalar(-u);\n          M.add(x);\n        }\n        this._boundary.clampPoint(M, M);\n        const E = Be.subVectors(M, this._targetEnd);\n        this._targetEnd.copy(M), this._target.add(E), this._changedDolly -= u, We(this._changedDolly) && (this._changedDolly = 0);\n      } else if (mn(this._camera) && this._changedZoom !== 0) {\n        const u = this._zoom - this._lastZoom, d = this._camera, h = Ae.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (d.near + d.far) / (d.near - d.far)).unproject(d), m = Be.set(0, 0, -1).applyQuaternion(d.quaternion), g = Yn.copy(h).add(m.multiplyScalar(-h.dot(d.up))), p = -(this._zoom - u - this._zoom) / this._zoom, b = this._getCameraDirection(ds), _ = this._targetEnd.dot(b), M = Ae.copy(this._targetEnd).lerp(g, p), R = M.dot(b), w = b.multiplyScalar(R - _);\n        M.sub(w), this._boundary.clampPoint(M, M);\n        const E = Be.subVectors(M, this._targetEnd);\n        this._targetEnd.copy(M), this._target.add(E), this._changedZoom -= u, We(this._changedZoom) && (this._changedZoom = 0);\n      }\n    }\n    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;\n    const l = this._collisionTest();\n    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!We(this._focalOffset.x) || !We(this._focalOffset.y) || !We(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrix, 0), Gt.setFromMatrixColumn(this._camera.matrix, 1), Rn.setFromMatrixColumn(this._camera.matrix, 2), zt.multiplyScalar(this._focalOffset.x), Gt.multiplyScalar(-this._focalOffset.y), Rn.multiplyScalar(this._focalOffset.z), Ae.copy(zt).add(Gt).add(Rn), this._camera.position.add(Ae)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Ae.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);\n    const f = this._needsUpdate;\n    return f && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: \"wake\" }), this.dispatchEvent({ type: \"update\" })) : f ? (this.dispatchEvent({ type: \"update\" }), We(t, this.restThreshold) && We(n, this.restThreshold) && We(s, this.restThreshold) && We(i.x, this.restThreshold) && We(i.y, this.restThreshold) && We(i.z, this.restThreshold) && We(o.x, this.restThreshold) && We(o.y, this.restThreshold) && We(o.z, this.restThreshold) && We(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: \"rest\" }))) : !f && this._updatedLastTime && this.dispatchEvent({ type: \"sleep\" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = f, this._needsUpdate = !1, f;\n  }\n  /**\n   * Get all state in JSON string\n   * @category Methods\n   */\n  toJSON() {\n    return JSON.stringify({\n      enabled: this._enabled,\n      minDistance: this.minDistance,\n      maxDistance: hs(this.maxDistance),\n      minZoom: this.minZoom,\n      maxZoom: hs(this.maxZoom),\n      minPolarAngle: this.minPolarAngle,\n      maxPolarAngle: hs(this.maxPolarAngle),\n      minAzimuthAngle: hs(this.minAzimuthAngle),\n      maxAzimuthAngle: hs(this.maxAzimuthAngle),\n      smoothTime: this.smoothTime,\n      draggingSmoothTime: this.draggingSmoothTime,\n      dollySpeed: this.dollySpeed,\n      truckSpeed: this.truckSpeed,\n      dollyToCursor: this.dollyToCursor,\n      verticalDragToForward: this.verticalDragToForward,\n      target: this._targetEnd.toArray(),\n      position: Ae.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),\n      zoom: this._zoomEnd,\n      focalOffset: this._focalOffsetEnd.toArray(),\n      target0: this._target0.toArray(),\n      position0: this._position0.toArray(),\n      zoom0: this._zoom0,\n      focalOffset0: this._focalOffset0.toArray()\n    });\n  }\n  /**\n   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.\n   * @param json\n   * @param enableTransition\n   * @category Methods\n   */\n  fromJSON(e, t = !1) {\n    const n = JSON.parse(e);\n    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = fs(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = fs(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = fs(n.maxPolarAngle), this.minAzimuthAngle = fs(n.minAzimuthAngle), this.maxAzimuthAngle = fs(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), St.setFromVector3(Ae.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(St.theta, St.phi, t), this.dollyTo(St.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;\n  }\n  /**\n   * Attach all internal event handlers to enable drag control.\n   * @category Methods\n   */\n  connect(e) {\n    if (this._domElement) {\n      console.warn(\"camera-controls is already connected.\");\n      return;\n    }\n    e.setAttribute(\"data-camera-controls-version\", _d), this._addAllEventListeners(e), this._getClientRect(this._elementRect);\n  }\n  /**\n   * Detach all internal event handlers to disable drag control.\n   */\n  disconnect() {\n    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute(\"data-camera-controls-version\"), this._domElement = void 0);\n  }\n  /**\n   * Dispose the cameraControls instance itself, remove all eventListeners.\n   * @category Methods\n   */\n  dispose() {\n    this.removeAllEventListeners(), this.disconnect();\n  }\n  // it's okay to expose public though\n  _getTargetDirection(e) {\n    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);\n  }\n  // it's okay to expose public though\n  _getCameraDirection(e) {\n    return this._getTargetDirection(e).negate();\n  }\n  _findPointerById(e) {\n    return this._activePointers.find((t) => t.pointerId === e);\n  }\n  _findPointerByMouseButton(e) {\n    return this._activePointers.find((t) => t.mouseButton === e);\n  }\n  _disposePointer(e) {\n    this._activePointers.splice(this._activePointers.indexOf(e), 1);\n  }\n  _encloseToBoundary(e, t, n) {\n    const s = t.lengthSq();\n    if (s === 0)\n      return e;\n    const i = Be.copy(t).add(e), a = this._boundary.clampPoint(i, Yn).sub(i), l = a.lengthSq();\n    if (l === 0)\n      return e.add(t);\n    if (l === s)\n      return e;\n    if (n === 0)\n      return e.add(t).add(a);\n    {\n      const c = 1 + n * l / t.dot(a);\n      return e.add(Be.copy(t).multiplyScalar(c)).add(a.multiplyScalar(1 - n));\n    }\n  }\n  _updateNearPlaneCorners() {\n    if (Pn(this._camera)) {\n      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * us, s = Math.tan(n * 0.5) * t, i = s * e.aspect;\n      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);\n    } else if (mn(this._camera)) {\n      const e = this._camera, t = 1 / e.zoom, n = e.left * t, s = e.right * t, i = e.top * t, o = e.bottom * t;\n      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, o, 0), this._nearPlaneCorners[3].set(n, o, 0);\n    }\n  }\n  // lateUpdate\n  _collisionTest() {\n    let e = 1 / 0;\n    if (!(this.colliderMeshes.length >= 1) || zi(this._camera, \"_collisionTest\"))\n      return e;\n    const n = this._getTargetDirection(ds);\n    Yi.lookAt(Nr, n, this._camera.up);\n    for (let s = 0; s < 4; s++) {\n      const i = Be.copy(this._nearPlaneCorners[s]);\n      i.applyMatrix4(Yi);\n      const o = Yn.addVectors(this._target, i);\n      Zs.set(o, n), Zs.far = this._spherical.radius + 1;\n      const a = Zs.intersectObjects(this.colliderMeshes);\n      a.length !== 0 && a[0].distance < e && (e = a[0].distance);\n    }\n    return e;\n  }\n  /**\n   * Get its client rect and package into given `DOMRect` .\n   */\n  _getClientRect(e) {\n    if (!this._domElement)\n      return;\n    const t = this._domElement.getBoundingClientRect();\n    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;\n  }\n  _createOnRestPromise(e) {\n    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: \"transitionstart\" }), new Promise((t) => {\n      const n = () => {\n        this.removeEventListener(\"rest\", n), t();\n      };\n      this.addEventListener(\"rest\", n);\n    }));\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _addAllEventListeners(e) {\n  }\n  _removeAllEventListeners() {\n  }\n  /**\n   * backward compatible\n   * @deprecated use smoothTime (in seconds) instead\n   * @category Properties\n   */\n  get dampingFactor() {\n    return console.warn(\".dampingFactor has been deprecated. use smoothTime (in seconds) instead.\"), 0;\n  }\n  /**\n   * backward compatible\n   * @deprecated use smoothTime (in seconds) instead\n   * @category Properties\n   */\n  set dampingFactor(e) {\n    console.warn(\".dampingFactor has been deprecated. use smoothTime (in seconds) instead.\");\n  }\n  /**\n   * backward compatible\n   * @deprecated use draggingSmoothTime (in seconds) instead\n   * @category Properties\n   */\n  get draggingDampingFactor() {\n    return console.warn(\".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.\"), 0;\n  }\n  /**\n   * backward compatible\n   * @deprecated use draggingSmoothTime (in seconds) instead\n   * @category Properties\n   */\n  set draggingDampingFactor(e) {\n    console.warn(\".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.\");\n  }\n  static createBoundingSphere(e, t = new Te.Sphere()) {\n    const n = t, s = n.center;\n    Wn.makeEmpty(), e.traverseVisible((o) => {\n      o.isMesh && Wn.expandByObject(o);\n    }), Wn.getCenter(s);\n    let i = 0;\n    return e.traverseVisible((o) => {\n      if (!o.isMesh)\n        return;\n      const a = o, l = a.geometry.clone();\n      l.applyMatrix4(a.matrixWorld);\n      const f = l.attributes.position;\n      for (let u = 0, d = f.count; u < d; u++)\n        Ae.fromBufferAttribute(f, u), i = Math.max(i, s.distanceToSquared(Ae));\n    }), n.radius = Math.sqrt(i), n;\n  }\n}\nconst dl = (r) => !!(r && r.isPerspectiveCamera), pl = (r) => !!(r && r.isOrthographicCamera), wd = [\"min-polar-angle\", \"max-polar-angle\", \"min-azimuth-angle\", \"max-azimuth-angle\", \"distance\", \"min-distance\", \"max-distance\", \"infinity-dolly\", \"min-zoom\", \"max-zoom\", \"smooth-time\", \"dragging-smooth-time\", \"max-speed\", \"azimuth-rotate-speed\", \"polar-rotate-speed\", \"dolly-speed\", \"dolly-drag-inverted\", \"truck-speed\", \"dolly-to-cursor\", \"drag-to-offset\", \"vertical-drag-to-forward\", \"boundary-friction\", \"rest-threshold\", \"collider-meshes\", \"args\", \"mouse-buttons\", \"touches\"], Gr = (r, e) => ({\n  left: lt.ACTION.ROTATE,\n  middle: lt.ACTION.DOLLY,\n  right: lt.ACTION.TRUCK,\n  wheel: dl(r) ? lt.ACTION.DOLLY : pl(r) ? lt.ACTION.ZOOM : lt.ACTION.NONE,\n  ...e\n}), Hr = (r, e) => ({\n  one: lt.ACTION.TOUCH_ROTATE,\n  two: dl(r) ? lt.ACTION.TOUCH_DOLLY_TRUCK : pl(r) ? lt.ACTION.TOUCH_ZOOM_TRUCK : lt.ACTION.NONE,\n  three: lt.ACTION.TOUCH_TRUCK,\n  ...e\n}), iv = /* @__PURE__ */ ue({\n  __name: \"CameraControls\",\n  props: {\n    makeDefault: { type: Boolean, default: !1 },\n    camera: {},\n    domElement: {},\n    minPolarAngle: { default: 0 },\n    maxPolarAngle: { default: Math.PI },\n    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },\n    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },\n    distance: { default: () => xe().camera.value.position.z },\n    minDistance: { default: Number.EPSILON },\n    maxDistance: { default: Number.POSITIVE_INFINITY },\n    infinityDolly: { type: Boolean, default: !1 },\n    minZoom: { default: 0.01 },\n    maxZoom: { default: Number.POSITIVE_INFINITY },\n    smoothTime: { default: 0.25 },\n    draggingSmoothTime: { default: 0.125 },\n    maxSpeed: { default: Number.POSITIVE_INFINITY },\n    azimuthRotateSpeed: { default: 1 },\n    polarRotateSpeed: { default: 1 },\n    dollySpeed: { default: 1 },\n    dollyDragInverted: { type: Boolean, default: !1 },\n    truckSpeed: { default: 2 },\n    dollyToCursor: { type: Boolean, default: !1 },\n    dragToOffset: { type: Boolean, default: !1 },\n    verticalDragToForward: { type: Boolean, default: !1 },\n    boundaryFriction: { default: 0 },\n    restThreshold: { default: 0.01 },\n    colliderMeshes: { default: () => [] },\n    mouseButtons: { default: () => Gr(xe().camera.value) },\n    touches: { default: () => Hr(xe().camera.value) }\n  },\n  emits: [\"change\", \"start\", \"end\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, {\n      makeDefault: i,\n      minPolarAngle: o,\n      maxPolarAngle: a,\n      minAzimuthAngle: l,\n      maxAzimuthAngle: c,\n      distance: f,\n      minDistance: u,\n      maxDistance: d,\n      infinityDolly: h,\n      minZoom: m,\n      maxZoom: g,\n      smoothTime: v,\n      draggingSmoothTime: p,\n      maxSpeed: b,\n      azimuthRotateSpeed: _,\n      polarRotateSpeed: M,\n      dollySpeed: R,\n      dollyDragInverted: w,\n      truckSpeed: E,\n      dollyToCursor: x,\n      dragToOffset: T,\n      verticalDragToForward: y,\n      boundaryFriction: A,\n      restThreshold: C,\n      colliderMeshes: N\n    } = Le(n), U = {\n      Box3: _t,\n      MathUtils: {\n        clamp: Ye.clamp\n      },\n      Matrix4: Ie,\n      Quaternion: je,\n      Raycaster: ya,\n      Sphere: Ms,\n      Spherical: si,\n      Vector2: ve,\n      Vector3: $,\n      Vector4: at\n    };\n    lt.install({ THREE: U });\n    const { camera: Y, renderer: V, extend: ne, controls: Z, invalidate: ee } = xe();\n    J(n, () => {\n      ee();\n    });\n    const te = Pe(() => Gr(\n      n.camera || Y.value,\n      n.mouseButtons\n    )), fe = Pe(() => Hr(\n      n.camera || Y.value,\n      n.touches\n    )), he = re(null);\n    ne({ CameraControls: lt }), et(() => {\n      we(), he.value && i.value ? Z.value = he.value : Z.value = null;\n    });\n    function we() {\n      Xe(he.value, \"update\", () => {\n        s(\"change\", he.value), ee();\n      }), Xe(he.value, \"controlend\", () => s(\"end\", he.value)), Xe(he.value, \"controlstart\", () => s(\"start\", he.value));\n    }\n    const { onBeforeRender: I } = Ve();\n    return I(({ delta: B, invalidate: D }) => {\n      var O, z;\n      (O = he.value) != null && O.enabled && ((z = he.value) == null || z.update(B), D());\n    }), tt(() => {\n      he.value && he.value.disconnect();\n    }), e({\n      instance: he\n    }), (B, D) => (B.camera || F(Y)) && (B.domElement || F(V)) ? (ae(), ce(\"TresCameraControls\", {\n      key: 0,\n      ref_key: \"controlsRef\",\n      ref: he,\n      \"min-polar-angle\": F(o),\n      \"max-polar-angle\": F(a),\n      \"min-azimuth-angle\": F(l),\n      \"max-azimuth-angle\": F(c),\n      distance: F(f),\n      \"min-distance\": F(u),\n      \"max-distance\": F(d),\n      \"infinity-dolly\": F(h),\n      \"min-zoom\": F(m),\n      \"max-zoom\": F(g),\n      \"smooth-time\": F(v),\n      \"dragging-smooth-time\": F(p),\n      \"max-speed\": F(b),\n      \"azimuth-rotate-speed\": F(_),\n      \"polar-rotate-speed\": F(M),\n      \"dolly-speed\": F(R),\n      \"dolly-drag-inverted\": F(w),\n      \"truck-speed\": F(E),\n      \"dolly-to-cursor\": F(x),\n      \"drag-to-offset\": F(T),\n      \"vertical-drag-to-forward\": F(y),\n      \"boundary-friction\": F(A),\n      \"rest-threshold\": F(C),\n      \"collider-meshes\": F(N),\n      args: [B.camera || F(Y), B.domElement || F(V).domElement],\n      \"mouse-buttons\": te.value,\n      touches: fe.value\n    }, null, 8, wd)) : an(\"\", !0);\n  }\n}), ov = /* @__PURE__ */ ue({\n  __name: \"KeyboardControls\",\n  props: {\n    makeDefault: { type: Boolean, default: !0 },\n    camera: {},\n    domElement: {},\n    moveSpeed: { default: 0.2 },\n    selector: {}\n  },\n  emits: [\"isLock\", \"change\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, { moveSpeed: i } = Le(n), { camera: o, controls: a, renderer: l, invalidate: c } = xe();\n    J(n, () => {\n      c();\n    });\n    const f = me(0), u = me(0), { KeyW: d, KeyA: h, KeyS: m, KeyD: g, Up: v, Down: p, Left: b, Right: _ } = eu();\n    et(() => {\n      h.value || b.value ? f.value = -i.value : g.value || _.value ? f.value = i.value : f.value = 0, d.value || v.value ? u.value = i.value : m.value || p.value ? u.value = -i.value : u.value = 0;\n    }), e({\n      instance: a\n    });\n    const M = (A) => s(\"isLock\", A), R = (A) => s(\"change\", A), w = new $(), E = new $(), x = new je(), T = (A, C) => {\n      var Y;\n      if (!((Y = o.value) != null && Y.position) && !w)\n        return;\n      const N = o.value, U = A * 1e-3;\n      N == null || N.translateZ(-C), x.set(E.x * U, E.y * U, E.z * U, 1).normalize(), N == null || N.quaternion.multiply(x), (f.value || u.value) && s(\"change\", a.value);\n    }, { onBeforeRender: y } = Ve();\n    return y(({ delta: A, invalidate: C }) => {\n      var N;\n      a.value instanceof qa && ((N = a.value) != null && N.isLocked) && (T(A, u.value), a.value.moveRight(f.value), C());\n    }), (A, C) => (ae(), Oo(F(Md), {\n      selector: A.selector,\n      \"make-default\": A.makeDefault,\n      camera: A.camera || F(o),\n      \"dom-element\": A.domElement || F(l).domElement,\n      onIsLock: M,\n      onChange: R\n    }, null, 8, [\"selector\", \"make-default\", \"camera\", \"dom-element\"]));\n  }\n}), Td = [\"args\", \"auto-rotate\", \"auto-rotate-speed\", \"enable-damping\", \"damping-factor\", \"enable-pan\", \"key-pan-speed\", \"keys\", \"max-azimuth-angle\", \"min-azimuth-angle\", \"max-polar-angle\", \"min-polar-angle\", \"min-distance\", \"max-distance\", \"min-zoom\", \"max-zoom\", \"enable-zoom\", \"zoom-speed\", \"enable-rotate\", \"rotate-speed\"], rv = /* @__PURE__ */ ue({\n  __name: \"MapControls\",\n  props: {\n    makeDefault: { type: Boolean, default: !1 },\n    camera: {},\n    domElement: {},\n    target: {},\n    enableDamping: { type: Boolean, default: !0 },\n    dampingFactor: { default: 0.05 },\n    autoRotate: { type: Boolean, default: !1 },\n    autoRotateSpeed: { default: 2 },\n    enablePan: { type: Boolean, default: !0 },\n    keyPanSpeed: { default: 7 },\n    keys: {},\n    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },\n    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },\n    maxPolarAngle: { default: Math.PI },\n    minPolarAngle: { default: 0 },\n    minDistance: { default: 0 },\n    maxDistance: { default: Number.POSITIVE_INFINITY },\n    minZoom: { default: 0 },\n    maxZoom: { default: Number.POSITIVE_INFINITY },\n    touches: {},\n    enableZoom: { type: Boolean, default: !0 },\n    zoomSpeed: { default: 1 },\n    enableRotate: { type: Boolean, default: !0 },\n    rotateSpeed: { default: 1 }\n  },\n  emits: [\"change\", \"start\", \"end\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, {\n      autoRotate: s,\n      autoRotateSpeed: i,\n      enableDamping: o,\n      dampingFactor: a,\n      enablePan: l,\n      keyPanSpeed: c,\n      maxAzimuthAngle: f,\n      minAzimuthAngle: u,\n      maxPolarAngle: d,\n      minPolarAngle: h,\n      minDistance: m,\n      maxDistance: g,\n      minZoom: v,\n      maxZoom: p,\n      enableZoom: b,\n      zoomSpeed: _,\n      enableRotate: M,\n      rotateSpeed: R\n    } = Le(n), { camera: w, renderer: E, extend: x, controls: T, invalidate: y } = xe();\n    J(n, () => {\n      y();\n    });\n    const A = re(null);\n    x({ MapControls: yh }), J(T, (N) => {\n      N && n.makeDefault ? T.value = N : T.value = null;\n    });\n    const { onBeforeRender: C } = Ve();\n    return C(({ invalidate: N }) => {\n      A.value && (o.value || s.value) && (A.value.update(), N());\n    }), tt(() => {\n      A.value && A.value.dispose();\n    }), e({\n      instance: A\n    }), (N, U) => (N.camera || F(w)) && (N.domElement || F(E)) ? (ae(), ce(\"TresMapControls\", {\n      key: 0,\n      ref_key: \"controlsRef\",\n      ref: A,\n      args: [N.camera || F(w), N.domElement || F(E).domElement],\n      \"auto-rotate\": F(s),\n      \"auto-rotate-speed\": F(i),\n      \"enable-damping\": F(o),\n      \"damping-factor\": F(a),\n      \"enable-pan\": F(l),\n      \"key-pan-speed\": F(c),\n      keys: N.keys,\n      \"max-azimuth-angle\": F(f),\n      \"min-azimuth-angle\": F(u),\n      \"max-polar-angle\": F(d),\n      \"min-polar-angle\": F(h),\n      \"min-distance\": F(m),\n      \"max-distance\": F(g),\n      \"min-zoom\": F(v),\n      \"max-zoom\": F(p),\n      \"enable-zoom\": F(b),\n      \"zoom-speed\": F(_),\n      \"enable-rotate\": F(M),\n      \"rotate-speed\": F(R)\n    }, null, 8, Td)) : an(\"\", !0);\n  }\n}), bd = [\"target\", \"auto-rotate\", \"auto-rotate-speed\", \"enable-damping\", \"damping-factor\", \"enable-pan\", \"key-pan-speed\", \"keys\", \"max-azimuth-angle\", \"min-azimuth-angle\", \"max-polar-angle\", \"min-polar-angle\", \"min-distance\", \"max-distance\", \"min-zoom\", \"max-zoom\", \"touches\", \"enable-zoom\", \"zoom-speed\", \"enable-rotate\", \"rotate-speed\", \"mouse-buttons\", \"args\"], av = /* @__PURE__ */ ue({\n  __name: \"OrbitControls\",\n  props: {\n    makeDefault: { type: Boolean, default: !1 },\n    camera: {},\n    domElement: {},\n    target: { default: () => [0, 0, 0] },\n    enableDamping: { type: Boolean, default: !0 },\n    dampingFactor: { default: 0.05 },\n    autoRotate: { type: Boolean, default: !1 },\n    autoRotateSpeed: { default: 2 },\n    enablePan: { type: Boolean, default: !0 },\n    keyPanSpeed: { default: 7 },\n    keys: {},\n    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },\n    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },\n    maxPolarAngle: { default: Math.PI },\n    minPolarAngle: { default: 0 },\n    minDistance: { default: 0 },\n    maxDistance: { default: Number.POSITIVE_INFINITY },\n    minZoom: { default: 0 },\n    maxZoom: { default: Number.POSITIVE_INFINITY },\n    touches: { default: () => ({ ONE: Vt.ROTATE, TWO: Vt.DOLLY_PAN }) },\n    enableZoom: { type: Boolean, default: !0 },\n    zoomSpeed: { default: 1 },\n    enableRotate: { type: Boolean, default: !0 },\n    rotateSpeed: { default: 1 },\n    mouseButtons: { default: () => ({ LEFT: Dt.ROTATE, MIDDLE: Dt.DOLLY, RIGHT: Dt.PAN }) }\n  },\n  emits: [\"change\", \"start\", \"end\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, {\n      makeDefault: i,\n      autoRotate: o,\n      autoRotateSpeed: a,\n      enableDamping: l,\n      dampingFactor: c,\n      enablePan: f,\n      keyPanSpeed: u,\n      maxAzimuthAngle: d,\n      minAzimuthAngle: h,\n      maxPolarAngle: m,\n      minPolarAngle: g,\n      minDistance: v,\n      maxDistance: p,\n      minZoom: b,\n      maxZoom: _,\n      enableZoom: M,\n      zoomSpeed: R,\n      enableRotate: w,\n      touches: E,\n      rotateSpeed: x,\n      target: T,\n      mouseButtons: y\n    } = Le(n), { camera: A, renderer: C, extend: N, controls: U, invalidate: Y } = xe(), V = re(null);\n    N({ OrbitControls: Qa }), J(V, (ee) => {\n      ne(), ee && i.value ? U.value = ee : U.value = null;\n    });\n    function ne() {\n      Xe(V.value, \"change\", () => {\n        s(\"change\", V.value), Y();\n      }), Xe(V.value, \"start\", () => s(\"start\", V.value)), Xe(V.value, \"end\", () => s(\"end\", V.value));\n    }\n    const { onBeforeRender: Z } = Ve();\n    return Z(({ invalidate: ee }) => {\n      V.value && (l.value || o.value) && (V.value.update(), o.value && ee());\n    }), tt(() => {\n      V.value && V.value.dispose();\n    }), e({ instance: V }), (ee, te) => (ee.camera || F(A)) && (ee.domElement || F(C)) ? (ae(), ce(\"TresOrbitControls\", {\n      key: 0,\n      ref_key: \"controlsRef\",\n      ref: V,\n      target: F(T),\n      \"auto-rotate\": F(o),\n      \"auto-rotate-speed\": F(a),\n      \"enable-damping\": F(l),\n      \"damping-factor\": F(c),\n      \"enable-pan\": F(f),\n      \"key-pan-speed\": F(u),\n      keys: ee.keys,\n      \"max-azimuth-angle\": F(d),\n      \"min-azimuth-angle\": F(h),\n      \"max-polar-angle\": F(m),\n      \"min-polar-angle\": F(g),\n      \"min-distance\": F(v),\n      \"max-distance\": F(p),\n      \"min-zoom\": F(b),\n      \"max-zoom\": F(_),\n      touches: F(E),\n      \"enable-zoom\": F(M),\n      \"zoom-speed\": F(R),\n      \"enable-rotate\": F(w),\n      \"rotate-speed\": F(x),\n      \"mouse-buttons\": F(y),\n      args: [ee.camera || F(A), ee.domElement || F(C).domElement]\n    }, null, 8, bd)) : an(\"\", !0);\n  }\n}), Ed = [\"args\"], Md = /* @__PURE__ */ ue({\n  __name: \"PointerLockControls\",\n  props: {\n    makeDefault: { type: Boolean, default: !1 },\n    camera: {},\n    domElement: {},\n    selector: {}\n  },\n  emits: [\"isLock\", \"change\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, { camera: i, renderer: o, extend: a, controls: l, invalidate: c } = xe();\n    J(n, () => {\n      c();\n    });\n    const f = re(null);\n    let u;\n    a({ PointerLockControls: qa });\n    const d = (h) => {\n      s(\"isLock\", h);\n    };\n    return J(f, (h) => {\n      h && n.makeDefault ? l.value = h : l.value = null, u = document.getElementById(n.selector || \"\") || o.value.domElement, Xe(u, \"click\", () => {\n        f.value && (f.value.lock(), f.value.addEventListener(\"lock\", () => d(!0)), f.value.addEventListener(\"unlock\", () => d(!1)), c());\n      });\n    }), tt(() => {\n      const h = f.value;\n      h && (h.removeEventListener(\"lock\", () => d(!0)), h.removeEventListener(\"unlock\", () => d(!1)), h.dispose());\n    }), e({\n      instance: l\n    }), (h, m) => (h.camera || F(i)) && (h.domElement || F(o)) ? (ae(), ce(\"TresPointerLockControls\", {\n      key: 0,\n      ref_key: \"controlsRef\",\n      ref: f,\n      args: [h.camera || F(i), h.domElement || F(o).domElement]\n    }, null, 8, Ed)) : an(\"\", !0);\n  }\n}), lv = /* @__PURE__ */ ue({\n  __name: \"ScrollControls\",\n  props: {\n    pages: { default: 4 },\n    distance: { default: 4 },\n    smoothScroll: { default: 0.1 },\n    horizontal: { type: Boolean, default: !1 },\n    htmlScroll: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, { logWarning: i } = xt();\n    n.smoothScroll < 0 && i(\"SmoothControl must be greater than zero\"), n.pages < 0 && i(\"Pages must be greater than zero\");\n    const { camera: o, controls: a, renderer: l, invalidate: c } = xe();\n    J(n, () => {\n      c();\n    });\n    const f = re(), u = document.createElement(\"div\"), { y: d } = su(), { x: h, y: m, isScrolling: g } = Qc(u), { height: v, width: p } = Na();\n    let b = 0;\n    const _ = me(!1), M = me(0), R = me(0), w = me(0), E = n.horizontal ? \"x\" : \"y\", x = J(\n      o,\n      (y) => {\n        if (_.value) {\n          x();\n          return;\n        }\n        b = n.horizontal ? (y == null ? void 0 : y.position.x) || 0 : (y == null ? void 0 : y.position.y) || 0, _.value = !0;\n      },\n      {\n        immediate: !0\n      }\n    );\n    J(\n      g,\n      (y) => {\n        a.value && (a.value.enabled = !y);\n      },\n      {\n        immediate: !0\n      }\n    ), J(d, (y) => {\n      !g.value && !n.htmlScroll || (R.value = y / v.value / (w.value / v.value - 1), M.value = -1 * R.value, s(\"update:modelValue\", R.value));\n    }), J(m, (y) => {\n      R.value = y / v.value / (w.value / v.value), M.value = -1 * R.value, s(\"update:modelValue\", R.value);\n    }), J(h, (y) => {\n      R.value = y / p.value / (w.value / p.value - 1), M.value = +R.value, s(\"update:modelValue\", R.value);\n    }), J(\n      l,\n      (y) => {\n        var C, N;\n        const A = y == null ? void 0 : y.domElement;\n        if (n.htmlScroll && (y != null && y.domElement))\n          A != null && A.style.width && (A != null && A.style.position) && (A != null && A.style.top) && (A != null && A.style.left) && (A.style.width = \"100%\", A.style.position = \"fixed\", A.style.zIndex = \" -99999\", A.style.top = \"0\", A.style.left = \"0\"), w.value = document.body.scrollHeight;\n        else {\n          const U = document.createElement(\"div\"), Y = document.createElement(\"div\");\n          u.style[n.horizontal ? \"overflowX\" : \"overflowY\"] = \"auto\", u.style[n.horizontal ? \"overflowY\" : \"overflowX\"] = \"hidden\", u.style.position = \"absolute\", u.style.width = \"100%\", u.style.height = \" 100%\", u.style.top = \"0\", u.style.left = \"0\", u.classList.add(\"scrollContainer\"), U.style.position = \"sticky\", U.style.top = \"0px\", U.style.left = \"0px\", U.style.width = \"100%\", U.style.height = \"100%\", U.style.overflow = \"hidden\", u.appendChild(U), Y.style.height = n.horizontal ? \"100%\" : `${v.value * n.pages}px`, Y.style.width = n.horizontal ? `${p.value * n.pages}px` : \"100vw\", Y.style.pointerEvents = \"none\", A.style.position = \"fixed\", A.style.zIndex = \"0\", A != null && A.style.width && (A.style.width = \"100%\"), u.appendChild(Y), y != null && y.domElement.parentNode && (y.domElement.parentNode.style.position = \"relative\"), (N = (C = y == null ? void 0 : y.domElement) == null ? void 0 : C.parentNode) == null || N.appendChild(u), w.value = n.horizontal ? p.value * n.pages : v.value * n.pages;\n        }\n      },\n      {\n        immediate: !0\n      }\n    );\n    const { onBeforeRender: T } = Ve();\n    return T(({ invalidate: y }) => {\n      var A;\n      if ((A = o.value) != null && A.position) {\n        const C = (M.value * n.distance - o.value.position[E] + b) * n.smoothScroll;\n        o.value.position[E] += C, f.value.children.length > 0 && (f.value.position[E] += C), y();\n      }\n    }), e({\n      instance: f\n    }), (y, A) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"wrapperRef\",\n      ref: f\n    }, [\n      Ne(y.$slots, \"default\")\n    ], 512));\n  }\n}), Sd = [\"object\", \"args\", \"mode\", \"enabled\", \"axis\", \"translation-snap\", \"rotation-snap\", \"scale-snap\", \"space\", \"size\", \"show-x\", \"show-y\", \"show-z\"], cv = /* @__PURE__ */ ue({\n  __name: \"TransformControls\",\n  props: {\n    object: {},\n    camera: {},\n    mode: { default: \"translate\" },\n    enabled: { type: Boolean, default: !0 },\n    axis: { default: \"XYZ\" },\n    translationSnap: {},\n    rotationSnap: {},\n    scaleSnap: {},\n    space: { default: \"world\" },\n    size: { default: 1 },\n    showX: { type: Boolean, default: !0 },\n    showY: { type: Boolean, default: !0 },\n    showZ: { type: Boolean, default: !0 }\n  },\n  emits: [\"dragging\", \"change\", \"mouseDown\", \"mouseUp\", \"objectChange\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, { object: i, mode: o, enabled: a, axis: l, translationSnap: c, rotationSnap: f, scaleSnap: u, space: d, size: h, showX: m, showY: g, showZ: v } = Le(n), p = re(null), { controls: b, camera: _, renderer: M, extend: R, invalidate: w } = xe();\n    J([i, o, a, l, c, f, u, d, h, m, g, v], () => {\n      w();\n    }), R({ TransformControls: ah });\n    const E = () => {\n      w(), s(\"change\");\n    }, x = (N) => {\n      b.value && (b.value.enabled = !N.value), w(), s(\"dragging\", N.value);\n    }, T = () => {\n      w(), s(\"mouseDown\");\n    }, y = () => {\n      w(), s(\"mouseDown\");\n    }, A = () => {\n      w(), s(\"objectChange\");\n    };\n    function C() {\n      Xe(p.value, \"change\", E), Xe(p.value, \"dragging-changed\", x), Xe(p.value, \"mouseDown\", T), Xe(p.value, \"mouseUp\", y), Xe(p.value, \"objectChange\", A);\n    }\n    return J(p, (N) => {\n      N && C();\n    }), tt(() => {\n      p.value && p.value.dispose();\n    }), e({\n      instance: p\n    }), (N, U) => {\n      var Y;\n      return (N.camera || F(_)) && F(M) ? (ae(), ce(\"TresTransformControls\", {\n        ref_key: \"controlsRef\",\n        ref: p,\n        key: (Y = N.camera || F(_)) == null ? void 0 : Y.uuid,\n        object: F(i),\n        args: [N.camera || F(_), F(M).domElement],\n        mode: F(o),\n        enabled: F(a),\n        axis: F(l),\n        \"translation-snap\": F(c),\n        \"rotation-snap\": F(f),\n        \"scale-snap\": F(u),\n        space: F(d),\n        size: F(h),\n        \"show-x\": F(m),\n        \"show-y\": F(g),\n        \"show-z\": F(v),\n        visible: !0\n      }, null, 8, Sd)) : an(\"\", !0);\n    };\n  }\n}), Ad = [\"geometry\", \"render-order\"], uv = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    src: {},\n    skipStrokes: { type: Boolean, default: !1 },\n    skipFills: { type: Boolean, default: !1 },\n    fillMaterial: {},\n    strokeMaterial: {},\n    fillMeshProps: {},\n    strokeMeshProps: {},\n    depth: { default: \"renderOrder\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r;\n    class n extends _s {\n      load(_, M, R, w) {\n        const E = Array.isArray(_) ? _[0] : _;\n        super.load(E, M, R, w);\n      }\n    }\n    const { src: s, skipStrokes: i, skipFills: o, fillMaterial: a, strokeMaterial: l, fillMeshProps: c, strokeMeshProps: f, depth: u } = Le(t), d = re(), h = re([]), m = re([]);\n    e({ instance: d }), et(async () => g(s.value).then((b) => m.value = b.paths)), J([o, i, a, l, m], p);\n    async function g(b) {\n      const _ = b.startsWith(\"<svg\") ? encodeURI(`data:image/svg+xml;utf8,${b}`) : b;\n      return Nn(n, _);\n    }\n    tt(v);\n    function v() {\n      h.value.forEach((b) => b.geometry.dispose());\n    }\n    function p() {\n      var w, E, x;\n      v();\n      const b = [], [_, M] = (() => {\n        const T = { flat: !1, renderOrder: !1, offsetZ: !0 }, y = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, A = u.value;\n        return typeof A == \"number\" ? [!0, A] : [T[A], y[A]];\n      })();\n      let R = 0;\n      for (const T of m.value) {\n        const y = ((w = T.userData) == null ? void 0 : w.style) ?? {}, A = Object.assign({\n          color: y.fill,\n          opacity: y.fillOpacity,\n          transparent: !0,\n          side: on,\n          depthWrite: _\n        }, t.fillMaterial);\n        if (!o.value && y.fill !== void 0 && y.fill !== \"none\")\n          for (const C of _s.createShapes(T)) {\n            const N = new nc(C);\n            N.scale(1, -1, 1), M && N.translate(0, 0, R++ * M), b.push({\n              geometry: N,\n              material: A,\n              isStroke: !1\n            });\n          }\n        if (!i.value && y.stroke !== void 0 && y.stroke !== \"none\") {\n          const C = Object.assign({\n            color: (E = T.userData) == null ? void 0 : E.style.stroke,\n            opacity: (x = T.userData) == null ? void 0 : x.style.strokeOpacity,\n            transparent: !0,\n            side: on,\n            depthWrite: _\n          }, t.strokeMaterial);\n          for (const N of T.subPaths) {\n            const U = N.getPoints().map((V) => new ve(V.x, -V.y)), Y = _s.pointsToStroke(U, y || \"none\");\n            M && Y.translate(0, 0, R++ * M), b.push({\n              geometry: Y,\n              material: C,\n              isStroke: !0\n            });\n          }\n        }\n      }\n      h.value = b;\n    }\n    return (b, _) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"svgRef\",\n      ref: d\n    }, [\n      (ae(!0), ce(Ra, null, Ca(h.value, ({ geometry: M, material: R, isStroke: w }, E) => (ae(), ce(\"TresMesh\", $e({\n        key: `${E}`,\n        ref_for: !0\n      }, w ? F(f) : F(c), {\n        geometry: M,\n        \"render-order\": F(u) === \"renderOrder\" ? E : 0\n      }), [\n        ye(\"TresMeshBasicMaterial\", $e({ ref_for: !0 }, R), null, 16)\n      ], 16, Ad))), 128))\n    ], 512));\n  }\n});\nclass Pd extends Un {\n  constructor(t) {\n    super(t);\n    pe(this, \"fbxLoader\");\n    this.fbxLoader = new ff(t);\n  }\n  /**\n   * Load an FBX model from a URL or array of URLs.\n   * If an array is provided, only the first URL will be used.\n   *\n   * @param {(string | string[])} url - URL or array of URLs to load\n   * @param {(result: Group) => void} onLoad - Callback when the model is loaded\n   * @param {(event: ProgressEvent<EventTarget>) => void} [onProgress] - Loading progress callback\n   * @param {(event: ErrorEvent) => void} [onError] - Error callback\n   */\n  load(t, n, s, i) {\n    const o = Array.isArray(t) ? t[0] : t;\n    this.fbxLoader.load(o, n, s, i);\n  }\n  /**\n   * Asynchronously load an FBX model.\n   *\n   * @param {string | string[]} url - URL or array of URLs to load\n   * @returns {Promise<Group>} Promise that resolves with the loaded model\n   */\n  async loadAsync(t) {\n    const n = Array.isArray(t) ? t[0] : t;\n    return this.fbxLoader.loadAsync(n);\n  }\n}\nconst Rd = Pd;\nasync function Cd(r) {\n  return await Nn(Rd, r);\n}\nconst Id = [\"object\"], hv = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    path: {},\n    castShadow: { type: Boolean, default: !1 },\n    receiveShadow: { type: Boolean, default: !1 }\n  },\n  async setup(r, { expose: e }) {\n    let t, n;\n    const s = r, i = me();\n    e({\n      instance: i\n    });\n    const o = ([t, n] = Tn(() => Cd(s.path)), t = await t, n(), t);\n    return (s.castShadow || s.receiveShadow) && o.traverse((a) => {\n      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);\n    }), (a, l) => (ae(), ce(\"primitive\", $e({\n      ref_key: \"modelRef\",\n      ref: i,\n      object: F(o)\n    }, a.$attrs), null, 16, Id));\n  }\n});\nclass Od extends Un {\n  constructor(t) {\n    super(t);\n    pe(this, \"gltfLoader\");\n    this.gltfLoader = new xh(t);\n  }\n  /**\n   * Load a GLTF model from a URL or array of URLs.\n   * If an array is provided, only the first URL will be used.\n   *\n   * @param {(string | string[])} url - URL or array of URLs to load\n   * @param {(result: GLTF) => void} onLoad - Callback when the model is loaded\n   * @param {(event: ProgressEvent<EventTarget>) => void} [onProgress] - Loading progress callback\n   * @param {(event: ErrorEvent) => void} [onError] - Error callback\n   */\n  load(t, n, s, i) {\n    const o = Array.isArray(t) ? t[0] : t;\n    this.gltfLoader.load(o, n, s, i);\n  }\n  /**\n   * Asynchronously load a GLTF model.\n   *\n   * @param {string | string[]} url - URL or array of URLs to load\n   * @returns {Promise<GLTF>} Promise that resolves with the loaded model\n   */\n  async loadAsync(t) {\n    const n = Array.isArray(t) ? t[0] : t;\n    return this.gltfLoader.loadAsync(n);\n  }\n  /**\n   * Set the DRACO loader for compressed models.\n   *\n   * @param {DRACOLoader} dracoLoader - The DRACO loader instance\n   * @returns {GLTFLoader} The loader instance for chaining\n   */\n  setDRACOLoader(t) {\n    return this.gltfLoader.setDRACOLoader(t);\n  }\n}\nconst Dd = Od;\nlet yn = null;\nfunction Ld(r, e) {\n  return (t) => {\n    e && e(t), r.draco && (yn || (yn = new Cf()), yn.setDecoderPath(r.decoderPath || \"https://www.gstatic.com/draco/versioned/decoders/1.4.3/\"), t.setDRACOLoader && t.setDRACOLoader(yn));\n  };\n}\nasync function kd(r, e = {\n  draco: !1\n}, t) {\n  const n = await Nn(Dd, r, Ld(e, t));\n  return yn == null || yn.dispose(), yn = null, n;\n}\nconst Nd = [\"object\"], fv = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    path: {},\n    draco: { type: Boolean, default: !1 },\n    decoderPath: { default: \"https://www.gstatic.com/draco/versioned/decoders/1.4.1/\" },\n    castShadow: { type: Boolean, default: !1 },\n    receiveShadow: { type: Boolean, default: !1 }\n  },\n  async setup(r, { expose: e }) {\n    let t, n;\n    const s = r, i = me();\n    e({\n      instance: i\n    });\n    const { scene: o } = ([t, n] = Tn(() => kd(s.path, {\n      draco: s.draco,\n      decoderPath: s.decoderPath\n    })), t = await t, n(), t);\n    return (s.castShadow || s.receiveShadow) && o.traverse((a) => {\n      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);\n    }), (a, l) => (ae(), ce(\"primitive\", $e({\n      ref_key: \"modelRef\",\n      ref: i,\n      object: F(o)\n    }, a.$attrs), null, 16, Nd));\n  }\n}), ml = \"[TresJS - Cientos â–² â–  â™¥] \";\nfunction Bd(r, e) {\n  console.error(`${ml} ${r}`, e || \"\");\n}\nfunction Ud(r) {\n  console.warn(`${ml} ${r}`);\n}\nfunction Fd(r, e) {\n}\nfunction gl() {\n  return {\n    logError: Bd,\n    logWarning: Ud,\n    logMessage: Fd\n  };\n}\nlet Wi = 0;\nfunction dv() {\n  const r = me(!1), e = me(0), t = me([]), { logError: n } = gl();\n  return new Promise((s) => {\n    ks.onStart = () => {\n      r.value = !1;\n    }, ks.onLoad = () => {\n      r.value = !0;\n    }, ks.onProgress = (i, o, a) => {\n      o === a && (Wi = a, r.value = !0, t.value.push(i)), e.value = Math.round((o - Wi) / (a - Wi) * 100 || 100);\n    }, ks.onError = (i) => {\n      n(\"Error loading assets\", new Error(i)), r.value = !0;\n    }, s({\n      items: t,\n      hasFinishLoading: r,\n      progress: e\n    });\n  });\n}\nasync function pv(r, e) {\n  const { logError: t } = gl();\n  if (!r)\n    return t(\"Error no path provided\");\n  const { unsuspend: n, start: s, crossOrigin: i, muted: o, loop: a, ...l } = {\n    unsuspend: \"loadedmetadata\",\n    crossOrigin: \"Anonymous\",\n    muted: !0,\n    loop: !0,\n    start: !0,\n    playsInline: !0,\n    ...e\n  };\n  function c() {\n    return new Promise((f, u) => {\n      const d = Object.assign(document.createElement(\"video\"), {\n        src: typeof r == \"string\" && r || void 0,\n        crossOrigin: i,\n        loop: a,\n        muted: o,\n        autoplay: !0,\n        ...l\n      }), h = new sc(d);\n      return d.addEventListener(n, () => f(h)), d.addEventListener(\"error\", () => u(new Error(\"Error loading video\"))), h;\n    });\n  }\n  try {\n    const f = await c();\n    return s && f.image && f.image.play(), f;\n  } catch {\n    t(\"Error loading resource\");\n  }\n}\nfunction Ps(r) {\n  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, \"default\") ? r.default : r;\n}\nfunction Ks(r) {\n  throw new Error('Could not dynamically require \"' + r + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar Xi = { exports: {} }, jr;\nfunction zd() {\n  return jr || (jr = 1, function(r, e) {\n    (function(t) {\n      r.exports = t();\n    })(function() {\n      return function t(n, s, i) {\n        function o(c, f) {\n          if (!s[c]) {\n            if (!n[c]) {\n              var u = typeof Ks == \"function\" && Ks;\n              if (!f && u) return u(c, !0);\n              if (a) return a(c, !0);\n              throw new Error(\"Cannot find module '\" + c + \"'\");\n            }\n            f = s[c] = { exports: {} }, n[c][0].call(f.exports, function(d) {\n              var h = n[c][1][d];\n              return o(h || d);\n            }, f, f.exports, t, n, s, i);\n          }\n          return s[c].exports;\n        }\n        for (var a = typeof Ks == \"function\" && Ks, l = 0; l < i.length; l++) o(i[l]);\n        return o;\n      }({ 1: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          var m = t(\"crypto\");\n          function g(w, E) {\n            E = b(w, E);\n            var x;\n            return (x = E.algorithm !== \"passthrough\" ? m.createHash(E.algorithm) : new R()).write === void 0 && (x.write = x.update, x.end = x.update), M(E, x).dispatch(w), x.update || x.end(\"\"), x.digest ? x.digest(E.encoding === \"buffer\" ? void 0 : E.encoding) : (w = x.read(), E.encoding !== \"buffer\" ? w.toString(E.encoding) : w);\n          }\n          (s = n.exports = g).sha1 = function(w) {\n            return g(w);\n          }, s.keys = function(w) {\n            return g(w, { excludeValues: !0, algorithm: \"sha1\", encoding: \"hex\" });\n          }, s.MD5 = function(w) {\n            return g(w, { algorithm: \"md5\", encoding: \"hex\" });\n          }, s.keysMD5 = function(w) {\n            return g(w, { algorithm: \"md5\", encoding: \"hex\", excludeValues: !0 });\n          };\n          var v = m.getHashes ? m.getHashes().slice() : [\"sha1\", \"md5\"], p = (v.push(\"passthrough\"), [\"buffer\", \"hex\", \"binary\", \"base64\"]);\n          function b(w, E) {\n            var x = {};\n            if (x.algorithm = (E = E || {}).algorithm || \"sha1\", x.encoding = E.encoding || \"hex\", x.excludeValues = !!E.excludeValues, x.algorithm = x.algorithm.toLowerCase(), x.encoding = x.encoding.toLowerCase(), x.ignoreUnknown = E.ignoreUnknown === !0, x.respectType = E.respectType !== !1, x.respectFunctionNames = E.respectFunctionNames !== !1, x.respectFunctionProperties = E.respectFunctionProperties !== !1, x.unorderedArrays = E.unorderedArrays === !0, x.unorderedSets = E.unorderedSets !== !1, x.unorderedObjects = E.unorderedObjects !== !1, x.replacer = E.replacer || void 0, x.excludeKeys = E.excludeKeys || void 0, w === void 0) throw new Error(\"Object argument required.\");\n            for (var T = 0; T < v.length; ++T) v[T].toLowerCase() === x.algorithm.toLowerCase() && (x.algorithm = v[T]);\n            if (v.indexOf(x.algorithm) === -1) throw new Error('Algorithm \"' + x.algorithm + '\"  not supported. supported values: ' + v.join(\", \"));\n            if (p.indexOf(x.encoding) === -1 && x.algorithm !== \"passthrough\") throw new Error('Encoding \"' + x.encoding + '\"  not supported. supported values: ' + p.join(\", \"));\n            return x;\n          }\n          function _(w) {\n            if (typeof w == \"function\") return /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i.exec(Function.prototype.toString.call(w)) != null;\n          }\n          function M(w, E, x) {\n            x = x || [];\n            function T(y) {\n              return E.update ? E.update(y, \"utf8\") : E.write(y, \"utf8\");\n            }\n            return { dispatch: function(y) {\n              return this[\"_\" + ((y = w.replacer ? w.replacer(y) : y) === null ? \"null\" : typeof y)](y);\n            }, _object: function(y) {\n              var A, C = Object.prototype.toString.call(y), N = /\\[object (.*)\\]/i.exec(C);\n              if (N = (N = N ? N[1] : \"unknown:[\" + C + \"]\").toLowerCase(), 0 <= (C = x.indexOf(y))) return this.dispatch(\"[CIRCULAR:\" + C + \"]\");\n              if (x.push(y), a !== void 0 && a.isBuffer && a.isBuffer(y)) return T(\"buffer:\"), T(y);\n              if (N === \"object\" || N === \"function\" || N === \"asyncfunction\") return C = Object.keys(y), w.unorderedObjects && (C = C.sort()), w.respectType === !1 || _(y) || C.splice(0, 0, \"prototype\", \"__proto__\", \"constructor\"), w.excludeKeys && (C = C.filter(function(U) {\n                return !w.excludeKeys(U);\n              })), T(\"object:\" + C.length + \":\"), A = this, C.forEach(function(U) {\n                A.dispatch(U), T(\":\"), w.excludeValues || A.dispatch(y[U]), T(\",\");\n              });\n              if (!this[\"_\" + N]) {\n                if (w.ignoreUnknown) return T(\"[\" + N + \"]\");\n                throw new Error('Unknown object type \"' + N + '\"');\n              }\n              this[\"_\" + N](y);\n            }, _array: function(y, U) {\n              U = U !== void 0 ? U : w.unorderedArrays !== !1;\n              var C = this;\n              if (T(\"array:\" + y.length + \":\"), !U || y.length <= 1) return y.forEach(function(Y) {\n                return C.dispatch(Y);\n              });\n              var N = [], U = y.map(function(Y) {\n                var V = new R(), ne = x.slice();\n                return M(w, V, ne).dispatch(Y), N = N.concat(ne.slice(x.length)), V.read().toString();\n              });\n              return x = x.concat(N), U.sort(), this._array(U, !1);\n            }, _date: function(y) {\n              return T(\"date:\" + y.toJSON());\n            }, _symbol: function(y) {\n              return T(\"symbol:\" + y.toString());\n            }, _error: function(y) {\n              return T(\"error:\" + y.toString());\n            }, _boolean: function(y) {\n              return T(\"bool:\" + y.toString());\n            }, _string: function(y) {\n              T(\"string:\" + y.length + \":\"), T(y.toString());\n            }, _function: function(y) {\n              T(\"fn:\"), _(y) ? this.dispatch(\"[native]\") : this.dispatch(y.toString()), w.respectFunctionNames !== !1 && this.dispatch(\"function-name:\" + String(y.name)), w.respectFunctionProperties && this._object(y);\n            }, _number: function(y) {\n              return T(\"number:\" + y.toString());\n            }, _xml: function(y) {\n              return T(\"xml:\" + y.toString());\n            }, _null: function() {\n              return T(\"Null\");\n            }, _undefined: function() {\n              return T(\"Undefined\");\n            }, _regexp: function(y) {\n              return T(\"regex:\" + y.toString());\n            }, _uint8array: function(y) {\n              return T(\"uint8array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _uint8clampedarray: function(y) {\n              return T(\"uint8clampedarray:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _int8array: function(y) {\n              return T(\"int8array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _uint16array: function(y) {\n              return T(\"uint16array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _int16array: function(y) {\n              return T(\"int16array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _uint32array: function(y) {\n              return T(\"uint32array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _int32array: function(y) {\n              return T(\"int32array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _float32array: function(y) {\n              return T(\"float32array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _float64array: function(y) {\n              return T(\"float64array:\"), this.dispatch(Array.prototype.slice.call(y));\n            }, _arraybuffer: function(y) {\n              return T(\"arraybuffer:\"), this.dispatch(new Uint8Array(y));\n            }, _url: function(y) {\n              return T(\"url:\" + y.toString());\n            }, _map: function(y) {\n              return T(\"map:\"), y = Array.from(y), this._array(y, w.unorderedSets !== !1);\n            }, _set: function(y) {\n              return T(\"set:\"), y = Array.from(y), this._array(y, w.unorderedSets !== !1);\n            }, _file: function(y) {\n              return T(\"file:\"), this.dispatch([y.name, y.size, y.type, y.lastModfied]);\n            }, _blob: function() {\n              if (w.ignoreUnknown) return T(\"[blob]\");\n              throw Error(`Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse \"options.replacer\" or \"options.ignoreUnknown\"\n`);\n            }, _domwindow: function() {\n              return T(\"domwindow\");\n            }, _bigint: function(y) {\n              return T(\"bigint:\" + y.toString());\n            }, _process: function() {\n              return T(\"process\");\n            }, _timer: function() {\n              return T(\"timer\");\n            }, _pipe: function() {\n              return T(\"pipe\");\n            }, _tcp: function() {\n              return T(\"tcp\");\n            }, _udp: function() {\n              return T(\"udp\");\n            }, _tty: function() {\n              return T(\"tty\");\n            }, _statwatcher: function() {\n              return T(\"statwatcher\");\n            }, _securecontext: function() {\n              return T(\"securecontext\");\n            }, _connection: function() {\n              return T(\"connection\");\n            }, _zlib: function() {\n              return T(\"zlib\");\n            }, _context: function() {\n              return T(\"context\");\n            }, _nodescript: function() {\n              return T(\"nodescript\");\n            }, _httpparser: function() {\n              return T(\"httpparser\");\n            }, _dataview: function() {\n              return T(\"dataview\");\n            }, _signal: function() {\n              return T(\"signal\");\n            }, _fsevent: function() {\n              return T(\"fsevent\");\n            }, _tlswrap: function() {\n              return T(\"tlswrap\");\n            } };\n          }\n          function R() {\n            return { buf: \"\", write: function(w) {\n              this.buf += w;\n            }, end: function(w) {\n              this.buf += w;\n            }, read: function() {\n              return this.buf;\n            } };\n          }\n          s.writeToStream = function(w, E, x) {\n            return x === void 0 && (x = E, E = {}), M(E = b(w, E), x).dispatch(w);\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/fake_9a5aa49d.js\", \"/\");\n      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          (function(m) {\n            var g = typeof Uint8Array < \"u\" ? Uint8Array : Array, v = 43, p = 47, b = 48, _ = 97, M = 65, R = 45, w = 95;\n            function E(x) {\n              return x = x.charCodeAt(0), x === v || x === R ? 62 : x === p || x === w ? 63 : x < b ? -1 : x < b + 10 ? x - b + 26 + 26 : x < M + 26 ? x - M : x < _ + 26 ? x - _ + 26 : void 0;\n            }\n            m.toByteArray = function(x) {\n              var T, y;\n              if (0 < x.length % 4) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n              var A = x.length, A = x.charAt(A - 2) === \"=\" ? 2 : x.charAt(A - 1) === \"=\" ? 1 : 0, C = new g(3 * x.length / 4 - A), N = 0 < A ? x.length - 4 : x.length, U = 0;\n              function Y(V) {\n                C[U++] = V;\n              }\n              for (T = 0; T < N; T += 4, 0) Y((16711680 & (y = E(x.charAt(T)) << 18 | E(x.charAt(T + 1)) << 12 | E(x.charAt(T + 2)) << 6 | E(x.charAt(T + 3)))) >> 16), Y((65280 & y) >> 8), Y(255 & y);\n              return A == 2 ? Y(255 & (y = E(x.charAt(T)) << 2 | E(x.charAt(T + 1)) >> 4)) : A == 1 && (Y((y = E(x.charAt(T)) << 10 | E(x.charAt(T + 1)) << 4 | E(x.charAt(T + 2)) >> 2) >> 8 & 255), Y(255 & y)), C;\n            }, m.fromByteArray = function(x) {\n              var T, y, A, C, N = x.length % 3, U = \"\";\n              function Y(V) {\n                return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(V);\n              }\n              for (T = 0, A = x.length - N; T < A; T += 3) y = (x[T] << 16) + (x[T + 1] << 8) + x[T + 2], U += Y((C = y) >> 18 & 63) + Y(C >> 12 & 63) + Y(C >> 6 & 63) + Y(63 & C);\n              switch (N) {\n                case 1:\n                  U = (U += Y((y = x[x.length - 1]) >> 2)) + Y(y << 4 & 63) + \"==\";\n                  break;\n                case 2:\n                  U = (U = (U += Y((y = (x[x.length - 2] << 8) + x[x.length - 1]) >> 10)) + Y(y >> 4 & 63)) + Y(y << 2 & 63) + \"=\";\n              }\n              return U;\n            };\n          })(s === void 0 ? this.base64js = {} : s);\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\", \"/node_modules/gulp-browserify/node_modules/base64-js/lib\");\n      }, { buffer: 3, lYpoI2: 11 }], 3: [function(t, n, s) {\n        (function(i, o, v, l, c, f, u, d, h) {\n          var m = t(\"base64-js\"), g = t(\"ieee754\");\n          function v(S, P, L) {\n            if (!(this instanceof v)) return new v(S, P, L);\n            var X, H, j, K, se = typeof S;\n            if (P === \"base64\" && se == \"string\") for (S = (K = S).trim ? K.trim() : K.replace(/^\\s+|\\s+$/g, \"\"); S.length % 4 != 0; ) S += \"=\";\n            if (se == \"number\") X = Z(S);\n            else if (se == \"string\") X = v.byteLength(S, P);\n            else {\n              if (se != \"object\") throw new Error(\"First argument needs to be a number, array or string.\");\n              X = Z(S.length);\n            }\n            if (v._useTypedArrays ? H = v._augment(new Uint8Array(X)) : ((H = this).length = X, H._isBuffer = !0), v._useTypedArrays && typeof S.byteLength == \"number\") H._set(S);\n            else if (ee(K = S) || v.isBuffer(K) || K && typeof K == \"object\" && typeof K.length == \"number\") for (j = 0; j < X; j++) v.isBuffer(S) ? H[j] = S.readUInt8(j) : H[j] = S[j];\n            else if (se == \"string\") H.write(S, 0, P);\n            else if (se == \"number\" && !v._useTypedArrays && !L) for (j = 0; j < X; j++) H[j] = 0;\n            return H;\n          }\n          function p(S, P, L, X) {\n            return v._charsWritten = we(function(H) {\n              for (var j = [], K = 0; K < H.length; K++) j.push(255 & H.charCodeAt(K));\n              return j;\n            }(P), S, L, X);\n          }\n          function b(S, P, L, X) {\n            return v._charsWritten = we(function(H) {\n              for (var j, K, se = [], ie = 0; ie < H.length; ie++) K = H.charCodeAt(ie), j = K >> 8, K = K % 256, se.push(K), se.push(j);\n              return se;\n            }(P), S, L, X);\n          }\n          function _(S, P, L) {\n            var X = \"\";\n            L = Math.min(S.length, L);\n            for (var H = P; H < L; H++) X += String.fromCharCode(S[H]);\n            return X;\n          }\n          function M(S, P, L, j) {\n            j || (z(typeof L == \"boolean\", \"missing or invalid endian\"), z(P != null, \"missing offset\"), z(P + 1 < S.length, \"Trying to read beyond buffer length\"));\n            var H, j = S.length;\n            if (!(j <= P)) return L ? (H = S[P], P + 1 < j && (H |= S[P + 1] << 8)) : (H = S[P] << 8, P + 1 < j && (H |= S[P + 1])), H;\n          }\n          function R(S, P, L, j) {\n            j || (z(typeof L == \"boolean\", \"missing or invalid endian\"), z(P != null, \"missing offset\"), z(P + 3 < S.length, \"Trying to read beyond buffer length\"));\n            var H, j = S.length;\n            if (!(j <= P)) return L ? (P + 2 < j && (H = S[P + 2] << 16), P + 1 < j && (H |= S[P + 1] << 8), H |= S[P], P + 3 < j && (H += S[P + 3] << 24 >>> 0)) : (P + 1 < j && (H = S[P + 1] << 16), P + 2 < j && (H |= S[P + 2] << 8), P + 3 < j && (H |= S[P + 3]), H += S[P] << 24 >>> 0), H;\n          }\n          function w(S, P, L, X) {\n            if (X || (z(typeof L == \"boolean\", \"missing or invalid endian\"), z(P != null, \"missing offset\"), z(P + 1 < S.length, \"Trying to read beyond buffer length\")), !(S.length <= P)) return X = M(S, P, L, !0), 32768 & X ? -1 * (65535 - X + 1) : X;\n          }\n          function E(S, P, L, X) {\n            if (X || (z(typeof L == \"boolean\", \"missing or invalid endian\"), z(P != null, \"missing offset\"), z(P + 3 < S.length, \"Trying to read beyond buffer length\")), !(S.length <= P)) return X = R(S, P, L, !0), 2147483648 & X ? -1 * (4294967295 - X + 1) : X;\n          }\n          function x(S, P, L, X) {\n            return X || (z(typeof L == \"boolean\", \"missing or invalid endian\"), z(P + 3 < S.length, \"Trying to read beyond buffer length\")), g.read(S, P, L, 23, 4);\n          }\n          function T(S, P, L, X) {\n            return X || (z(typeof L == \"boolean\", \"missing or invalid endian\"), z(P + 7 < S.length, \"Trying to read beyond buffer length\")), g.read(S, P, L, 52, 8);\n          }\n          function y(S, P, L, X, H) {\n            if (H || (z(P != null, \"missing value\"), z(typeof X == \"boolean\", \"missing or invalid endian\"), z(L != null, \"missing offset\"), z(L + 1 < S.length, \"trying to write beyond buffer length\"), B(P, 65535)), H = S.length, !(H <= L)) for (var j = 0, K = Math.min(H - L, 2); j < K; j++) S[L + j] = (P & 255 << 8 * (X ? j : 1 - j)) >>> 8 * (X ? j : 1 - j);\n          }\n          function A(S, P, L, X, H) {\n            if (H || (z(P != null, \"missing value\"), z(typeof X == \"boolean\", \"missing or invalid endian\"), z(L != null, \"missing offset\"), z(L + 3 < S.length, \"trying to write beyond buffer length\"), B(P, 4294967295)), H = S.length, !(H <= L)) for (var j = 0, K = Math.min(H - L, 4); j < K; j++) S[L + j] = P >>> 8 * (X ? j : 3 - j) & 255;\n          }\n          function C(S, P, L, X, H) {\n            H || (z(P != null, \"missing value\"), z(typeof X == \"boolean\", \"missing or invalid endian\"), z(L != null, \"missing offset\"), z(L + 1 < S.length, \"Trying to write beyond buffer length\"), D(P, 32767, -32768)), S.length <= L || y(S, 0 <= P ? P : 65535 + P + 1, L, X, H);\n          }\n          function N(S, P, L, X, H) {\n            H || (z(P != null, \"missing value\"), z(typeof X == \"boolean\", \"missing or invalid endian\"), z(L != null, \"missing offset\"), z(L + 3 < S.length, \"Trying to write beyond buffer length\"), D(P, 2147483647, -2147483648)), S.length <= L || A(S, 0 <= P ? P : 4294967295 + P + 1, L, X, H);\n          }\n          function U(S, P, L, X, H) {\n            H || (z(P != null, \"missing value\"), z(typeof X == \"boolean\", \"missing or invalid endian\"), z(L != null, \"missing offset\"), z(L + 3 < S.length, \"Trying to write beyond buffer length\"), O(P, 34028234663852886e22, -34028234663852886e22)), S.length <= L || g.write(S, P, L, X, 23, 4);\n          }\n          function Y(S, P, L, X, H) {\n            H || (z(P != null, \"missing value\"), z(typeof X == \"boolean\", \"missing or invalid endian\"), z(L != null, \"missing offset\"), z(L + 7 < S.length, \"Trying to write beyond buffer length\"), O(P, 17976931348623157e292, -17976931348623157e292)), S.length <= L || g.write(S, P, L, X, 52, 8);\n          }\n          s.Buffer = v, s.SlowBuffer = v, s.INSPECT_MAX_BYTES = 50, v.poolSize = 8192, v._useTypedArrays = function() {\n            try {\n              var S = new ArrayBuffer(0), P = new Uint8Array(S);\n              return P.foo = function() {\n                return 42;\n              }, P.foo() === 42 && typeof P.subarray == \"function\";\n            } catch {\n              return !1;\n            }\n          }(), v.isEncoding = function(S) {\n            switch (String(S).toLowerCase()) {\n              case \"hex\":\n              case \"utf8\":\n              case \"utf-8\":\n              case \"ascii\":\n              case \"binary\":\n              case \"base64\":\n              case \"raw\":\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return !0;\n              default:\n                return !1;\n            }\n          }, v.isBuffer = function(S) {\n            return !(S == null || !S._isBuffer);\n          }, v.byteLength = function(S, P) {\n            var L;\n            switch (S += \"\", P || \"utf8\") {\n              case \"hex\":\n                L = S.length / 2;\n                break;\n              case \"utf8\":\n              case \"utf-8\":\n                L = fe(S).length;\n                break;\n              case \"ascii\":\n              case \"binary\":\n              case \"raw\":\n                L = S.length;\n                break;\n              case \"base64\":\n                L = he(S).length;\n                break;\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                L = 2 * S.length;\n                break;\n              default:\n                throw new Error(\"Unknown encoding\");\n            }\n            return L;\n          }, v.concat = function(S, P) {\n            if (z(ee(S), `Usage: Buffer.concat(list, [totalLength])\nlist should be an Array.`), S.length === 0) return new v(0);\n            if (S.length === 1) return S[0];\n            if (typeof P != \"number\") for (H = P = 0; H < S.length; H++) P += S[H].length;\n            for (var L = new v(P), X = 0, H = 0; H < S.length; H++) {\n              var j = S[H];\n              j.copy(L, X), X += j.length;\n            }\n            return L;\n          }, v.prototype.write = function(S, P, L, X) {\n            isFinite(P) ? isFinite(L) || (X = L, L = void 0) : (ie = X, X = P, P = L, L = ie), P = Number(P) || 0;\n            var H, j, K, se, ie = this.length - P;\n            switch ((!L || ie < (L = Number(L))) && (L = ie), X = String(X || \"utf8\").toLowerCase()) {\n              case \"hex\":\n                H = function(G, k, oe, ge) {\n                  oe = Number(oe) || 0;\n                  var Re = G.length - oe;\n                  (!ge || Re < (ge = Number(ge))) && (ge = Re), z((Re = k.length) % 2 == 0, \"Invalid hex string\"), Re / 2 < ge && (ge = Re / 2);\n                  for (var Ke = 0; Ke < ge; Ke++) {\n                    var He = parseInt(k.substr(2 * Ke, 2), 16);\n                    z(!isNaN(He), \"Invalid hex string\"), G[oe + Ke] = He;\n                  }\n                  return v._charsWritten = 2 * Ke, Ke;\n                }(this, S, P, L);\n                break;\n              case \"utf8\":\n              case \"utf-8\":\n                j = this, K = P, se = L, H = v._charsWritten = we(fe(S), j, K, se);\n                break;\n              case \"ascii\":\n              case \"binary\":\n                H = p(this, S, P, L);\n                break;\n              case \"base64\":\n                j = this, K = P, se = L, H = v._charsWritten = we(he(S), j, K, se);\n                break;\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                H = b(this, S, P, L);\n                break;\n              default:\n                throw new Error(\"Unknown encoding\");\n            }\n            return H;\n          }, v.prototype.toString = function(S, P, L) {\n            var X, H, j, K, se = this;\n            if (S = String(S || \"utf8\").toLowerCase(), P = Number(P) || 0, (L = L !== void 0 ? Number(L) : se.length) === P) return \"\";\n            switch (S) {\n              case \"hex\":\n                X = function(ie, G, k) {\n                  var oe = ie.length;\n                  (!G || G < 0) && (G = 0), (!k || k < 0 || oe < k) && (k = oe);\n                  for (var ge = \"\", Re = G; Re < k; Re++) ge += te(ie[Re]);\n                  return ge;\n                }(se, P, L);\n                break;\n              case \"utf8\":\n              case \"utf-8\":\n                X = function(ie, G, k) {\n                  var oe = \"\", ge = \"\";\n                  k = Math.min(ie.length, k);\n                  for (var Re = G; Re < k; Re++) ie[Re] <= 127 ? (oe += I(ge) + String.fromCharCode(ie[Re]), ge = \"\") : ge += \"%\" + ie[Re].toString(16);\n                  return oe + I(ge);\n                }(se, P, L);\n                break;\n              case \"ascii\":\n              case \"binary\":\n                X = _(se, P, L);\n                break;\n              case \"base64\":\n                H = se, K = L, X = (j = P) === 0 && K === H.length ? m.fromByteArray(H) : m.fromByteArray(H.slice(j, K));\n                break;\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                X = function(ie, G, k) {\n                  for (var oe = ie.slice(G, k), ge = \"\", Re = 0; Re < oe.length; Re += 2) ge += String.fromCharCode(oe[Re] + 256 * oe[Re + 1]);\n                  return ge;\n                }(se, P, L);\n                break;\n              default:\n                throw new Error(\"Unknown encoding\");\n            }\n            return X;\n          }, v.prototype.toJSON = function() {\n            return { type: \"Buffer\", data: Array.prototype.slice.call(this._arr || this, 0) };\n          }, v.prototype.copy = function(S, P, L, X) {\n            if (P = P || 0, (X = X || X === 0 ? X : this.length) !== (L = L || 0) && S.length !== 0 && this.length !== 0) {\n              z(L <= X, \"sourceEnd < sourceStart\"), z(0 <= P && P < S.length, \"targetStart out of bounds\"), z(0 <= L && L < this.length, \"sourceStart out of bounds\"), z(0 <= X && X <= this.length, \"sourceEnd out of bounds\"), X > this.length && (X = this.length);\n              var H = (X = S.length - P < X - L ? S.length - P + L : X) - L;\n              if (H < 100 || !v._useTypedArrays) for (var j = 0; j < H; j++) S[j + P] = this[j + L];\n              else S._set(this.subarray(L, L + H), P);\n            }\n          }, v.prototype.slice = function(S, P) {\n            var L = this.length;\n            if (S = ne(S, L, 0), P = ne(P, L, L), v._useTypedArrays) return v._augment(this.subarray(S, P));\n            for (var X = P - S, H = new v(X, void 0, !0), j = 0; j < X; j++) H[j] = this[j + S];\n            return H;\n          }, v.prototype.get = function(S) {\n            return console.log(\".get() is deprecated. Access using array indexes instead.\"), this.readUInt8(S);\n          }, v.prototype.set = function(S, P) {\n            return console.log(\".set() is deprecated. Access using array indexes instead.\"), this.writeUInt8(S, P);\n          }, v.prototype.readUInt8 = function(S, P) {\n            if (P || (z(S != null, \"missing offset\"), z(S < this.length, \"Trying to read beyond buffer length\")), !(S >= this.length)) return this[S];\n          }, v.prototype.readUInt16LE = function(S, P) {\n            return M(this, S, !0, P);\n          }, v.prototype.readUInt16BE = function(S, P) {\n            return M(this, S, !1, P);\n          }, v.prototype.readUInt32LE = function(S, P) {\n            return R(this, S, !0, P);\n          }, v.prototype.readUInt32BE = function(S, P) {\n            return R(this, S, !1, P);\n          }, v.prototype.readInt8 = function(S, P) {\n            if (P || (z(S != null, \"missing offset\"), z(S < this.length, \"Trying to read beyond buffer length\")), !(S >= this.length)) return 128 & this[S] ? -1 * (255 - this[S] + 1) : this[S];\n          }, v.prototype.readInt16LE = function(S, P) {\n            return w(this, S, !0, P);\n          }, v.prototype.readInt16BE = function(S, P) {\n            return w(this, S, !1, P);\n          }, v.prototype.readInt32LE = function(S, P) {\n            return E(this, S, !0, P);\n          }, v.prototype.readInt32BE = function(S, P) {\n            return E(this, S, !1, P);\n          }, v.prototype.readFloatLE = function(S, P) {\n            return x(this, S, !0, P);\n          }, v.prototype.readFloatBE = function(S, P) {\n            return x(this, S, !1, P);\n          }, v.prototype.readDoubleLE = function(S, P) {\n            return T(this, S, !0, P);\n          }, v.prototype.readDoubleBE = function(S, P) {\n            return T(this, S, !1, P);\n          }, v.prototype.writeUInt8 = function(S, P, L) {\n            L || (z(S != null, \"missing value\"), z(P != null, \"missing offset\"), z(P < this.length, \"trying to write beyond buffer length\"), B(S, 255)), P >= this.length || (this[P] = S);\n          }, v.prototype.writeUInt16LE = function(S, P, L) {\n            y(this, S, P, !0, L);\n          }, v.prototype.writeUInt16BE = function(S, P, L) {\n            y(this, S, P, !1, L);\n          }, v.prototype.writeUInt32LE = function(S, P, L) {\n            A(this, S, P, !0, L);\n          }, v.prototype.writeUInt32BE = function(S, P, L) {\n            A(this, S, P, !1, L);\n          }, v.prototype.writeInt8 = function(S, P, L) {\n            L || (z(S != null, \"missing value\"), z(P != null, \"missing offset\"), z(P < this.length, \"Trying to write beyond buffer length\"), D(S, 127, -128)), P >= this.length || (0 <= S ? this.writeUInt8(S, P, L) : this.writeUInt8(255 + S + 1, P, L));\n          }, v.prototype.writeInt16LE = function(S, P, L) {\n            C(this, S, P, !0, L);\n          }, v.prototype.writeInt16BE = function(S, P, L) {\n            C(this, S, P, !1, L);\n          }, v.prototype.writeInt32LE = function(S, P, L) {\n            N(this, S, P, !0, L);\n          }, v.prototype.writeInt32BE = function(S, P, L) {\n            N(this, S, P, !1, L);\n          }, v.prototype.writeFloatLE = function(S, P, L) {\n            U(this, S, P, !0, L);\n          }, v.prototype.writeFloatBE = function(S, P, L) {\n            U(this, S, P, !1, L);\n          }, v.prototype.writeDoubleLE = function(S, P, L) {\n            Y(this, S, P, !0, L);\n          }, v.prototype.writeDoubleBE = function(S, P, L) {\n            Y(this, S, P, !1, L);\n          }, v.prototype.fill = function(S, P, L) {\n            if (P = P || 0, L = L || this.length, z(typeof (S = typeof (S = S || 0) == \"string\" ? S.charCodeAt(0) : S) == \"number\" && !isNaN(S), \"value is not a number\"), z(P <= L, \"end < start\"), L !== P && this.length !== 0) {\n              z(0 <= P && P < this.length, \"start out of bounds\"), z(0 <= L && L <= this.length, \"end out of bounds\");\n              for (var X = P; X < L; X++) this[X] = S;\n            }\n          }, v.prototype.inspect = function() {\n            for (var S = [], P = this.length, L = 0; L < P; L++) if (S[L] = te(this[L]), L === s.INSPECT_MAX_BYTES) {\n              S[L + 1] = \"...\";\n              break;\n            }\n            return \"<Buffer \" + S.join(\" \") + \">\";\n          }, v.prototype.toArrayBuffer = function() {\n            if (typeof Uint8Array > \"u\") throw new Error(\"Buffer.toArrayBuffer not supported in this browser\");\n            if (v._useTypedArrays) return new v(this).buffer;\n            for (var S = new Uint8Array(this.length), P = 0, L = S.length; P < L; P += 1) S[P] = this[P];\n            return S.buffer;\n          };\n          var V = v.prototype;\n          function ne(S, P, L) {\n            return typeof S != \"number\" ? L : P <= (S = ~~S) ? P : 0 <= S || 0 <= (S += P) ? S : 0;\n          }\n          function Z(S) {\n            return (S = ~~Math.ceil(+S)) < 0 ? 0 : S;\n          }\n          function ee(S) {\n            return (Array.isArray || function(P) {\n              return Object.prototype.toString.call(P) === \"[object Array]\";\n            })(S);\n          }\n          function te(S) {\n            return S < 16 ? \"0\" + S.toString(16) : S.toString(16);\n          }\n          function fe(S) {\n            for (var P = [], L = 0; L < S.length; L++) {\n              var X = S.charCodeAt(L);\n              if (X <= 127) P.push(S.charCodeAt(L));\n              else for (var H = L, j = (55296 <= X && X <= 57343 && L++, encodeURIComponent(S.slice(H, L + 1)).substr(1).split(\"%\")), K = 0; K < j.length; K++) P.push(parseInt(j[K], 16));\n            }\n            return P;\n          }\n          function he(S) {\n            return m.toByteArray(S);\n          }\n          function we(S, P, L, X) {\n            for (var H = 0; H < X && !(H + L >= P.length || H >= S.length); H++) P[H + L] = S[H];\n            return H;\n          }\n          function I(S) {\n            try {\n              return decodeURIComponent(S);\n            } catch {\n              return \"ï¿½\";\n            }\n          }\n          function B(S, P) {\n            z(typeof S == \"number\", \"cannot write a non-number as a number\"), z(0 <= S, \"specified a negative value for writing an unsigned value\"), z(S <= P, \"value is larger than maximum value for type\"), z(Math.floor(S) === S, \"value has a fractional component\");\n          }\n          function D(S, P, L) {\n            z(typeof S == \"number\", \"cannot write a non-number as a number\"), z(S <= P, \"value larger than maximum allowed value\"), z(L <= S, \"value smaller than minimum allowed value\"), z(Math.floor(S) === S, \"value has a fractional component\");\n          }\n          function O(S, P, L) {\n            z(typeof S == \"number\", \"cannot write a non-number as a number\"), z(S <= P, \"value larger than maximum allowed value\"), z(L <= S, \"value smaller than minimum allowed value\");\n          }\n          function z(S, P) {\n            if (!S) throw new Error(P || \"Failed assertion\");\n          }\n          v._augment = function(S) {\n            return S._isBuffer = !0, S._get = S.get, S._set = S.set, S.get = V.get, S.set = V.set, S.write = V.write, S.toString = V.toString, S.toLocaleString = V.toString, S.toJSON = V.toJSON, S.copy = V.copy, S.slice = V.slice, S.readUInt8 = V.readUInt8, S.readUInt16LE = V.readUInt16LE, S.readUInt16BE = V.readUInt16BE, S.readUInt32LE = V.readUInt32LE, S.readUInt32BE = V.readUInt32BE, S.readInt8 = V.readInt8, S.readInt16LE = V.readInt16LE, S.readInt16BE = V.readInt16BE, S.readInt32LE = V.readInt32LE, S.readInt32BE = V.readInt32BE, S.readFloatLE = V.readFloatLE, S.readFloatBE = V.readFloatBE, S.readDoubleLE = V.readDoubleLE, S.readDoubleBE = V.readDoubleBE, S.writeUInt8 = V.writeUInt8, S.writeUInt16LE = V.writeUInt16LE, S.writeUInt16BE = V.writeUInt16BE, S.writeUInt32LE = V.writeUInt32LE, S.writeUInt32BE = V.writeUInt32BE, S.writeInt8 = V.writeInt8, S.writeInt16LE = V.writeInt16LE, S.writeInt16BE = V.writeInt16BE, S.writeInt32LE = V.writeInt32LE, S.writeInt32BE = V.writeInt32BE, S.writeFloatLE = V.writeFloatLE, S.writeFloatBE = V.writeFloatBE, S.writeDoubleLE = V.writeDoubleLE, S.writeDoubleBE = V.writeDoubleBE, S.fill = V.fill, S.inspect = V.inspect, S.toArrayBuffer = V.toArrayBuffer, S;\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/buffer/index.js\", \"/node_modules/gulp-browserify/node_modules/buffer\");\n      }, { \"base64-js\": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(t, n, s) {\n        (function(i, o, m, l, c, f, u, d, h) {\n          var m = t(\"buffer\").Buffer, g = 4, v = new m(g);\n          v.fill(0), n.exports = { hash: function(p, b, _, M) {\n            for (var R = b(function(y, A) {\n              y.length % g != 0 && (C = y.length + (g - y.length % g), y = m.concat([y, v], C));\n              for (var C, N = [], U = A ? y.readInt32BE : y.readInt32LE, Y = 0; Y < y.length; Y += g) N.push(U.call(y, Y));\n              return N;\n            }(p = m.isBuffer(p) ? p : new m(p), M), 8 * p.length), b = M, w = new m(_), E = b ? w.writeInt32BE : w.writeInt32LE, x = 0; x < R.length; x++) E.call(w, R[x], 4 * x, !0);\n            return w;\n          } };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js\", \"/node_modules/gulp-browserify/node_modules/crypto-browserify\");\n      }, { buffer: 3, lYpoI2: 11 }], 5: [function(t, n, s) {\n        (function(i, o, m, l, c, f, u, d, h) {\n          var m = t(\"buffer\").Buffer, g = t(\"./sha\"), v = t(\"./sha256\"), p = t(\"./rng\"), b = { sha1: g, sha256: v, md5: t(\"./md5\") }, _ = 64, M = new m(_);\n          function R(y, A) {\n            var C = b[y = y || \"sha1\"], N = [];\n            return C || w(\"algorithm:\", y, \"is not yet supported\"), { update: function(U) {\n              return m.isBuffer(U) || (U = new m(U)), N.push(U), U.length, this;\n            }, digest: function(U) {\n              var Y = m.concat(N), Y = A ? function(V, ne, Z) {\n                m.isBuffer(ne) || (ne = new m(ne)), m.isBuffer(Z) || (Z = new m(Z)), ne.length > _ ? ne = V(ne) : ne.length < _ && (ne = m.concat([ne, M], _));\n                for (var ee = new m(_), te = new m(_), fe = 0; fe < _; fe++) ee[fe] = 54 ^ ne[fe], te[fe] = 92 ^ ne[fe];\n                return Z = V(m.concat([ee, Z])), V(m.concat([te, Z]));\n              }(C, A, Y) : C(Y);\n              return N = null, U ? Y.toString(U) : Y;\n            } };\n          }\n          function w() {\n            var y = [].slice.call(arguments).join(\" \");\n            throw new Error([y, \"we accept pull requests\", \"http://github.com/dominictarr/crypto-browserify\"].join(`\n`));\n          }\n          M.fill(0), s.createHash = function(y) {\n            return R(y);\n          }, s.createHmac = R, s.randomBytes = function(y, A) {\n            if (!A || !A.call) return new m(p(y));\n            try {\n              A.call(this, void 0, new m(p(y)));\n            } catch (C) {\n              A(C);\n            }\n          };\n          var E, x = [\"createCredentials\", \"createCipher\", \"createCipheriv\", \"createDecipher\", \"createDecipheriv\", \"createSign\", \"createVerify\", \"createDiffieHellman\", \"pbkdf2\"], T = function(y) {\n            s[y] = function() {\n              w(\"sorry,\", y, \"is not implemented yet\");\n            };\n          };\n          for (E in x) T(x[E]);\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js\", \"/node_modules/gulp-browserify/node_modules/crypto-browserify\");\n      }, { \"./md5\": 6, \"./rng\": 7, \"./sha\": 8, \"./sha256\": 9, buffer: 3, lYpoI2: 11 }], 6: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          var m = t(\"./helpers\");\n          function g(w, E) {\n            w[E >> 5] |= 128 << E % 32, w[14 + (E + 64 >>> 9 << 4)] = E;\n            for (var x = 1732584193, T = -271733879, y = -1732584194, A = 271733878, C = 0; C < w.length; C += 16) {\n              var N = x, U = T, Y = y, V = A, x = p(x, T, y, A, w[C + 0], 7, -680876936), A = p(A, x, T, y, w[C + 1], 12, -389564586), y = p(y, A, x, T, w[C + 2], 17, 606105819), T = p(T, y, A, x, w[C + 3], 22, -1044525330);\n              x = p(x, T, y, A, w[C + 4], 7, -176418897), A = p(A, x, T, y, w[C + 5], 12, 1200080426), y = p(y, A, x, T, w[C + 6], 17, -1473231341), T = p(T, y, A, x, w[C + 7], 22, -45705983), x = p(x, T, y, A, w[C + 8], 7, 1770035416), A = p(A, x, T, y, w[C + 9], 12, -1958414417), y = p(y, A, x, T, w[C + 10], 17, -42063), T = p(T, y, A, x, w[C + 11], 22, -1990404162), x = p(x, T, y, A, w[C + 12], 7, 1804603682), A = p(A, x, T, y, w[C + 13], 12, -40341101), y = p(y, A, x, T, w[C + 14], 17, -1502002290), x = b(x, T = p(T, y, A, x, w[C + 15], 22, 1236535329), y, A, w[C + 1], 5, -165796510), A = b(A, x, T, y, w[C + 6], 9, -1069501632), y = b(y, A, x, T, w[C + 11], 14, 643717713), T = b(T, y, A, x, w[C + 0], 20, -373897302), x = b(x, T, y, A, w[C + 5], 5, -701558691), A = b(A, x, T, y, w[C + 10], 9, 38016083), y = b(y, A, x, T, w[C + 15], 14, -660478335), T = b(T, y, A, x, w[C + 4], 20, -405537848), x = b(x, T, y, A, w[C + 9], 5, 568446438), A = b(A, x, T, y, w[C + 14], 9, -1019803690), y = b(y, A, x, T, w[C + 3], 14, -187363961), T = b(T, y, A, x, w[C + 8], 20, 1163531501), x = b(x, T, y, A, w[C + 13], 5, -1444681467), A = b(A, x, T, y, w[C + 2], 9, -51403784), y = b(y, A, x, T, w[C + 7], 14, 1735328473), x = _(x, T = b(T, y, A, x, w[C + 12], 20, -1926607734), y, A, w[C + 5], 4, -378558), A = _(A, x, T, y, w[C + 8], 11, -2022574463), y = _(y, A, x, T, w[C + 11], 16, 1839030562), T = _(T, y, A, x, w[C + 14], 23, -35309556), x = _(x, T, y, A, w[C + 1], 4, -1530992060), A = _(A, x, T, y, w[C + 4], 11, 1272893353), y = _(y, A, x, T, w[C + 7], 16, -155497632), T = _(T, y, A, x, w[C + 10], 23, -1094730640), x = _(x, T, y, A, w[C + 13], 4, 681279174), A = _(A, x, T, y, w[C + 0], 11, -358537222), y = _(y, A, x, T, w[C + 3], 16, -722521979), T = _(T, y, A, x, w[C + 6], 23, 76029189), x = _(x, T, y, A, w[C + 9], 4, -640364487), A = _(A, x, T, y, w[C + 12], 11, -421815835), y = _(y, A, x, T, w[C + 15], 16, 530742520), x = M(x, T = _(T, y, A, x, w[C + 2], 23, -995338651), y, A, w[C + 0], 6, -198630844), A = M(A, x, T, y, w[C + 7], 10, 1126891415), y = M(y, A, x, T, w[C + 14], 15, -1416354905), T = M(T, y, A, x, w[C + 5], 21, -57434055), x = M(x, T, y, A, w[C + 12], 6, 1700485571), A = M(A, x, T, y, w[C + 3], 10, -1894986606), y = M(y, A, x, T, w[C + 10], 15, -1051523), T = M(T, y, A, x, w[C + 1], 21, -2054922799), x = M(x, T, y, A, w[C + 8], 6, 1873313359), A = M(A, x, T, y, w[C + 15], 10, -30611744), y = M(y, A, x, T, w[C + 6], 15, -1560198380), T = M(T, y, A, x, w[C + 13], 21, 1309151649), x = M(x, T, y, A, w[C + 4], 6, -145523070), A = M(A, x, T, y, w[C + 11], 10, -1120210379), y = M(y, A, x, T, w[C + 2], 15, 718787259), T = M(T, y, A, x, w[C + 9], 21, -343485551), x = R(x, N), T = R(T, U), y = R(y, Y), A = R(A, V);\n            }\n            return Array(x, T, y, A);\n          }\n          function v(w, E, x, T, y, A) {\n            return R((E = R(R(E, w), R(T, A))) << y | E >>> 32 - y, x);\n          }\n          function p(w, E, x, T, y, A, C) {\n            return v(E & x | ~E & T, w, E, y, A, C);\n          }\n          function b(w, E, x, T, y, A, C) {\n            return v(E & T | x & ~T, w, E, y, A, C);\n          }\n          function _(w, E, x, T, y, A, C) {\n            return v(E ^ x ^ T, w, E, y, A, C);\n          }\n          function M(w, E, x, T, y, A, C) {\n            return v(x ^ (E | ~T), w, E, y, A, C);\n          }\n          function R(w, E) {\n            var x = (65535 & w) + (65535 & E);\n            return (w >> 16) + (E >> 16) + (x >> 16) << 16 | 65535 & x;\n          }\n          n.exports = function(w) {\n            return m.hash(w, g, 16);\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js\", \"/node_modules/gulp-browserify/node_modules/crypto-browserify\");\n      }, { \"./helpers\": 4, buffer: 3, lYpoI2: 11 }], 7: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          n.exports = function(m) {\n            for (var g, v = new Array(m), p = 0; p < m; p++) !(3 & p) && (g = 4294967296 * Math.random()), v[p] = g >>> ((3 & p) << 3) & 255;\n            return v;\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js\", \"/node_modules/gulp-browserify/node_modules/crypto-browserify\");\n      }, { buffer: 3, lYpoI2: 11 }], 8: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          var m = t(\"./helpers\");\n          function g(b, _) {\n            b[_ >> 5] |= 128 << 24 - _ % 32, b[15 + (_ + 64 >> 9 << 4)] = _;\n            for (var M, R, w, E = Array(80), x = 1732584193, T = -271733879, y = -1732584194, A = 271733878, C = -1009589776, N = 0; N < b.length; N += 16) {\n              for (var U = x, Y = T, V = y, ne = A, Z = C, ee = 0; ee < 80; ee++) {\n                E[ee] = ee < 16 ? b[N + ee] : p(E[ee - 3] ^ E[ee - 8] ^ E[ee - 14] ^ E[ee - 16], 1);\n                var te = v(v(p(x, 5), (te = T, R = y, w = A, (M = ee) < 20 ? te & R | ~te & w : !(M < 40) && M < 60 ? te & R | te & w | R & w : te ^ R ^ w)), v(v(C, E[ee]), (M = ee) < 20 ? 1518500249 : M < 40 ? 1859775393 : M < 60 ? -1894007588 : -899497514)), C = A, A = y, y = p(T, 30), T = x, x = te;\n              }\n              x = v(x, U), T = v(T, Y), y = v(y, V), A = v(A, ne), C = v(C, Z);\n            }\n            return Array(x, T, y, A, C);\n          }\n          function v(b, _) {\n            var M = (65535 & b) + (65535 & _);\n            return (b >> 16) + (_ >> 16) + (M >> 16) << 16 | 65535 & M;\n          }\n          function p(b, _) {\n            return b << _ | b >>> 32 - _;\n          }\n          n.exports = function(b) {\n            return m.hash(b, g, 20, !0);\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js\", \"/node_modules/gulp-browserify/node_modules/crypto-browserify\");\n      }, { \"./helpers\": 4, buffer: 3, lYpoI2: 11 }], 9: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          function m(_, M) {\n            var R = (65535 & _) + (65535 & M);\n            return (_ >> 16) + (M >> 16) + (R >> 16) << 16 | 65535 & R;\n          }\n          function g(_, M) {\n            var R, w = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), E = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), x = new Array(64);\n            _[M >> 5] |= 128 << 24 - M % 32, _[15 + (M + 64 >> 9 << 4)] = M;\n            for (var T, y, A = 0; A < _.length; A += 16) {\n              for (var C = E[0], N = E[1], U = E[2], Y = E[3], V = E[4], ne = E[5], Z = E[6], ee = E[7], te = 0; te < 64; te++) x[te] = te < 16 ? _[te + A] : m(m(m((y = x[te - 2], p(y, 17) ^ p(y, 19) ^ b(y, 10)), x[te - 7]), (y = x[te - 15], p(y, 7) ^ p(y, 18) ^ b(y, 3))), x[te - 16]), R = m(m(m(m(ee, p(y = V, 6) ^ p(y, 11) ^ p(y, 25)), V & ne ^ ~V & Z), w[te]), x[te]), T = m(p(T = C, 2) ^ p(T, 13) ^ p(T, 22), C & N ^ C & U ^ N & U), ee = Z, Z = ne, ne = V, V = m(Y, R), Y = U, U = N, N = C, C = m(R, T);\n              E[0] = m(C, E[0]), E[1] = m(N, E[1]), E[2] = m(U, E[2]), E[3] = m(Y, E[3]), E[4] = m(V, E[4]), E[5] = m(ne, E[5]), E[6] = m(Z, E[6]), E[7] = m(ee, E[7]);\n            }\n            return E;\n          }\n          var v = t(\"./helpers\"), p = function(_, M) {\n            return _ >>> M | _ << 32 - M;\n          }, b = function(_, M) {\n            return _ >>> M;\n          };\n          n.exports = function(_) {\n            return v.hash(_, g, 32, !0);\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js\", \"/node_modules/gulp-browserify/node_modules/crypto-browserify\");\n      }, { \"./helpers\": 4, buffer: 3, lYpoI2: 11 }], 10: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          s.read = function(m, g, v, p, A) {\n            var _, M, R = 8 * A - p - 1, w = (1 << R) - 1, E = w >> 1, x = -7, T = v ? A - 1 : 0, y = v ? -1 : 1, A = m[g + T];\n            for (T += y, _ = A & (1 << -x) - 1, A >>= -x, x += R; 0 < x; _ = 256 * _ + m[g + T], T += y, x -= 8) ;\n            for (M = _ & (1 << -x) - 1, _ >>= -x, x += p; 0 < x; M = 256 * M + m[g + T], T += y, x -= 8) ;\n            if (_ === 0) _ = 1 - E;\n            else {\n              if (_ === w) return M ? NaN : 1 / 0 * (A ? -1 : 1);\n              M += Math.pow(2, p), _ -= E;\n            }\n            return (A ? -1 : 1) * M * Math.pow(2, _ - p);\n          }, s.write = function(m, g, v, p, b, C) {\n            var M, R, w = 8 * C - b - 1, E = (1 << w) - 1, x = E >> 1, T = b === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = p ? 0 : C - 1, A = p ? 1 : -1, C = g < 0 || g === 0 && 1 / g < 0 ? 1 : 0;\n            for (g = Math.abs(g), isNaN(g) || g === 1 / 0 ? (R = isNaN(g) ? 1 : 0, M = E) : (M = Math.floor(Math.log(g) / Math.LN2), g * (p = Math.pow(2, -M)) < 1 && (M--, p *= 2), 2 <= (g += 1 <= M + x ? T / p : T * Math.pow(2, 1 - x)) * p && (M++, p /= 2), E <= M + x ? (R = 0, M = E) : 1 <= M + x ? (R = (g * p - 1) * Math.pow(2, b), M += x) : (R = g * Math.pow(2, x - 1) * Math.pow(2, b), M = 0)); 8 <= b; m[v + y] = 255 & R, y += A, R /= 256, b -= 8) ;\n            for (M = M << b | R, w += b; 0 < w; m[v + y] = 255 & M, y += A, M /= 256, w -= 8) ;\n            m[v + y - A] |= 128 * C;\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/ieee754/index.js\", \"/node_modules/gulp-browserify/node_modules/ieee754\");\n      }, { buffer: 3, lYpoI2: 11 }], 11: [function(t, n, s) {\n        (function(i, o, a, l, c, f, u, d, h) {\n          var m, g, v;\n          function p() {\n          }\n          (i = n.exports = {}).nextTick = (g = typeof window < \"u\" && window.setImmediate, v = typeof window < \"u\" && window.postMessage && window.addEventListener, g ? function(b) {\n            return window.setImmediate(b);\n          } : v ? (m = [], window.addEventListener(\"message\", function(b) {\n            var _ = b.source;\n            _ !== window && _ !== null || b.data !== \"process-tick\" || (b.stopPropagation(), 0 < m.length && m.shift()());\n          }, !0), function(b) {\n            m.push(b), window.postMessage(\"process-tick\", \"*\");\n          }) : function(b) {\n            setTimeout(b, 0);\n          }), i.title = \"browser\", i.browser = !0, i.env = {}, i.argv = [], i.on = p, i.addListener = p, i.once = p, i.off = p, i.removeListener = p, i.removeAllListeners = p, i.emit = p, i.binding = function(b) {\n            throw new Error(\"process.binding is not supported\");\n          }, i.cwd = function() {\n            return \"/\";\n          }, i.chdir = function(b) {\n            throw new Error(\"process.chdir is not supported\");\n          };\n        }).call(this, t(\"lYpoI2\"), typeof self < \"u\" ? self : typeof window < \"u\" ? window : {}, t(\"buffer\").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], \"/node_modules/gulp-browserify/node_modules/process/browser.js\", \"/node_modules/gulp-browserify/node_modules/process\");\n      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);\n    });\n  }(Xi)), Xi.exports;\n}\nvar Gd = zd();\nconst Hd = /* @__PURE__ */ Ps(Gd);\nvar $i, Vr;\nfunction vl() {\n  return Vr || (Vr = 1, $i = [\n    // current\n    \"precision\",\n    \"highp\",\n    \"mediump\",\n    \"lowp\",\n    \"attribute\",\n    \"const\",\n    \"uniform\",\n    \"varying\",\n    \"break\",\n    \"continue\",\n    \"do\",\n    \"for\",\n    \"while\",\n    \"if\",\n    \"else\",\n    \"in\",\n    \"out\",\n    \"inout\",\n    \"float\",\n    \"int\",\n    \"uint\",\n    \"void\",\n    \"bool\",\n    \"true\",\n    \"false\",\n    \"discard\",\n    \"return\",\n    \"mat2\",\n    \"mat3\",\n    \"mat4\",\n    \"vec2\",\n    \"vec3\",\n    \"vec4\",\n    \"ivec2\",\n    \"ivec3\",\n    \"ivec4\",\n    \"bvec2\",\n    \"bvec3\",\n    \"bvec4\",\n    \"sampler1D\",\n    \"sampler2D\",\n    \"sampler3D\",\n    \"samplerCube\",\n    \"sampler1DShadow\",\n    \"sampler2DShadow\",\n    \"struct\",\n    \"asm\",\n    \"class\",\n    \"union\",\n    \"enum\",\n    \"typedef\",\n    \"template\",\n    \"this\",\n    \"packed\",\n    \"goto\",\n    \"switch\",\n    \"default\",\n    \"inline\",\n    \"noinline\",\n    \"volatile\",\n    \"public\",\n    \"static\",\n    \"extern\",\n    \"external\",\n    \"interface\",\n    \"long\",\n    \"short\",\n    \"double\",\n    \"half\",\n    \"fixed\",\n    \"unsigned\",\n    \"input\",\n    \"output\",\n    \"hvec2\",\n    \"hvec3\",\n    \"hvec4\",\n    \"dvec2\",\n    \"dvec3\",\n    \"dvec4\",\n    \"fvec2\",\n    \"fvec3\",\n    \"fvec4\",\n    \"sampler2DRect\",\n    \"sampler3DRect\",\n    \"sampler2DRectShadow\",\n    \"sizeof\",\n    \"cast\",\n    \"namespace\",\n    \"using\"\n  ]), $i;\n}\nvar Zi, Yr;\nfunction jd() {\n  return Yr || (Yr = 1, Zi = [\n    \"<<=\",\n    \">>=\",\n    \"++\",\n    \"--\",\n    \"<<\",\n    \">>\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"!=\",\n    \"&&\",\n    \"||\",\n    \"+=\",\n    \"-=\",\n    \"*=\",\n    \"/=\",\n    \"%=\",\n    \"&=\",\n    \"^^\",\n    \"^=\",\n    \"|=\",\n    \"(\",\n    \")\",\n    \"[\",\n    \"]\",\n    \".\",\n    \"!\",\n    \"~\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"+\",\n    \"-\",\n    \"<\",\n    \">\",\n    \"&\",\n    \"^\",\n    \"|\",\n    \"?\",\n    \":\",\n    \"=\",\n    \",\",\n    \";\",\n    \"{\",\n    \"}\"\n  ]), Zi;\n}\nvar Ki, Wr;\nfunction yl() {\n  return Wr || (Wr = 1, Ki = [\n    // Keep this list sorted\n    \"abs\",\n    \"acos\",\n    \"all\",\n    \"any\",\n    \"asin\",\n    \"atan\",\n    \"ceil\",\n    \"clamp\",\n    \"cos\",\n    \"cross\",\n    \"dFdx\",\n    \"dFdy\",\n    \"degrees\",\n    \"distance\",\n    \"dot\",\n    \"equal\",\n    \"exp\",\n    \"exp2\",\n    \"faceforward\",\n    \"floor\",\n    \"fract\",\n    \"gl_BackColor\",\n    \"gl_BackLightModelProduct\",\n    \"gl_BackLightProduct\",\n    \"gl_BackMaterial\",\n    \"gl_BackSecondaryColor\",\n    \"gl_ClipPlane\",\n    \"gl_ClipVertex\",\n    \"gl_Color\",\n    \"gl_DepthRange\",\n    \"gl_DepthRangeParameters\",\n    \"gl_EyePlaneQ\",\n    \"gl_EyePlaneR\",\n    \"gl_EyePlaneS\",\n    \"gl_EyePlaneT\",\n    \"gl_Fog\",\n    \"gl_FogCoord\",\n    \"gl_FogFragCoord\",\n    \"gl_FogParameters\",\n    \"gl_FragColor\",\n    \"gl_FragCoord\",\n    \"gl_FragData\",\n    \"gl_FragDepth\",\n    \"gl_FragDepthEXT\",\n    \"gl_FrontColor\",\n    \"gl_FrontFacing\",\n    \"gl_FrontLightModelProduct\",\n    \"gl_FrontLightProduct\",\n    \"gl_FrontMaterial\",\n    \"gl_FrontSecondaryColor\",\n    \"gl_LightModel\",\n    \"gl_LightModelParameters\",\n    \"gl_LightModelProducts\",\n    \"gl_LightProducts\",\n    \"gl_LightSource\",\n    \"gl_LightSourceParameters\",\n    \"gl_MaterialParameters\",\n    \"gl_MaxClipPlanes\",\n    \"gl_MaxCombinedTextureImageUnits\",\n    \"gl_MaxDrawBuffers\",\n    \"gl_MaxFragmentUniformComponents\",\n    \"gl_MaxLights\",\n    \"gl_MaxTextureCoords\",\n    \"gl_MaxTextureImageUnits\",\n    \"gl_MaxTextureUnits\",\n    \"gl_MaxVaryingFloats\",\n    \"gl_MaxVertexAttribs\",\n    \"gl_MaxVertexTextureImageUnits\",\n    \"gl_MaxVertexUniformComponents\",\n    \"gl_ModelViewMatrix\",\n    \"gl_ModelViewMatrixInverse\",\n    \"gl_ModelViewMatrixInverseTranspose\",\n    \"gl_ModelViewMatrixTranspose\",\n    \"gl_ModelViewProjectionMatrix\",\n    \"gl_ModelViewProjectionMatrixInverse\",\n    \"gl_ModelViewProjectionMatrixInverseTranspose\",\n    \"gl_ModelViewProjectionMatrixTranspose\",\n    \"gl_MultiTexCoord0\",\n    \"gl_MultiTexCoord1\",\n    \"gl_MultiTexCoord2\",\n    \"gl_MultiTexCoord3\",\n    \"gl_MultiTexCoord4\",\n    \"gl_MultiTexCoord5\",\n    \"gl_MultiTexCoord6\",\n    \"gl_MultiTexCoord7\",\n    \"gl_Normal\",\n    \"gl_NormalMatrix\",\n    \"gl_NormalScale\",\n    \"gl_ObjectPlaneQ\",\n    \"gl_ObjectPlaneR\",\n    \"gl_ObjectPlaneS\",\n    \"gl_ObjectPlaneT\",\n    \"gl_Point\",\n    \"gl_PointCoord\",\n    \"gl_PointParameters\",\n    \"gl_PointSize\",\n    \"gl_Position\",\n    \"gl_ProjectionMatrix\",\n    \"gl_ProjectionMatrixInverse\",\n    \"gl_ProjectionMatrixInverseTranspose\",\n    \"gl_ProjectionMatrixTranspose\",\n    \"gl_SecondaryColor\",\n    \"gl_TexCoord\",\n    \"gl_TextureEnvColor\",\n    \"gl_TextureMatrix\",\n    \"gl_TextureMatrixInverse\",\n    \"gl_TextureMatrixInverseTranspose\",\n    \"gl_TextureMatrixTranspose\",\n    \"gl_Vertex\",\n    \"greaterThan\",\n    \"greaterThanEqual\",\n    \"inversesqrt\",\n    \"length\",\n    \"lessThan\",\n    \"lessThanEqual\",\n    \"log\",\n    \"log2\",\n    \"matrixCompMult\",\n    \"max\",\n    \"min\",\n    \"mix\",\n    \"mod\",\n    \"normalize\",\n    \"not\",\n    \"notEqual\",\n    \"pow\",\n    \"radians\",\n    \"reflect\",\n    \"refract\",\n    \"sign\",\n    \"sin\",\n    \"smoothstep\",\n    \"sqrt\",\n    \"step\",\n    \"tan\",\n    \"texture2D\",\n    \"texture2DLod\",\n    \"texture2DProj\",\n    \"texture2DProjLod\",\n    \"textureCube\",\n    \"textureCubeLod\",\n    \"texture2DLodEXT\",\n    \"texture2DProjLodEXT\",\n    \"textureCubeLodEXT\",\n    \"texture2DGradEXT\",\n    \"texture2DProjGradEXT\",\n    \"textureCubeGradEXT\"\n  ]), Ki;\n}\nvar qi, Xr;\nfunction Vd() {\n  if (Xr) return qi;\n  Xr = 1;\n  var r = vl();\n  return qi = r.slice().concat([\n    \"layout\",\n    \"centroid\",\n    \"smooth\",\n    \"case\",\n    \"mat2x2\",\n    \"mat2x3\",\n    \"mat2x4\",\n    \"mat3x2\",\n    \"mat3x3\",\n    \"mat3x4\",\n    \"mat4x2\",\n    \"mat4x3\",\n    \"mat4x4\",\n    \"uvec2\",\n    \"uvec3\",\n    \"uvec4\",\n    \"samplerCubeShadow\",\n    \"sampler2DArray\",\n    \"sampler2DArrayShadow\",\n    \"isampler2D\",\n    \"isampler3D\",\n    \"isamplerCube\",\n    \"isampler2DArray\",\n    \"usampler2D\",\n    \"usampler3D\",\n    \"usamplerCube\",\n    \"usampler2DArray\",\n    \"coherent\",\n    \"restrict\",\n    \"readonly\",\n    \"writeonly\",\n    \"resource\",\n    \"atomic_uint\",\n    \"noperspective\",\n    \"patch\",\n    \"sample\",\n    \"subroutine\",\n    \"common\",\n    \"partition\",\n    \"active\",\n    \"filter\",\n    \"image1D\",\n    \"image2D\",\n    \"image3D\",\n    \"imageCube\",\n    \"iimage1D\",\n    \"iimage2D\",\n    \"iimage3D\",\n    \"iimageCube\",\n    \"uimage1D\",\n    \"uimage2D\",\n    \"uimage3D\",\n    \"uimageCube\",\n    \"image1DArray\",\n    \"image2DArray\",\n    \"iimage1DArray\",\n    \"iimage2DArray\",\n    \"uimage1DArray\",\n    \"uimage2DArray\",\n    \"image1DShadow\",\n    \"image2DShadow\",\n    \"image1DArrayShadow\",\n    \"image2DArrayShadow\",\n    \"imageBuffer\",\n    \"iimageBuffer\",\n    \"uimageBuffer\",\n    \"sampler1DArray\",\n    \"sampler1DArrayShadow\",\n    \"isampler1D\",\n    \"isampler1DArray\",\n    \"usampler1D\",\n    \"usampler1DArray\",\n    \"isampler2DRect\",\n    \"usampler2DRect\",\n    \"samplerBuffer\",\n    \"isamplerBuffer\",\n    \"usamplerBuffer\",\n    \"sampler2DMS\",\n    \"isampler2DMS\",\n    \"usampler2DMS\",\n    \"sampler2DMSArray\",\n    \"isampler2DMSArray\",\n    \"usampler2DMSArray\"\n  ]), qi;\n}\nvar Qi, $r;\nfunction Yd() {\n  if ($r) return Qi;\n  $r = 1;\n  var r = yl();\n  return r = r.slice().filter(function(e) {\n    return !/^(gl\\_|texture)/.test(e);\n  }), Qi = r.concat([\n    // the updated gl_ constants\n    \"gl_VertexID\",\n    \"gl_InstanceID\",\n    \"gl_Position\",\n    \"gl_PointSize\",\n    \"gl_FragCoord\",\n    \"gl_FrontFacing\",\n    \"gl_FragDepth\",\n    \"gl_PointCoord\",\n    \"gl_MaxVertexAttribs\",\n    \"gl_MaxVertexUniformVectors\",\n    \"gl_MaxVertexOutputVectors\",\n    \"gl_MaxFragmentInputVectors\",\n    \"gl_MaxVertexTextureImageUnits\",\n    \"gl_MaxCombinedTextureImageUnits\",\n    \"gl_MaxTextureImageUnits\",\n    \"gl_MaxFragmentUniformVectors\",\n    \"gl_MaxDrawBuffers\",\n    \"gl_MinProgramTexelOffset\",\n    \"gl_MaxProgramTexelOffset\",\n    \"gl_DepthRangeParameters\",\n    \"gl_DepthRange\",\n    \"trunc\",\n    \"round\",\n    \"roundEven\",\n    \"isnan\",\n    \"isinf\",\n    \"floatBitsToInt\",\n    \"floatBitsToUint\",\n    \"intBitsToFloat\",\n    \"uintBitsToFloat\",\n    \"packSnorm2x16\",\n    \"unpackSnorm2x16\",\n    \"packUnorm2x16\",\n    \"unpackUnorm2x16\",\n    \"packHalf2x16\",\n    \"unpackHalf2x16\",\n    \"outerProduct\",\n    \"transpose\",\n    \"determinant\",\n    \"inverse\",\n    \"texture\",\n    \"textureSize\",\n    \"textureProj\",\n    \"textureLod\",\n    \"textureOffset\",\n    \"texelFetch\",\n    \"texelFetchOffset\",\n    \"textureProjOffset\",\n    \"textureLodOffset\",\n    \"textureProjLod\",\n    \"textureProjLodOffset\",\n    \"textureGrad\",\n    \"textureGradOffset\",\n    \"textureProjGrad\",\n    \"textureProjGradOffset\"\n  ]), Qi;\n}\nvar Ji, Zr;\nfunction Wd() {\n  if (Zr) return Ji;\n  Zr = 1, Ji = M;\n  var r = vl(), e = jd(), t = yl(), n = Vd(), s = Yd(), i = 999, o = 9999, a = 0, l = 1, c = 2, f = 3, u = 4, d = 5, h = 6, m = 7, g = 8, v = 9, p = 10, b = 11, _ = [\n    \"block-comment\",\n    \"line-comment\",\n    \"preprocessor\",\n    \"operator\",\n    \"integer\",\n    \"float\",\n    \"ident\",\n    \"builtin\",\n    \"keyword\",\n    \"whitespace\",\n    \"eof\",\n    \"integer\"\n  ];\n  function M(R) {\n    var w = 0, E = 0, x = i, T, y, A = [], C = [], N = 1, U = 0, Y = 0, V = !1, ne = !1, Z = \"\", ee;\n    R = R || {};\n    var te = t, fe = r;\n    R.version === \"300 es\" && (te = s, fe = n);\n    for (var he = {}, we = {}, w = 0; w < te.length; w++)\n      he[te[w]] = !0;\n    for (var w = 0; w < fe.length; w++)\n      we[fe[w]] = !0;\n    return function(G) {\n      return C = [], G !== null ? B(G) : D();\n    };\n    function I(G) {\n      G.length && C.push({\n        type: _[x],\n        data: G,\n        position: Y,\n        line: N,\n        column: U\n      });\n    }\n    function B(G) {\n      w = 0, G.toString && (G = G.toString()), Z += G.replace(/\\r\\n/g, `\n`), ee = Z.length;\n      for (var k; T = Z[w], w < ee; ) {\n        switch (k = w, x) {\n          case a:\n            w = L();\n            break;\n          case l:\n            w = P();\n            break;\n          case c:\n            w = S();\n            break;\n          case f:\n            w = X();\n            break;\n          case u:\n            w = K();\n            break;\n          case b:\n            w = j();\n            break;\n          case d:\n            w = se();\n            break;\n          case o:\n            w = ie();\n            break;\n          case v:\n            w = z();\n            break;\n          case i:\n            w = O();\n            break;\n        }\n        if (k !== w)\n          switch (Z[k]) {\n            case `\n`:\n              U = 0, ++N;\n              break;\n            default:\n              ++U;\n              break;\n          }\n      }\n      return E += w, Z = Z.slice(w), C;\n    }\n    function D(G) {\n      return A.length && I(A.join(\"\")), x = p, I(\"(eof)\"), C;\n    }\n    function O() {\n      return A = A.length ? [] : A, y === \"/\" && T === \"*\" ? (Y = E + w - 1, x = a, y = T, w + 1) : y === \"/\" && T === \"/\" ? (Y = E + w - 1, x = l, y = T, w + 1) : T === \"#\" ? (x = c, Y = E + w, w) : /\\s/.test(T) ? (x = v, Y = E + w, w) : (V = /\\d/.test(T), ne = /[^\\w_]/.test(T), Y = E + w, x = V ? u : ne ? f : o, w);\n    }\n    function z() {\n      return /[^\\s]/g.test(T) ? (I(A.join(\"\")), x = i, w) : (A.push(T), y = T, w + 1);\n    }\n    function S() {\n      return (T === \"\\r\" || T === `\n`) && y !== \"\\\\\" ? (I(A.join(\"\")), x = i, w) : (A.push(T), y = T, w + 1);\n    }\n    function P() {\n      return S();\n    }\n    function L() {\n      return T === \"/\" && y === \"*\" ? (A.push(T), I(A.join(\"\")), x = i, w + 1) : (A.push(T), y = T, w + 1);\n    }\n    function X() {\n      if (y === \".\" && /\\d/.test(T))\n        return x = d, w;\n      if (y === \"/\" && T === \"*\")\n        return x = a, w;\n      if (y === \"/\" && T === \"/\")\n        return x = l, w;\n      if (T === \".\" && A.length) {\n        for (; H(A); ) ;\n        return x = d, w;\n      }\n      if (T === \";\" || T === \")\" || T === \"(\") {\n        if (A.length) for (; H(A); ) ;\n        return I(T), x = i, w + 1;\n      }\n      var G = A.length === 2 && T !== \"=\";\n      if (/[\\w_\\d\\s]/.test(T) || G) {\n        for (; H(A); ) ;\n        return x = i, w;\n      }\n      return A.push(T), y = T, w + 1;\n    }\n    function H(G) {\n      var k = 0, oe, ge;\n      do {\n        if (oe = e.indexOf(G.slice(0, G.length + k).join(\"\")), ge = e[oe], oe === -1) {\n          if (k-- + G.length > 0) continue;\n          ge = G.slice(0, 1).join(\"\");\n        }\n        return I(ge), Y += ge.length, A = A.slice(ge.length), A.length;\n      } while (!0);\n    }\n    function j() {\n      return /[^a-fA-F0-9]/.test(T) ? (I(A.join(\"\")), x = i, w) : (A.push(T), y = T, w + 1);\n    }\n    function K() {\n      return T === \".\" || /[eE]/.test(T) ? (A.push(T), x = d, y = T, w + 1) : T === \"x\" && A.length === 1 && A[0] === \"0\" ? (x = b, A.push(T), y = T, w + 1) : /[^\\d]/.test(T) ? (I(A.join(\"\")), x = i, w) : (A.push(T), y = T, w + 1);\n    }\n    function se() {\n      return T === \"f\" && (A.push(T), y = T, w += 1), /[eE]/.test(T) || (T === \"-\" || T === \"+\") && /[eE]/.test(y) ? (A.push(T), y = T, w + 1) : /[^\\d]/.test(T) ? (I(A.join(\"\")), x = i, w) : (A.push(T), y = T, w + 1);\n    }\n    function ie() {\n      if (/[^\\d\\w_]/.test(T)) {\n        var G = A.join(\"\");\n        return we[G] ? x = g : he[G] ? x = m : x = h, I(A.join(\"\")), x = i, w;\n      }\n      return A.push(T), y = T, w + 1;\n    }\n  }\n  return Ji;\n}\nvar eo, Kr;\nfunction Xd() {\n  if (Kr) return eo;\n  Kr = 1;\n  var r = Wd();\n  eo = e;\n  function e(t, n) {\n    var s = r(n), i = [];\n    return i = i.concat(s(t)), i = i.concat(s(null)), i;\n  }\n  return eo;\n}\nvar $d = Xd();\nconst Zd = /* @__PURE__ */ Ps($d);\nvar to, qr;\nfunction Kd() {\n  if (qr) return to;\n  qr = 1, to = r;\n  function r(e) {\n    for (var t = [], n = 0; n < e.length; n++)\n      e[n].type !== \"eof\" && t.push(e[n].data);\n    return t.join(\"\");\n  }\n  return to;\n}\nvar qd = Kd();\nconst Qr = /* @__PURE__ */ Ps(qd);\nvar no, Jr;\nfunction Qd() {\n  if (Jr) return no;\n  Jr = 1, no = r;\n  function r(n) {\n    var s = null, i = null, o = 0, a = 0, l = 0, c = 0, f = 0, u = [], d, h, m;\n    for (d = 0, h; d < n.length; d++)\n      if (m = n[d], m.data === \"{\") {\n        if (o && o++ || (h = v(d, e(\")\"), e()), h < 0) || (c = h, h = v(h, e(\"(\"), e(\")\")), h < 0) || (f = h, h = v(h, t), h < 0) || n[h].type !== \"ident\" || (i = n[h].data, h = v(h, t), h < 0)) continue;\n        o = 1, a = d, s = n[h].data, l = h;\n        var g = v(h, t);\n        switch (n[g] && n[g].data) {\n          case \"lowp\":\n          case \"highp\":\n          case \"mediump\":\n            l = g;\n        }\n      } else if (o && m.data === \"}\") {\n        if (--o) continue;\n        u.push({\n          name: i,\n          type: s,\n          body: [a + 1, d],\n          args: [f, c + 1],\n          outer: [l, d + 1]\n        });\n      }\n    for (d = 0; d < n.length; d++)\n      if (m = n[d], m.data === \";\") {\n        if (h = v(d, e(\")\"), e()), h < 0 || (c = h, h = v(h, e(\"(\"), e(\")\")), h < 0) || (f = h, h = v(h, t), h < 0) || n[h].type !== \"ident\" || (i = n[h].data, h = v(h, t), h < 0) || n[h].type === \"operator\" || n[h].data === \"return\") continue;\n        s = n[h].data, u.push({\n          name: i,\n          type: s,\n          body: !1,\n          args: [f, c + 1],\n          outer: [h, d + 1]\n        });\n      }\n    return u.sort(function(p, b) {\n      return p.outer[0] - b.outer[0];\n    });\n    function v(p, b, _) {\n      for (var M = p - 1; M >= 0; M--) {\n        if (b(n[M])) return M;\n        if (_ && _(n[M])) return -1;\n      }\n      return -1;\n    }\n  }\n  function e(n) {\n    return function(s) {\n      return s.type === \"operator\" && (!n || s.data === n);\n    };\n  }\n  function t(n) {\n    return n.type !== \"whitespace\";\n  }\n  return no;\n}\nvar Jd = Qd();\nconst ep = /* @__PURE__ */ Ps(Jd);\nfunction tp(r, e) {\n  if (typeof r != \"object\" || r === null) return r;\n  var t = r[Symbol.toPrimitive];\n  if (t !== void 0) {\n    var n = t.call(r, e);\n    if (typeof n != \"object\") return n;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return String(r);\n}\nfunction _l(r) {\n  var e = tp(r, \"string\");\n  return typeof e == \"symbol\" ? e : String(e);\n}\nfunction Ge(r, e, t) {\n  return e = _l(e), e in r ? Object.defineProperty(r, e, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : r[e] = t, r;\n}\nfunction ea(r, e) {\n  var t = Object.keys(r);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(r);\n    e && (n = n.filter(function(s) {\n      return Object.getOwnPropertyDescriptor(r, s).enumerable;\n    })), t.push.apply(t, n);\n  }\n  return t;\n}\nfunction Xn(r) {\n  for (var e = 1; e < arguments.length; e++) {\n    var t = arguments[e] != null ? arguments[e] : {};\n    e % 2 ? ea(Object(t), !0).forEach(function(n) {\n      Ge(r, n, t[n]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ea(Object(t)).forEach(function(n) {\n      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));\n    });\n  }\n  return r;\n}\nfunction np(r, e) {\n  if (r == null) return {};\n  var t = {}, n = Object.keys(r), s, i;\n  for (i = 0; i < n.length; i++)\n    s = n[i], !(e.indexOf(s) >= 0) && (t[s] = r[s]);\n  return t;\n}\nfunction sp(r, e) {\n  if (r == null) return {};\n  var t = np(r, e), n, s;\n  if (Object.getOwnPropertySymbols) {\n    var i = Object.getOwnPropertySymbols(r);\n    for (s = 0; s < i.length; s++)\n      n = i[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (t[n] = r[n]);\n  }\n  return t;\n}\nfunction ip(r, e) {\n  if (!(r instanceof e))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction op(r, e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(r, _l(n.key), n);\n  }\n}\nfunction rp(r, e, t) {\n  return e && op(r.prototype, e), Object.defineProperty(r, \"prototype\", {\n    writable: !1\n  }), r;\n}\nfunction xl(r) {\n  if (r === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return r;\n}\nfunction To(r, e) {\n  return To = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {\n    return n.__proto__ = s, n;\n  }, To(r, e);\n}\nfunction ap(r, e) {\n  if (typeof e != \"function\" && e !== null)\n    throw new TypeError(\"Super expression must either be null or a function\");\n  r.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: r,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(r, \"prototype\", {\n    writable: !1\n  }), e && To(r, e);\n}\nfunction ri(r) {\n  return ri = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, ri(r);\n}\nfunction lp() {\n  if (typeof Reflect > \"u\" || !Reflect.construct || Reflect.construct.sham) return !1;\n  if (typeof Proxy == \"function\") return !0;\n  try {\n    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    })), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction cp(r, e) {\n  if (e && (typeof e == \"object\" || typeof e == \"function\"))\n    return e;\n  if (e !== void 0)\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return xl(r);\n}\nfunction up(r) {\n  var e = lp();\n  return function() {\n    var n = ri(r), s;\n    if (e) {\n      var i = ri(this).constructor;\n      s = Reflect.construct(n, arguments, i);\n    } else\n      s = n.apply(this, arguments);\n    return cp(this, s);\n  };\n}\nvar Me = {\n  position: \"csm_Position\",\n  positionRaw: \"csm_PositionRaw\",\n  pointSize: \"csm_PointSize\",\n  fragColor: \"csm_FragColor\",\n  // PBR\n  diffuseColor: \"csm_DiffuseColor\",\n  // Color + alpha\n  normal: \"csm_Normal\",\n  // Normal\n  roughness: \"csm_Roughness\",\n  // Roughness\n  metalness: \"csm_Metalness\",\n  // Metalness\n  emissive: \"csm_Emissive\",\n  // Emissive\n  ao: \"csm_AO\",\n  // AO\n  bump: \"csm_Bump\",\n  // Bump\n  depthAlpha: \"csm_DepthAlpha\"\n  // Depth\n}, dt, $n, hp = (dt = {}, Ge(dt, \"\".concat(Me.normal), {\n  \"#include <beginnormal_vertex>\": `\n    vec3 objectNormal = `.concat(Me.normal, `;\n    #ifdef USE_TANGENT\n\t    vec3 objectTangent = vec3( tangent.xyz );\n    #endif\n    `)\n}), Ge(dt, \"\".concat(Me.position), {\n  \"#include <begin_vertex>\": `\n    vec3 transformed = `.concat(Me.position, `;\n  `)\n}), Ge(dt, \"\".concat(Me.positionRaw), {\n  \"#include <begin_vertex>\": `\n    vec4 csm_internal_positionUnprojected = `.concat(Me.positionRaw, `;\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\n    #ifdef USE_INSTANCING\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\n    #endif\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\n  `)\n}), Ge(dt, \"\".concat(Me.pointSize), {\n  \"gl_PointSize = size;\": `\n    gl_PointSize = `.concat(Me.pointSize, `;\n    `)\n}), Ge(dt, \"\".concat(Me.diffuseColor), {\n  \"#include <color_fragment>\": `\n    #include <color_fragment>\n    diffuseColor = `.concat(Me.diffuseColor, `;\n  `)\n}), Ge(dt, \"\".concat(Me.fragColor), {\n  \"#include <dithering_fragment>\": `\n    #include <dithering_fragment>\n    gl_FragColor  = `.concat(Me.fragColor, `;\n  `)\n}), Ge(dt, \"\".concat(Me.emissive), {\n  \"vec3 totalEmissiveRadiance = emissive;\": `\n    vec3 totalEmissiveRadiance = `.concat(Me.emissive, `;\n    `)\n}), Ge(dt, \"\".concat(Me.roughness), {\n  \"#include <roughnessmap_fragment>\": `\n    #include <roughnessmap_fragment>\n    roughnessFactor = `.concat(Me.roughness, `;\n    `)\n}), Ge(dt, \"\".concat(Me.metalness), {\n  \"#include <metalnessmap_fragment>\": `\n    #include <metalnessmap_fragment>\n    metalnessFactor = `.concat(Me.metalness, `;\n    `)\n}), Ge(dt, \"\".concat(Me.ao), {\n  \"#include <aomap_fragment>\": `\n    #include <aomap_fragment>\n    reflectedLight.indirectDiffuse *= 1. - `.concat(Me.ao, `;\n    `)\n}), Ge(dt, \"\".concat(Me.bump), {\n  \"#include <normal_fragment_maps>\": `\n    #include <normal_fragment_maps>\n\n    vec3 csm_internal_orthogonal = `.concat(Me.bump, \" - (dot(\").concat(Me.bump, `, normal) * normal);\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\n    normal = normalize(normal - csm_internal_projectedbump);\n    `)\n}), Ge(dt, \"\".concat(Me.depthAlpha), {\n  \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\": `\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(Me.depthAlpha, ` );\n    `),\n  \"gl_FragColor = packDepthToRGBA( fragCoordZ );\": `\n      gl_FragColor = packDepthToRGBA( fragCoordZ );\n      gl_FragColor.a *= `.concat(Me.depthAlpha, `;\n    `)\n}), dt), fp = ($n = {}, Ge($n, \"\".concat(Me.position), {\n  \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\": `\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(Me.position, `, 1.0 );\n  `)\n}), Ge($n, \"\".concat(Me.positionRaw), {\n  \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\": `\n    gl_Position = `.concat(Me.position, `;\n  `)\n}), Ge($n, \"\".concat(Me.diffuseColor), {\n  \"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\": `\n    gl_FragColor = `.concat(Me.diffuseColor, `;\n  `)\n}), Ge($n, \"\".concat(Me.fragColor), {\n  \"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\": `\n    gl_FragColor = `.concat(Me.fragColor, `;\n  `)\n}), $n), dp = (\n  /* glsl */\n  `\n\n#ifdef IS_VERTEX\n    // csm_Position & csm_PositionRaw\n    #ifdef IS_UNKNOWN\n        vec3 csm_Position = vec3(0.0);\n        vec4 csm_PositionRaw = vec4(0.0);\n        vec3 csm_Normal = vec3(0.0);\n    #else\n        vec3 csm_Position = position;\n        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n        vec3 csm_Normal = normal;\n    #endif\n\n    // csm_PointSize\n    #ifdef IS_POINTSMATERIAL\n        float csm_PointSize = size;\n    #endif\n#else\n    // csm_DiffuseColor & csm_FragColor\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\n        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #else\n        #ifdef USE_MAP\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\n\n            #ifdef DECODE_VIDEO_TEXTURE\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\n            #endif\n\n            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\n        #else\n            vec4 csm_DiffuseColor = vec4(diffuse, opacity);\n            vec4 csm_FragColor = vec4(diffuse, opacity);\n        #endif\n    #endif\n\n    // csm_Emissive, csm_Roughness, csm_Metalness\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n        vec3 csm_Emissive = emissive;\n        float csm_Roughness = roughness;\n        float csm_Metalness = metalness;\n    #endif\n\n    // csm_AO\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\n        float csm_AO = 0.0;\n    #endif\n\n    // csm_Bump\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \n        vec3 csm_Bump = vec3(0.0);\n    #endif\n\n    float csm_DepthAlpha = 1.0;\n#endif\n`\n), pp = (\n  /* glsl */\n  `\n    varying mat4 csm_internal_vModelViewMatrix;\n`\n), mp = (\n  /* glsl */\n  `\n    csm_internal_vModelViewMatrix = modelViewMatrix;\n`\n), gp = (\n  /* glsl */\n  `\n    varying mat4 csm_internal_vModelViewMatrix;\n`\n), vp = (\n  /* glsl */\n  `\n    \n`\n), pt, yp = (pt = {}, Ge(pt, \"\".concat(Me.position), \"*\"), Ge(pt, \"\".concat(Me.positionRaw), \"*\"), Ge(pt, \"\".concat(Me.normal), \"*\"), Ge(pt, \"\".concat(Me.pointSize), [\"PointsMaterial\"]), Ge(pt, \"\".concat(Me.diffuseColor), \"*\"), Ge(pt, \"\".concat(Me.fragColor), \"*\"), Ge(pt, \"\".concat(Me.emissive), [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"]), Ge(pt, \"\".concat(Me.roughness), [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"]), Ge(pt, \"\".concat(Me.metalness), [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"]), Ge(pt, \"\".concat(Me.ao), [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\", \"MeshBasicMaterial\", \"MeshLambertMaterial\", \"MeshPhongMaterial\", \"MeshToonMaterial\"]), Ge(pt, \"\".concat(Me.bump), [\"MeshLambertMaterial\", \"MeshMatcapMaterial\", \"MeshNormalMaterial\", \"MeshPhongMaterial\", \"MeshPhysicalMaterial\", \"MeshStandardMaterial\", \"MeshToonMaterial\", \"ShadowMaterial\"]), Ge(pt, \"\".concat(Me.depthAlpha), \"*\"), pt), _p = [\"baseMaterial\", \"fragmentShader\", \"vertexShader\", \"uniforms\", \"patchMap\", \"cacheKey\", \"silent\"], xp = function(e, t, n) {\n  return e.split(t).join(n);\n}, wp = function(e) {\n  return e.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}, Tp = function(e, t) {\n  return new RegExp(\"\\\\b\".concat(wp(t), \"\\\\b\")).test(e);\n};\nfunction bp(r) {\n  try {\n    new r();\n  } catch (e) {\n    if (e.message.indexOf(\"is not a constructor\") >= 0)\n      return !1;\n  }\n  return !0;\n}\nfunction Ep(r, e) {\n  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n  Object.assign(r, e);\n  var n = Object.getPrototypeOf(e);\n  Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(s) {\n    var i = typeof s[1].get == \"function\", o = typeof s[1].set == \"function\", a = typeof s[1].value == \"function\", l = s[0] === \"constructor\";\n    return (i || o || a) && !l;\n  }).forEach(function(s) {\n    if (typeof r[s[0]] == \"function\") {\n      t || console.warn(\"Function \".concat(s[0], \" already exists on CSM, renaming to base_\").concat(s[0]));\n      var i = \"base_\".concat(s[0]);\n      r[i] = s[1].value.bind(r);\n      return;\n    }\n    Object.defineProperty(r, s[0], s[1]);\n  });\n}\nfunction Mp(r) {\n  var e = r.toString().trim(), t = e.substring(e.indexOf(\"{\") + 1, e.lastIndexOf(\"}\"));\n  return t.trim().length === 0;\n}\nfunction ta(r) {\n  return r.replace(/\\s/g, \"\");\n}\nfunction Sp(r, e, t) {\n  var n = r.lastIndexOf(e);\n  return n === -1 ? r : r.substring(0, n) + t + r.substring(n + e.length);\n}\nvar Ap = /* @__PURE__ */ function(r) {\n  ap(t, r);\n  var e = up(t);\n  function t(n) {\n    var s, i = n.baseMaterial, o = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, f = n.cacheKey, u = n.silent, d = sp(n, _p);\n    ip(this, t);\n    var h;\n    if (bp(i) ? h = new i(d) : (h = i, Object.assign(h, d)), h.type === \"RawShaderMaterial\")\n      throw new Error(\"CustomShaderMaterial does not support RawShaderMaterial\");\n    s = e.call(this), Ep(xl(s), h, u), s.__csm = {\n      patchMap: c || {},\n      fragmentShader: o || \"\",\n      vertexShader: a || \"\",\n      cacheKey: f,\n      baseMaterial: i,\n      instanceID: Jn.MathUtils.generateUUID(),\n      type: h.type,\n      isAlreadyExtended: !Mp(h.onBeforeCompile),\n      cacheHash: \"\",\n      silent: u\n    }, s.uniforms = Xn(Xn({}, s.uniforms || {}), l || {});\n    {\n      var m = s.__csm, g = m.fragmentShader, v = m.vertexShader, p = s.uniforms;\n      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(g, v, p);\n    }\n    return s;\n  }\n  return rp(t, [{\n    key: \"update\",\n    value: function() {\n      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n      this.uniforms = s.uniforms || this.uniforms, Object.assign(this.__csm, s);\n      var i = this.__csm, o = i.fragmentShader, a = i.vertexShader, l = this.uniforms, c = this.getCacheHash();\n      this.__csm.cacheHash = c, this.generateMaterial(o, a, l);\n    }\n    /**\n     * Returns a new instance of this material with the same options.\n     *\n     * @returns A clone of this material.\n     */\n  }, {\n    key: \"clone\",\n    value: function() {\n      var s = {\n        baseMaterial: this.__csm.baseMaterial,\n        fragmentShader: this.__csm.fragmentShader,\n        vertexShader: this.__csm.vertexShader,\n        uniforms: this.uniforms,\n        silent: this.__csm.silent,\n        patchMap: this.__csm.patchMap,\n        cacheKey: this.__csm.cacheKey\n      }, i = new this.constructor(s);\n      return Object.assign(this, i), i;\n    }\n    /**\n     * Internally calculates the cache key for this instance of CSM.\n     * If no specific CSM inputs are provided, the cache key is the same as the default\n     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.\n     *\n     * This method is quite expensive owing to the hashing function and string manip.\n     *\n     * TODO:\n     * - Optimize string manip.\n     * - Find faster hash function\n     *\n     * @returns {string} A cache key for this instance of CSM.\n     */\n  }, {\n    key: \"getCacheHash\",\n    value: function() {\n      var s = this.__csm, i = s.fragmentShader, o = s.vertexShader, a = this.uniforms, l = Object.values(a).reduce(function(f, u) {\n        var d = u.value;\n        return f + JSON.stringify(d);\n      }, \"\"), c = ta(i) + ta(o) + l;\n      return c.trim().length > 0 ? Hd(c) : this.customProgramCacheKey();\n    }\n    /**\n     * Does the internal shader generation. Not meant to be called directly.\n     *\n     * @param fragmentShader\n     * @param vertexShader\n     * @param uniforms\n     */\n  }, {\n    key: \"generateMaterial\",\n    value: function(s, i, o) {\n      var a = this, l = this.parseShader(s), c = this.parseShader(i);\n      this.uniforms = o || {}, this.customProgramCacheKey = function() {\n        return a.__csm.cacheHash;\n      };\n      var f = function(h) {\n        try {\n          if (l) {\n            var m = a.patchShader(l, h.fragmentShader, !0);\n            h.fragmentShader = a.getMaterialDefine() + m;\n          }\n          if (c) {\n            var g = a.patchShader(c, h.vertexShader);\n            h.vertexShader = `#define IS_VERTEX;\n` + g, h.vertexShader = a.getMaterialDefine() + h.vertexShader;\n          }\n          h.uniforms = Xn(Xn({}, h.uniforms), a.uniforms), a.uniforms = h.uniforms;\n        } catch (v) {\n          console.error(v);\n        }\n      };\n      if (this.__csm.isAlreadyExtended) {\n        var u = this.onBeforeCompile;\n        this.onBeforeCompile = function(d, h) {\n          u(d, h), f(d);\n        };\n      } else\n        this.onBeforeCompile = f;\n      this.needsUpdate = !0;\n    }\n    /**\n     * Patches input shader with custom shader. Not meant to be called directly.\n     * @param customShader\n     * @param shader\n     * @param isFrag\n     * @returns\n     */\n  }, {\n    key: \"patchShader\",\n    value: function(s, i, o) {\n      var a = this, l = i, c = Xn(Xn({}, this.getPatchMapForMaterial()), this.__csm.patchMap);\n      Object.keys(c).forEach(function(d) {\n        Object.keys(c[d]).forEach(function(h) {\n          var m = yp[d], g = a.__csm.type;\n          if (d === \"*\" || Tp(s.main, d))\n            if (!m || Array.isArray(m) && m.includes(g) || m === \"*\")\n              l = xp(l, h, c[d][h]);\n            else\n              throw new Error(\"CSM: \".concat(d, \" is not available in \").concat(g, \". Shader cannot compile.\"));\n        });\n      }), l = l.replace(\"void main() {\", `\n        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED\n          `.concat(o ? gp : pp, `\n          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1\n        #endif\n\n        `).concat(s.header, `\n        \n        void main() {\n          #ifndef CSM_IS_DEFAULTS_DEFINED\n            `).concat(dp, `\n            #define CSM_IS_DEFAULTS_DEFINED 1\n          #endif\n          \n          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED\n            `).concat(o ? vp : mp, `\n            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1\n          #endif\n\n          // CSM_START\n      `));\n      var f = this.__csm.isAlreadyExtended, u = l.includes(\"// CSM_END\");\n      return f && u ? l = Sp(l, \"// CSM_END\", `\n          // CSM_END\n          `.concat(s.main, `\n          // CSM_END\n        `)) : l = l.replace(\"// CSM_START\", `\n        // CSM_START\n        `.concat(s.main, `\n        // CSM_END\n          `)), l = s.defines + l, l;\n    }\n    /**\n     * This method is expensive owing to the tokenization and parsing of the shader.\n     *\n     * TODO:\n     * - Replace tokenization with regex\n     *\n     * @param shader\n     * @returns\n     */\n  }, {\n    key: \"parseShader\",\n    value: function(s) {\n      if (s) {\n        var i = s.replace(/\\/\\*\\*(.*?)\\*\\/|\\/\\/(.*?)\\n/gm, \"\"), o = Zd(i), a = ep(o), l = a.map(function(u) {\n          return u.name;\n        }).indexOf(\"main\"), c = Qr(o.slice(0, l >= 0 ? a[l].outer[0] : void 0)), f = l >= 0 ? this.getShaderFromIndex(o, a[l].body) : \"\";\n        return {\n          defines: \"\",\n          header: c,\n          main: f\n        };\n      }\n    }\n    /**\n     * Gets the material type as a string. Not meant to be called directly.\n     * @returns\n     */\n  }, {\n    key: \"getMaterialDefine\",\n    value: function() {\n      var s = this.__csm.type;\n      return s ? \"#define IS_\".concat(s.toUpperCase(), `;\n`) : `#define IS_UNKNOWN;\n`;\n    }\n    /**\n     * Gets the right patch map for the material. Not meant to be called directly.\n     * @returns\n     */\n  }, {\n    key: \"getPatchMapForMaterial\",\n    value: function() {\n      switch (this.__csm.type) {\n        case \"ShaderMaterial\":\n          return fp;\n        default:\n          return hp;\n      }\n    }\n    /**\n     * Gets the shader from the tokens. Not meant to be called directly.\n     * @param tokens\n     * @param index\n     * @returns\n     */\n  }, {\n    key: \"getShaderFromIndex\",\n    value: function(s, i) {\n      return Qr(s.slice(i[0], i[1]));\n    }\n  }]), t;\n}(Jn.Material);\nconst Pp = [\"args\"], mv = /* @__PURE__ */ ue({\n  __name: \"index\",\n  props: {\n    baseMaterial: { type: Function },\n    vertexShader: {},\n    fragmentShader: {},\n    silent: { type: Boolean },\n    uniforms: {}\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(null), { extend: s, invalidate: i } = xe();\n    return s({ CustomShaderMaterial: Ap }), J(t, () => i()), e({ instance: n }), (o, a) => (ae(), ce(\"TresCustomShaderMaterial\", {\n      ref_key: \"customShaderMaterialClass\",\n      ref: n,\n      args: [t]\n    }, null, 8, Pp));\n  }\n});\nclass na extends bt {\n  /**\n   * Create a HolographicMaterial.\n   *\n   * @param {object} parameters - The parameters to configure the material.\n   * @param {number} [parameters.time] - The time uniform representing animation time.\n   * @param {number} [parameters.fresnelOpacity] - The opacity for the fresnel effect.\n   * @param {number} [parameters.fresnelAmount] - The strength of the fresnel effect.\n   * @param {number} [parameters.scanlineSize] - The size of the scanline effect.\n   * @param {number} [parameters.hologramBrightness] - The brightness of the hologram.\n   * @param {number} [parameters.signalSpeed] - The speed of the signal effect.\n   * @param {Color} [parameters.hologramColor] - The color of the hologram.\n   * @param {boolean} [parameters.enableBlinking] - Enable/disable blinking effect.\n   * @param {boolean} [parameters.blinkFresnelOnly] - Enable blinking only on the fresnel effect.\n   * @param {number} [parameters.hologramOpacity] - The opacity of the hologram.\n   * @param {number} [parameters.blendMode] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.\n   * @param {number} [parameters.side] - The rendering side. Use `THREE.FrontSide`,\n   *  `THREE.BackSide`, or `THREE.DoubleSide`.\n   * @param {boolean} [parameters.depthTest] - Enable or disable depthTest.\n   */\n  constructor(t = {}) {\n    super();\n    pe(this, \"clock\");\n    this.vertexShader = `\n      #define STANDARD\n      varying vec3 vViewPosition;\n      #ifdef USE_TRANSMISSION\n      varying vec3 vWorldPosition;\n      #endif\n    \n      varying vec2 vUv;\n      varying vec4 vPos;\n      varying vec3 vNormalW;\n      varying vec3 vPositionW;\n\n      #include <common>\n      #include <uv_pars_vertex>\n      #include <envmap_pars_vertex>\n      #include <color_pars_vertex>\n      #include <fog_pars_vertex>\n      #include <morphtarget_pars_vertex>\n      #include <skinning_pars_vertex>\n      #include <logdepthbuf_pars_vertex>\n      #include <clipping_planes_pars_vertex>\n\n      void main() {\n        \n        #include <uv_vertex>\n        #include <color_vertex>\n        #include <morphcolor_vertex>\n      \n        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n      \n          #include <beginnormal_vertex>\n          #include <morphnormal_vertex>\n          #include <skinbase_vertex>\n          #include <skinnormal_vertex>\n          #include <defaultnormal_vertex>\n      \n        #endif\n      \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n      \n        #include <worldpos_vertex>\n        #include <envmap_vertex>\n        #include <fog_vertex>\n\n        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;\n\n        vUv = uv;\n        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );\n        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);\n        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );\n        \n        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );\n\n      }`, this.fragmentShader = ` \n      varying vec2 vUv;\n      varying vec3 vPositionW;\n      varying vec4 vPos;\n      varying vec3 vNormalW;\n      \n      uniform float time;\n      uniform float fresnelOpacity;\n      uniform float scanlineSize;\n      uniform float fresnelAmount;\n      uniform float signalSpeed;\n      uniform float hologramBrightness;\n      uniform float hologramOpacity;\n      uniform bool blinkFresnelOnly;\n      uniform bool enableBlinking;\n      uniform vec3 hologramColor;\n\n      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}\n      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }\n\n      void main() {\n        vec2 vCoords = vPos.xy;\n        vCoords /= vPos.w;\n        vCoords = vCoords * 0.5 + 0.5;\n        vec2 myUV = fract( vCoords );\n\n        // Defines hologram main color\n        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));\n\n        // Add scanlines\n        float scanlines = 10.;\n        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);\n        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);\n        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);\n\n        // Scanlines offsets\n        float r = random(vUv.x, vUv.y);\n        float g = random(vUv.y * 20.2, vUv.y * .2);\n        float b = random(vUv.y * .9, vUv.y * .2);\n\n        // Scanline composition\n        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;\n        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);\n\n        // Calculates fresnel\n        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);\n        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);\n        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);\n\n        // Blinkin effect\n        //Suggested by Octano - https://x.com/OtanoDesign?s=20\n        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;\n        float blink = flicker(blinkValue, time * signalSpeed * .02);\n\n        // Final shader composition\n        vec3 finalColor;\n\n        if(blinkFresnelOnly){\n          finalColor = scanlineMix.rgb + fresnelEffect * blink;\n        }else{\n          finalColor = scanlineMix.rgb * blink + fresnelEffect;\n        }\n\n        gl_FragColor = vec4( finalColor, hologramOpacity);\n\n      }`, this.uniforms = {\n      /**\n       * The time uniform representing animation time.\n       * @type {Uniform<number>}\n       * @default 0.0\n       */\n      time: new Se(0),\n      /**\n       * The opacity for the fresnel effect.\n       * @type {Uniform<number>}\n       * @default 1.0\n       */\n      fresnelOpacity: new Se(t.fresnelOpacity !== void 0 ? t.fresnelOpacity : 1),\n      /**\n       * The strength of the fresnel effect.\n       * @type {Uniform<number>}\n       * @default 1.0\n       */\n      fresnelAmount: new Se(t.fresnelAmount !== void 0 ? t.fresnelAmount : 0.45),\n      /**\n       * The size of the scanline effect.\n       * @type {Uniform<number>}\n       * @default 1.0\n       */\n      scanlineSize: new Se(t.scanlineSize !== void 0 ? t.scanlineSize : 8),\n      /**\n       * The brightness of the hologram.\n       * @type {Uniform<number>}\n       * @default 1.0\n       */\n      hologramBrightness: new Se(t.hologramBrightness !== void 0 ? t.hologramBrightness : 1),\n      /**\n       * The speed of the signal effect.\n       * @type {Uniform<number>}\n       * @default 1.0\n       */\n      signalSpeed: new Se(t.signalSpeed !== void 0 ? t.signalSpeed : 1),\n      /**\n       * The color of the hologram.\n       * @type {Uniform<Color>}\n       * @default new Color(0xFFFFFF)\n       */\n      hologramColor: new Se(t.hologramColor !== void 0 ? new be(t.hologramColor) : new be(\"#00d5ff\")),\n      /**\n       * Enable/disable blinking effect.\n       * @type {Uniform<boolean>}\n       * @default true\n       */\n      enableBlinking: new Se(t.enableBlinking !== void 0 ? t.enableBlinking : !0),\n      /**\n       * Enable blinking only on the fresnel effect.\n       * @type {Uniform<boolean>}\n       * @default false\n       */\n      blinkFresnelOnly: new Se(t.blinkFresnelOnly !== void 0 ? t.blinkFresnelOnly : !0),\n      /**\n       * The opacity of the hologram.\n       * @type {Uniform<number>}\n       * @default 1.0\n       */\n      hologramOpacity: new Se(t.hologramOpacity !== void 0 ? t.hologramOpacity : 1)\n    }, this.clock = new ic(), this.setValues(t), this.depthTest = t.depthTest !== void 0 ? t.depthTest : !1, this.blending = t.blendMode !== void 0 ? t.blendMode : So, this.transparent = !0, this.side = t.side !== void 0 ? t.side : ss;\n  }\n  update() {\n    this.uniforms.time.value = this.clock.getElapsedTime();\n  }\n}\nconst Rp = [\"uniforms-fresnelAmount-value\", \"uniforms-enableBlinking-value\", \"uniforms-fresnelOpacity-value\", \"uniforms-hologramBrightness-value\", \"uniforms-scanlineSize-value\", \"uniforms-signalSpeed-value\", \"uniforms-hologramColor-value\", \"uniforms-hologramOpacity-value\", \"uniforms-blinkFresnelOnly-value\", \"enableAdditive\", \"side\"], gv = /* @__PURE__ */ ue({\n  __name: \"index\",\n  props: {\n    fresnelAmount: { default: 0.45 },\n    fresnelOpacity: { default: 1 },\n    blinkFresnelOnly: { type: Boolean, default: !0 },\n    enableBlinking: { type: Boolean, default: !0 },\n    enableAdditive: { type: Boolean, default: !0 },\n    hologramBrightness: { default: 0.7 },\n    scanlineSize: { default: 8 },\n    signalSpeed: { default: 0.45 },\n    hologramOpacity: { default: 1 },\n    hologramColor: { default: \"#00d5ff\" },\n    side: { default: ss }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), { extend: s } = xe();\n    s({ HolographicMaterial: na }), e({ root: n, constructor: na });\n    const { onBeforeRender: i } = Ve();\n    return i(({ invalidate: o }) => {\n      var a;\n      (a = n.value) == null || a.update(), o();\n    }), (o, a) => (ae(), ce(\"TresHolographicMaterial\", {\n      ref_key: \"MeshHolographicMaterialClass\",\n      ref: n,\n      \"uniforms-fresnelAmount-value\": t.fresnelAmount,\n      \"uniforms-enableBlinking-value\": t.enableBlinking,\n      \"uniforms-fresnelOpacity-value\": t.fresnelOpacity,\n      \"uniforms-hologramBrightness-value\": t.hologramBrightness,\n      \"uniforms-scanlineSize-value\": t.scanlineSize,\n      \"uniforms-signalSpeed-value\": t.signalSpeed,\n      \"uniforms-hologramColor-value\": t.hologramColor,\n      \"uniforms-hologramOpacity-value\": t.hologramOpacity,\n      \"uniforms-blinkFresnelOnly-value\": t.blinkFresnelOnly,\n      enableAdditive: t.enableAdditive,\n      side: t.side\n    }, null, 8, Rp));\n  }\n});\nclass Cp extends bt {\n  constructor() {\n    super(), this.vertexShader = \"void main() { }\", this.fragmentShader = \"void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;}\";\n  }\n}\nconst vv = /* @__PURE__ */ ue({\n  __name: \"index\",\n  setup(r, { expose: e }) {\n    const t = re(), { extend: n } = xe();\n    return n({ MeshDiscardMaterial: Cp }), e({ instance: t }), (s, i) => (ae(), ce(\"TresMeshDiscardMaterial\", {\n      ref_key: \"meshDiscardMaterialRef\",\n      ref: t\n    }, null, 512));\n  }\n});\nclass Ip extends Es {\n  constructor(t = {}) {\n    super();\n    pe(this, \"isMeshPhysicalMaterial\");\n    pe(this, \"clearcoatMap\");\n    pe(this, \"clearcoatRoughness\");\n    pe(this, \"clearcoatRoughnessMap\");\n    pe(this, \"clearcoatNormalScale\");\n    pe(this, \"clearcoatNormalMap\");\n    pe(this, \"ior\");\n    pe(this, \"transmissionMap\");\n    pe(this, \"thickness\");\n    pe(this, \"thicknessMap\");\n    pe(this, \"attenuationDistance\");\n    pe(this, \"attenuationColor\");\n    pe(this, \"specularIntensity\");\n    pe(this, \"specularIntensityMap\");\n    pe(this, \"specularColor\");\n    pe(this, \"specularColorMap\");\n    pe(this, \"_clearcoat\");\n    pe(this, \"_transmission\");\n    this.isMeshPhysicalMaterial = !0, this.defines = {\n      STANDARD: \"\",\n      PHYSICAL: \"\"\n    }, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ve(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, \"reflectivity\", {\n      get() {\n        return Ye.clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);\n      },\n      set(n) {\n        this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);\n      }\n    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = Number.POSITIVE_INFINITY, this.attenuationColor = new be(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new be(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);\n  }\n  get clearcoat() {\n    return this._clearcoat;\n  }\n  set clearcoat(t) {\n    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;\n  }\n  get transmission() {\n    return this._transmission;\n  }\n  set transmission(t) {\n    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;\n  }\n  copy(t) {\n    return super.copy(t), this.defines = {\n      STANDARD: \"\",\n      PHYSICAL: \"\"\n    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;\n  }\n}\nconst yv = /* @__PURE__ */ ue({\n  __name: \"index\",\n  setup(r, { expose: e }) {\n    const t = re(), { extend: n } = xe();\n    return n({ MeshGlassMaterial: Ip }), e({ instance: t }), (s, i) => (ae(), ce(\"TresMeshGlassMaterial\", {\n      ref_key: \"MeshGlassMaterialClass\",\n      ref: t\n    }, null, 512));\n  }\n}), Op = () => Number.parseInt(Ts.replace(/\\D+/g, \"\")), Dp = /* @__PURE__ */ Op();\nclass Lp extends bt {\n  constructor(t = new ve()) {\n    super({\n      uniforms: {\n        inputBuffer: new Se(null),\n        depthBuffer: new Se(null),\n        resolution: new Se(new ve()),\n        texelSize: new Se(new ve()),\n        halfTexelSize: new Se(new ve()),\n        kernel: new Se(0),\n        scale: new Se(1),\n        cameraNear: new Se(0),\n        cameraFar: new Se(1),\n        depthEdge0: new Se(0),\n        depthEdge1: new Se(1),\n        depthScale: new Se(0),\n        depthBias: new Se(0.25)\n      },\n      fragmentShader: `#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float depthEdge0;\n        uniform float depthEdge1;\n        uniform float depthScale;\n        uniform float depthBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(\n              1.0 - depthEdge1, 1.0 - depthEdge0,\n              1.0 - (depth.r * depth.a) + depthBias\n            );\n            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);\n          #endif\n\n          gl_FragColor = 0.25 * (\n            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))\n            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))\n          );\n          \n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${Dp >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }`,\n      vertexShader: `uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }`,\n      blending: oc,\n      depthWrite: !1,\n      depthTest: !1\n    });\n    pe(this, \"kernel\");\n    this.toneMapped = !1, this.setTexelSize(t.x, t.y), this.kernel = new Float32Array([0, 1, 2, 2, 3]);\n  }\n  setTexelSize(t, n) {\n    this.uniforms.texelSize.value.set(t, n), this.uniforms.halfTexelSize.value.set(t, n).multiplyScalar(0.5);\n  }\n  setResolution(t) {\n    this.uniforms.resolution.value.copy(t);\n  }\n}\nclass kp {\n  constructor({\n    resolution: e,\n    width: t = 500,\n    height: n = 500,\n    depthEdge0: s = 0,\n    depthEdge1: i = 1,\n    depthScale: o = 0,\n    depthBias: a = 0.25\n  }) {\n    pe(this, \"renderTargetA\");\n    pe(this, \"renderTargetB\");\n    pe(this, \"convolutionMaterial\");\n    pe(this, \"scene\");\n    pe(this, \"camera\");\n    pe(this, \"screen\");\n    pe(this, \"renderToScreen\", !1);\n    this.renderTargetA = new Xt(e, e, {\n      minFilter: wt,\n      magFilter: wt,\n      stencilBuffer: !1,\n      depthBuffer: !1,\n      type: Lt\n    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new Lp(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new ve(t, n)), this.scene = new xs(), this.camera = new rc(), this.convolutionMaterial.uniforms.depthEdge0.value = s, this.convolutionMaterial.uniforms.depthEdge1.value = i, this.convolutionMaterial.uniforms.depthScale.value = o, this.convolutionMaterial.uniforms.depthBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = o > 0;\n    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), f = new ht();\n    f.setAttribute(\"position\", new ut(l, 3)), f.setAttribute(\"uv\", new ut(c, 2)), this.screen = new de(f, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);\n  }\n  render(e, t, n) {\n    const s = this.scene, i = this.camera, o = this.renderTargetA, a = this.renderTargetB, l = this.convolutionMaterial, c = l.uniforms;\n    c.depthBuffer.value = t.depthTexture;\n    const f = l.kernel;\n    let u = t, d, h, m;\n    for (h = 0, m = f.length - 1; h < m; ++h)\n      d = h & 1 ? a : o, c.kernel.value = f[h], c.inputBuffer.value = u.texture, e.setRenderTarget(d), e.render(s, i), u = d;\n    c.kernel.value = f[h], c.inputBuffer.value = u.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);\n  }\n  dispose() {\n    this.screen.material.dispose(), this.screen.geometry.dispose(), this.renderTargetA.dispose(), this.renderTargetB.dispose(), this.convolutionMaterial.dispose();\n  }\n}\nclass Np extends Es {\n  constructor(t = {}) {\n    super(t);\n    pe(this, \"_tDepth\", { value: null });\n    pe(this, \"_distortionMap\", { value: null });\n    pe(this, \"_tSharp\", { value: null });\n    pe(this, \"_tBlur\", { value: null });\n    pe(this, \"_textureMatrix\", { value: null });\n    pe(this, \"_mix\", { value: 0.5 });\n    pe(this, \"_sharpMix\", { value: 0 });\n    pe(this, \"_blurMixSmooth\", { value: 0 });\n    pe(this, \"_blurMixRough\", { value: 0 });\n    pe(this, \"_sharpDepthEdgeMin\", { value: 0.9 });\n    pe(this, \"_sharpDepthEdgeMax\", { value: 1 });\n    pe(this, \"_sharpDepthScale\", { value: 0 });\n    pe(this, \"_sharpDepthBias\", { value: 0 });\n    pe(this, \"_distortion\", { value: 1 });\n    this.setValues(t);\n  }\n  onBeforeCompile(t) {\n    var n;\n    (n = t.defines) != null && n.USE_UV || (t.defines.USE_UV = \"\");\n    for (const s of Object.keys(t.defines))\n      t.defines[s.toUpperCase()] = t.defines[s];\n    t.uniforms.tSharp = this._tSharp, t.uniforms.tDepth = this._tDepth, t.uniforms.tBlur = this._tBlur, t.uniforms.distortionMap = this._distortionMap, t.uniforms.textureMatrix = this._textureMatrix, t.uniforms.mixMain = this._mix, t.uniforms.sharpMix = this._sharpMix, t.uniforms.sharpDepthScale = this._sharpDepthScale, t.uniforms.sharpDepthEdgeMin = this._sharpDepthEdgeMin, t.uniforms.sharpDepthEdgeMax = this._sharpDepthEdgeMax, t.uniforms.sharpDepthBias = this._sharpDepthBias, t.uniforms.blurMixSmooth = this._blurMixSmooth, t.uniforms.blurMixRough = this._blurMixRough, t.uniforms.distortion = this._distortion, t.vertexShader = `\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${t.vertexShader}`, t.vertexShader = t.vertexShader.replace(\n      \"#include <project_vertex>\",\n      `#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`\n    ), t.fragmentShader = `\n        uniform sampler2D tSharp;\n        uniform sampler2D tBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float mixMain;\n        uniform float sharpMix;\n        uniform float blurMixSmooth;\n        uniform float blurMixRough;\n        uniform float sharpDepthScale;\n        uniform float sharpDepthBias;\n        uniform float sharpDepthEdgeMin;\n        uniform float sharpDepthEdgeMax;\n        varying vec4 my_vUv;\n        ${t.fragmentShader}`, t.fragmentShader = t.fragmentShader.replace(\n      \"#include <emissivemap_fragment>\",\n      `#include <emissivemap_fragment>\n\n      vec4 new_vUv = my_vUv;\n\n      #ifdef USE_DISTORTION\n        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;\n        new_vUv.x += distortionFactor;\n        new_vUv.y += distortionFactor;\n      #endif\n\n      #ifdef USE_NORMALMAP\n\n        vec4 normalColor = texture(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n\n        vec4 sharp = texture(tSharp, normal_uv);\n\n        #ifdef USE_BLUR\n          vec4 blur = texture(tBlur, normal_uv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = texture(tDepth, normal_uv);\n        #endif\n\n      #else\n\n        vec4 sharp = textureProj(tSharp, new_vUv);\n\n        #ifdef USE_BLUR\n          vec4 blur = textureProj(tBlur, new_vUv);\n        #endif\n\n        #ifdef USE_DEPTH\n          vec4 depth = textureProj(tDepth, new_vUv);\n        #endif\n\n      #endif\n\n      #ifdef USE_DEPTH\n        float depthFactor = smoothstep(\n          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,\n          1.0 - (depth.r * depth.a) + sharpDepthBias\n        );\n        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);\n\n        sharp *= depthFactor;\n      #endif\n\n      sharp *= (1.0 - roughnessFactor);\n      `\n    ), t.fragmentShader = t.fragmentShader.replace(\n      \"#include <opaque_fragment>\",\n      `\n\n      #ifdef USE_BLUR\n        outgoingLight += mixMain * (\n          vec3(sharp) * sharpMix\n          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)\n        );\n      #else\n        outgoingLight += mixMain * vec3(sharp) * sharpMix;\n      #endif\n\n      #include <opaque_fragment>\n      `\n    );\n  }\n  get tSharp() {\n    return this._tSharp.value;\n  }\n  set tSharp(t) {\n    this._tSharp.value = t;\n  }\n  get tDepth() {\n    return this._tDepth.value;\n  }\n  set tDepth(t) {\n    this._tDepth.value = t;\n  }\n  get distortionMap() {\n    return this._distortionMap.value;\n  }\n  set distortionMap(t) {\n    this._distortionMap.value = t;\n  }\n  get tBlur() {\n    return this._tBlur.value;\n  }\n  set tBlur(t) {\n    this._tBlur.value = t;\n  }\n  get textureMatrix() {\n    return this._textureMatrix.value;\n  }\n  set textureMatrix(t) {\n    this._textureMatrix.value = t;\n  }\n  get sharpMix() {\n    return this._sharpMix.value;\n  }\n  set sharpMix(t) {\n    this._sharpMix.value = t;\n  }\n  get blurMixSmooth() {\n    return this._blurMixSmooth.value;\n  }\n  set blurMixSmooth(t) {\n    this._blurMixSmooth.value = t;\n  }\n  get blurMixRough() {\n    return this._blurMixRough.value;\n  }\n  set blurMixRough(t) {\n    this._blurMixRough.value = t;\n  }\n  get mix() {\n    return this._mix.value;\n  }\n  set mix(t) {\n    this._mix.value = t;\n  }\n  get sharpDepthScale() {\n    return this._sharpDepthScale.value;\n  }\n  set sharpDepthScale(t) {\n    this._sharpDepthScale.value = t;\n  }\n  get sharpDepthBias() {\n    return this._sharpDepthBias.value;\n  }\n  set sharpDepthBias(t) {\n    this._sharpDepthBias.value = t;\n  }\n  get sharpDepthEdgeMin() {\n    return this._sharpDepthEdgeMin.value;\n  }\n  set sharpDepthEdgeMin(t) {\n    this._sharpDepthEdgeMin.value = t;\n  }\n  get sharpDepthEdgeMax() {\n    return this._sharpDepthEdgeMax.value;\n  }\n  set sharpDepthEdgeMax(t) {\n    this._sharpDepthEdgeMax.value = t;\n  }\n  get distortion() {\n    return this._distortion.value;\n  }\n  set distortion(t) {\n    this._distortion.value = t;\n  }\n}\nconst Bp = [\"texture-matrix\", \"t-sharp\", \"t-depth\", \"t-blur\", \"defines-USE_BLUR\", \"defines-USE_DEPTH\", \"defines-USE_DISTORTION\"], _v = /* @__PURE__ */ ue({\n  __name: \"index\",\n  props: {\n    resolution: { default: 256 },\n    mix: { default: 1 },\n    sharpMix: { default: 1 },\n    sharpDepthScale: { default: 1 },\n    sharpDepthBias: { default: 0 },\n    sharpDepthEdgeMin: { default: 0 },\n    sharpDepthEdgeMax: { default: 0.2 },\n    blurMixSmooth: { default: 1 },\n    blurMixRough: { default: 1 },\n    blurDepthScale: { default: 1 },\n    blurDepthBias: { default: 0 },\n    blurDepthEdgeMin: { default: 0 },\n    blurDepthEdgeMax: { default: 0.2 },\n    blurSize: { default: () => [0, 0] },\n    distortionMap: {},\n    distortion: { default: 0 },\n    reflectorOffset: { default: 0 },\n    color: { default: () => new be(3355443) },\n    roughness: { default: 1 },\n    metalness: { default: 0 },\n    map: {},\n    lightMap: {},\n    lightMapIntensity: { default: 1 },\n    aoMap: {},\n    aoMapIntensity: { default: 1 },\n    emissive: { default: () => new be(0) },\n    emissiveIntensity: { default: 1 },\n    emissiveMap: {},\n    bumpMap: {},\n    bumpScale: { default: 1 },\n    normalMap: {},\n    normalMapType: { default: ac },\n    normalScale: { default: () => new ve(1, 1) },\n    displacementMap: {},\n    displacementScale: { default: 1 },\n    displacementBias: { default: 0 },\n    roughnessMap: { default: null },\n    metalnessMap: {},\n    alphaMap: {},\n    envMap: {},\n    envMapRotation: { default: () => new vt() },\n    envMapIntensity: { default: 1 },\n    wireframe: { type: Boolean, default: !1 },\n    wireframeLinewidth: { default: 1 },\n    wireframeLinecap: { default: \"round\" },\n    wireframeLinejoin: { default: \"round\" },\n    flatShading: { type: Boolean, default: !1 },\n    fog: { type: Boolean, default: !0 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { extend: n, invalidate: s } = xe();\n    n({ MeshReflectionMaterial: Np });\n    const i = Pe(() => 500 - (Array.isArray(t.blurSize) ? t.blurSize[0] : t.blurSize)), o = Pe(() => 500 - (Array.isArray(t.blurSize) ? t.blurSize[1] : t.blurSize)), a = Pe(() => i.value > 0 || o.value > 0), l = Pe(() => t.sharpDepthScale > 0 || t.blurDepthScale > 0), c = Pe(() => !!t.distortionMap), f = Pe(() => !!t.roughnessMap), u = re();\n    let d;\n    const h = {\n      reflectorPlane: new bs(),\n      normal: new $(),\n      reflectorWorldPosition: new $(),\n      cameraWorldPosition: new $(),\n      rotationMatrix: new Ie(),\n      lookAtPosition: new $(0, 0, -1),\n      clipPlane: new at(),\n      view: new $(),\n      target: new $(),\n      q: new at(),\n      virtualCamera: new kt(),\n      textureMatrix: new Ie()\n    }, m = new Xt(\n      t.resolution,\n      t.resolution,\n      {\n        minFilter: wt,\n        magFilter: wt,\n        type: Lt,\n        depthBuffer: !0,\n        depthTexture: new Sa(\n          t.resolution,\n          t.resolution\n        )\n      }\n    ), g = new Xt(\n      t.resolution,\n      t.resolution,\n      {\n        minFilter: wt,\n        magFilter: wt,\n        type: Lt\n      }\n    );\n    function v(p, b, _, M) {\n      s();\n      const R = p.xr.enabled, w = p.shadowMap.autoUpdate;\n      if (h.reflectorWorldPosition.setFromMatrixPosition(M.matrixWorld), h.cameraWorldPosition.setFromMatrixPosition(_.matrixWorld), h.rotationMatrix.extractRotation(M.matrixWorld), h.normal.set(0, 0, 1), h.normal.applyMatrix4(h.rotationMatrix), h.reflectorWorldPosition.addScaledVector(h.normal, t.reflectorOffset), h.view.subVectors(h.reflectorWorldPosition, h.cameraWorldPosition), h.view.dot(h.normal) > 0)\n        return;\n      M.visible = !1, h.view.reflect(h.normal).negate(), h.view.add(h.reflectorWorldPosition), h.rotationMatrix.extractRotation(_.matrixWorld), h.lookAtPosition.set(0, 0, -1), h.lookAtPosition.applyMatrix4(h.rotationMatrix), h.lookAtPosition.add(h.cameraWorldPosition), h.target.subVectors(h.reflectorWorldPosition, h.lookAtPosition), h.target.reflect(h.normal).negate(), h.target.add(h.reflectorWorldPosition), h.virtualCamera.position.copy(h.view), h.virtualCamera.up.set(0, 1, 0), h.virtualCamera.up.applyMatrix4(h.rotationMatrix), h.virtualCamera.up.reflect(h.normal), h.virtualCamera.lookAt(h.target), h.virtualCamera.far = _.far, h.virtualCamera.updateMatrixWorld(), h.virtualCamera.projectionMatrix.copy(_.projectionMatrix), h.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), h.textureMatrix.multiply(h.virtualCamera.projectionMatrix), h.textureMatrix.multiply(h.virtualCamera.matrixWorldInverse), h.textureMatrix.multiply(M.matrixWorld), h.reflectorPlane.setFromNormalAndCoplanarPoint(h.normal, h.reflectorWorldPosition), h.reflectorPlane.applyMatrix4(h.virtualCamera.matrixWorldInverse), h.clipPlane.set(\n        h.reflectorPlane.normal.x,\n        h.reflectorPlane.normal.y,\n        h.reflectorPlane.normal.z,\n        h.reflectorPlane.constant\n      );\n      const E = h.virtualCamera.projectionMatrix;\n      h.q.x = (Math.sign(h.clipPlane.x) + E.elements[8]) / E.elements[0], h.q.y = (Math.sign(h.clipPlane.y) + E.elements[9]) / E.elements[5], h.q.z = -1, h.q.w = (1 + E.elements[10]) / E.elements[14], h.clipPlane.multiplyScalar(2 / h.clipPlane.dot(h.q)), E.elements[2] = h.clipPlane.x, E.elements[6] = h.clipPlane.y, E.elements[10] = h.clipPlane.z + 1, E.elements[14] = h.clipPlane.w, p.shadowMap.autoUpdate = !1, p.setRenderTarget(m), p.autoClear || p.clear(), p.render(b, h.virtualCamera), d.render(p, m, g), p.xr.enabled = R, p.shadowMap.autoUpdate = w, M.visible = !0, p.setRenderTarget(null);\n    }\n    return J(\n      () => [t.resolution],\n      () => {\n        m.setSize(t.resolution, t.resolution), g.setSize(t.resolution, t.resolution);\n      }\n    ), J(() => [\n      t.resolution,\n      i.value,\n      o.value,\n      t.blurDepthEdgeMin,\n      t.blurDepthEdgeMax,\n      t.blurDepthScale,\n      t.blurDepthBias\n    ], () => {\n      d == null || d.dispose(), d = new kp({\n        resolution: t.resolution,\n        width: i.value,\n        height: o.value,\n        depthEdge0: t.blurDepthEdgeMin,\n        depthEdge1: t.blurDepthEdgeMax,\n        depthScale: t.blurDepthScale,\n        depthBias: t.blurDepthBias\n      });\n    }, { immediate: !0 }), J(() => [a.value], () => {\n      xt().logWarning(\n        \"MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.\"\n      );\n    }), J(l, () => {\n      xt().logWarning(\n        \"MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.\"\n      );\n    }), J(c, () => {\n      xt().logWarning(\n        \"MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.\"\n      );\n    }), J(f, () => {\n      xt().logWarning(\n        \"MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.\"\n      );\n    }), J(() => [t.normalMap], () => {\n      xt().logWarning(\n        \"MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.\"\n      );\n    }), Co(() => {\n      m.dispose(), g.dispose(), d.dispose();\n    }), Ve().onBeforeRender(({ renderer: p, scene: b, camera: _, invalidate: M }) => {\n      var w, E;\n      const R = (E = (w = u.value) == null ? void 0 : w.__tres) == null ? void 0 : E.parent;\n      R && (v(p, b, _, R), M());\n    }), e({ instance: u }), (p, b) => {\n      var _, M, R;\n      return ae(), ce(\"TresMeshReflectionMaterial\", $e({\n        key: `key${a.value ? \"0\" : \"1\"}${l.value ? \"0\" : \"1\"}${c.value ? \"0\" : \"1\"}${f.value ? \"0\" : \"1\"}`,\n        ref_key: \"materialRef\",\n        ref: u\n      }, t, {\n        \"texture-matrix\": h.textureMatrix,\n        \"t-sharp\": (_ = F(m)) == null ? void 0 : _.texture,\n        \"t-depth\": (M = F(m)) == null ? void 0 : M.depthTexture,\n        \"t-blur\": (R = F(g)) == null ? void 0 : R.texture,\n        \"defines-USE_BLUR\": a.value ? \"\" : void 0,\n        \"defines-USE_DEPTH\": l.value ? \"\" : void 0,\n        \"defines-USE_DISTORTION\": c.value ? \"\" : void 0\n      }), null, 16, Bp);\n    };\n  }\n});\nclass Up extends Es {\n  constructor(t = {}) {\n    super(t);\n    pe(this, \"_time\");\n    pe(this, \"_factor\");\n    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };\n  }\n  onBeforeCompile(t) {\n    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `\n        uniform float time;\n        uniform float factor;\n        ${t.vertexShader}\n      `, t.vertexShader = t.vertexShader.replace(\n      \"#include <begin_vertex>\",\n      `float theta = sin( time + position.y ) / 2.0 * factor;\n          float c = cos( theta );\n          float s = sin( theta );\n          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n          vec3 transformed = vec3( position ) * m;\n          vNormal = vNormal * m;`\n    );\n  }\n  get time() {\n    return this._time.value;\n  }\n  set time(t) {\n    this._time.value = t;\n  }\n  get factor() {\n    return this._factor.value;\n  }\n  set factor(t) {\n    this._factor.value = t;\n  }\n}\nconst Fp = [\"factor\"], xv = /* @__PURE__ */ ue({\n  __name: \"index\",\n  props: {\n    speed: { default: 1 },\n    factor: { default: 1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), { extend: s, invalidate: i } = xe();\n    s({ MeshWobbleMaterial: Up }), J(t, () => i());\n    const { onBeforeRender: o } = Ve();\n    return o(({ elapsed: a, invalidate: l }) => {\n      n.value && (n.value.time = a * (t == null ? void 0 : t.speed), l());\n    }), e({ instance: n }), (a, l) => (ae(), ce(\"TresMeshWobbleMaterial\", $e({\n      ref_key: \"materialRef\",\n      ref: n,\n      factor: a.factor\n    }, a.$attrs), null, 16, Fp));\n  }\n}), wv = ue({\n  name: \"BakeShadows\",\n  setup() {\n    const { renderer: r } = xe();\n    et(() => {\n      r.value.shadowMap.autoUpdate = !1, r.value.shadowMap.needsUpdate = !0;\n    });\n  }\n});\nvar zp = `void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}`, Gp = `#include <common>\n\nvoid main() {\n  vec2 center = vec2(0., 1.);\n  float rotation = 0.0;\n\n  \n  \n  float size = 0.03;\n\n  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n  vec2 scale;\n  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n  bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n  if ( isPerspective ) scale *= - mvPosition.z;\n\n  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n  vec2 rotatedPosition;\n  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n  mvPosition.xy += rotatedPosition;\n\n  gl_Position = projectionMatrix * mvPosition;\n}`;\nconst Rs = new $(0, 0, 0), Vo = new $(0, 0, 0), Hp = new $(0, 0, 0);\nfunction sa(r, e, t) {\n  const n = Rs.setFromMatrixPosition(r.matrixWorld);\n  n.project(e);\n  const s = t.width / 2, i = t.height / 2;\n  return [\n    (Number.isNaN(n.x) ? 0 : n.x) * s + s,\n    -(n.y * i) + i,\n    n.z\n  ];\n}\nfunction jp(r, e) {\n  const t = Rs.setFromMatrixPosition(r.matrixWorld), n = Vo.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(Hp);\n  return s.angleTo(i) > Math.PI / 2;\n}\nfunction Vp(r, e, t, n) {\n  const s = Rs.setFromMatrixPosition(r.matrixWorld), i = s.clone();\n  i.project(e), t.setFromCamera(new ve(i.x, i.y), e);\n  const o = t.intersectObjects(n, !0);\n  if (o.length > 0) {\n    const a = o[0].distance;\n    return s.distanceTo(t.ray.origin) < a;\n  }\n  return !0;\n}\nfunction Yp(r, e) {\n  if (e instanceof _n)\n    return e.zoom;\n  if (e instanceof kt) {\n    const t = Rs.setFromMatrixPosition(r.matrixWorld), n = Vo.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);\n    return 1 / (2 * Math.tan(s / 2) * i);\n  } else\n    return 1;\n}\nfunction Wp(r, e, t) {\n  if (e instanceof kt || e instanceof _n) {\n    const n = Rs.setFromMatrixPosition(r.matrixWorld), s = Vo.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), o = (t[1] - t[0]) / (e.far - e.near), a = t[1] - o * e.far;\n    return Math.round(o * i + a);\n  }\n}\nconst bo = (r) => Math.abs(r) < 1e-10 ? 0 : r;\nfunction wl(r, e, t = \"\") {\n  let n = \"matrix3d(\";\n  for (let s = 0; s !== 16; s++)\n    n += bo(e[s] * r.elements[s]) + (s !== 15 ? \",\" : \")\");\n  return t + n;\n}\nconst Xp = /* @__PURE__ */ ((r) => (e) => wl(e, r))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), $p = /* @__PURE__ */ ((r) => (e, t) => wl(e, r(t), \"translate(-50%,-50%)\"))((r) => [1 / r, 1 / r, 1 / r, 1, -1 / r, -1 / r, -1 / r, -1, 1 / r, 1 / r, 1 / r, 1, 1, 1, 1, 1]), Zp = [\"geometry\", \"material\"], Tv = /* @__PURE__ */ ue({\n  __name: \"HTML\",\n  props: {\n    geometry: { default: new jt() },\n    material: {},\n    as: { default: \"div\" },\n    transform: { type: Boolean, default: !1 },\n    portal: {},\n    wrapperClass: {},\n    eps: { default: 1e-4 },\n    distanceFactor: {},\n    fullscreen: { type: Boolean },\n    center: { type: Boolean },\n    pointerEvents: { default: \"auto\" },\n    sprite: { type: Boolean, default: !1 },\n    zIndexRange: { default: () => [16777271, 0] },\n    occlude: { type: [Object, null, Array, Boolean, String] }\n  },\n  emits: [\"onOcclude\"],\n  setup(r, { expose: e, emit: t }) {\n    const n = r, s = t, i = Io(), o = mc(), a = me(), l = me(), {\n      geometry: c,\n      material: f,\n      as: u,\n      transform: d,\n      portal: h,\n      wrapperClass: m,\n      eps: g,\n      distanceFactor: v,\n      fullscreen: p,\n      center: b,\n      pointerEvents: _,\n      sprite: M,\n      occlude: R,\n      zIndexRange: w\n    } = Le(n), { renderer: E, scene: x, camera: T, raycaster: y, sizes: A } = xe(), C = Pe(() => document.createElement(u.value)), N = me([0, 0, 0]), U = me(0), Y = me(), V = Pe(() => d.value ? {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: `${A.width.value}px`,\n      height: `${A.height.value}px`,\n      transformStyle: \"preserve-3d\",\n      pointerEvents: \"none\",\n      zIndex: 2\n    } : {\n      position: \"absolute\",\n      transform: b.value ? \"translate3d(-50%,-50%,0)\" : \"none\",\n      ...p.value && {\n        top: -A.height.value / 2,\n        left: -A.width.value / 2,\n        width: `${A.width.value}px`,\n        height: `${A.height.value}px`\n      },\n      zIndex: 2,\n      ...Object.assign({}, o.style)\n    }), ne = Pe(() => ({\n      position: \"absolute\",\n      pointerEvents: _.value\n    })), Z = me(null), ee = me(!1), te = Pe(\n      () => (R == null ? void 0 : R.value) && (R == null ? void 0 : R.value) !== \"blending\" || Array.isArray(R == null ? void 0 : R.value) && (R == null ? void 0 : R.value.length) && ii(R.value[0])\n    );\n    J(\n      () => R,\n      ({ value: B }) => {\n        B === \"blending\" ? (C.value.style.zIndex = `${Math.floor(w.value[0] / 2)}`, C.value.style.position = \"absolute\", C.value.style.pointerEvents = \"none\") : (C.value.style.zIndex = null, C.value.style.position = null, C.value.style.pointerEvents = null);\n      }\n    ), J(\n      () => {\n        var B;\n        return [a.value, E.value, A.width.value, A.height.value, (B = i.default) == null ? void 0 : B.call(i)];\n      },\n      ([B, D]) => {\n        var O, z, S, P, L, X;\n        if (B && D) {\n          const H = (h == null ? void 0 : h.value) || D.domElement;\n          if ((O = x.value) == null || O.updateMatrixWorld(), d.value)\n            C.value.style.cssText = \"position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;\";\n          else {\n            const j = sa(B, T.value, {\n              width: A.width.value,\n              height: A.height.value\n            });\n            C.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${j[0]}px,${j[1]}px,0);transform-origin:0 0;`;\n          }\n          H && !C.value.parentNode && ((z = H.parentNode) == null || z.appendChild(C.value)), d.value ? Y.value = ms(\"div\", { id: \"outer\", style: V.value }, [\n            ms(\"div\", { id: \"inner\", style: ne.value }, [\n              ms(\"div\", {\n                key: (S = l.value) == null ? void 0 : S.uuid,\n                id: x == null ? void 0 : x.value.uuid,\n                class: o.class,\n                style: o.style\n              }, (P = i.default) == null ? void 0 : P.call(i))\n            ])\n          ]) : Y.value = ms(\"div\", {\n            key: (L = l.value) == null ? void 0 : L.uuid,\n            id: x == null ? void 0 : x.value.uuid,\n            style: V.value\n          }, (X = i.default) == null ? void 0 : X.call(i)), gc(Y.value, C.value);\n        }\n      }\n    ), et(() => {\n      m != null && m.value && (C.value.className = m.value);\n    });\n    const fe = me(!0), { onBeforeRender: he } = Ve();\n    he(({ invalidate: B }) => {\n      var D, O, z, S, P, L, X;\n      if (B(), a.value && T.value && E.value) {\n        (D = T.value) == null || D.updateMatrixWorld(), a.value.updateWorldMatrix(!0, !1);\n        const H = d.value ? N.value : sa(a.value, T.value, {\n          width: A.width.value || 0,\n          height: A.height.value || 0\n        });\n        if (d.value || Math.abs(U.value - T.value.zoom) > g.value || Math.abs(N.value[0] - H[0]) > g.value || Math.abs(N.value[1] - H[1]) > g.value || Math.abs(N.value[2] - H[2]) > g.value) {\n          const j = jp(a.value, T.value);\n          let K = !1;\n          te.value && (Array.isArray(R == null ? void 0 : R.value) ? K = R == null ? void 0 : R.value : (R == null ? void 0 : R.value) !== \"blending\" && (K = [x.value]));\n          const se = fe.value;\n          if (K) {\n            const k = Vp(\n              a.value,\n              T.value,\n              y.value,\n              K\n            );\n            fe.value = k && !j;\n          } else\n            fe.value = !j;\n          se !== fe.value && (s(\"onOcclude\", !fe.value), C.value.style.display = fe.value ? \"block\" : \"none\");\n          const ie = Math.floor(w.value[0] / 2), G = R != null && R.value ? te.value ? [w.value[0], ie] : [ie - 1, 0] : w.value;\n          if (C.value.style.zIndex = `${Wp(a.value, T.value, G)}`, d.value) {\n            const [k, oe] = [\n              A.width.value / 2,\n              A.height.value / 2\n            ], ge = T.value.projectionMatrix.elements[5] * oe, { isOrthographicCamera: Re, top: Ke, left: He, bottom: Et, right: un } = T.value, En = Xp(T.value.matrixWorldInverse), Nt = Re ? `scale(${ge})translate(${bo(-(un + He) / 2)}px,${bo((Ke + Et) / 2)}px)` : `translateZ(${ge}px)`;\n            let yt = a.value.matrixWorld;\n            if (M.value && (yt = T.value.matrixWorldInverse.clone().transpose().copyPosition(yt).scale(a.value.scale), yt.elements[3] = yt.elements[7] = yt.elements[11] = 0, yt.elements[15] = 1), C.value.style.width = `${A.width.value}px`, C.value.style.height = `${A.height.value}px`, C.value.style.perspective = Re ? \"\" : `${ge}px`, (O = Y.value) != null && O.el && ((z = Y.value) != null && z.children) && Array.isArray(Y.value.children)) {\n              Y.value.el.style.transform = `${Nt}${En}translate(${k}px,${oe}px)`;\n              const Bt = Y.value.children[0];\n              Bt && Bt.el && (Bt.el.style.transform = $p(\n                yt,\n                1 / (((v == null ? void 0 : v.value) || 10) / 400)\n              ));\n            }\n          } else {\n            const k = (v == null ? void 0 : v.value) === void 0 ? 1 : Yp(a.value, T.value) * (v == null ? void 0 : v.value);\n            C.value.style.transform = `translate3d(${H[0]}px,${H[1]}px,0) scale(${k})`;\n          }\n        }\n        N.value = H, U.value = T.value.zoom;\n      }\n      if (!te.value && l.value && !ee.value)\n        if (d.value) {\n          if ((S = Y.value) != null && S.el && ((P = Y.value) != null && P.children)) {\n            const H = ((L = Y.value) == null ? void 0 : L.children)[0];\n            if (H != null && H.clientWidth && (H != null && H.clientHeight)) {\n              const { isOrthographicCamera: j } = T.value;\n              if (j || c)\n                o.scale && (Array.isArray(o.scale) ? o.scale instanceof $ ? l.value.scale.copy(o.scale.clone().divideScalar(1)) : l.value.scale.set(1 / o.scale[0], 1 / o.scale[1], 1 / o.scale[2]) : l.value.scale.setScalar(1 / o.scale));\n              else {\n                const K = ((v == null ? void 0 : v.value) || 10) / 400, se = H.clientWidth * K, ie = H.clientHeight * K;\n                l.value.scale.set(se, ie, 1);\n              }\n              ee.value = !0;\n            }\n          }\n        } else {\n          const H = C.value.children[0];\n          if (H != null && H.clientWidth && (H != null && H.clientHeight)) {\n            const K = H.clientWidth * 1, se = H.clientHeight * 1;\n            l.value.scale.set(K, se, 1), ee.value = !0;\n          }\n          Z.value.lookAt((X = T.value) == null ? void 0 : X.position);\n        }\n    });\n    const we = Pe(() => ({\n      vertexShader: d.value ? void 0 : Gp,\n      fragmentShader: zp\n    })), I = Pe(() => {\n      const B = we.value;\n      return f.value || new bt({\n        vertexShader: B.vertexShader,\n        fragmentShader: B.fragmentShader,\n        side: on\n      });\n    });\n    return tt(() => {\n      I.value && I.value.dispose(), C.value.remove();\n    }), e({ instance: a }), (B, D) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"groupRef\",\n      ref: a\n    }, [\n      F(R) && !te.value ? (ae(), ce(\"TresMesh\", {\n        key: 0,\n        ref_key: \"meshRef\",\n        ref: l,\n        geometry: F(c),\n        material: I.value\n      }, null, 8, Zp)) : an(\"\", !0)\n    ], 512));\n  }\n});\nvar Js = { exports: {} }, Kp = Js.exports, ia;\nfunction qp() {\n  return ia || (ia = 1, function(r, e) {\n    (function(t, n) {\n      r.exports = n();\n    })(Kp, function() {\n      var t = function() {\n        function n(h) {\n          return o.appendChild(h.dom), h;\n        }\n        function s(h) {\n          for (var m = 0; m < o.children.length; m++) o.children[m].style.display = m === h ? \"block\" : \"none\";\n          i = h;\n        }\n        var i = 0, o = document.createElement(\"div\");\n        o.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\", o.addEventListener(\"click\", function(h) {\n          h.preventDefault(), s(++i % o.children.length);\n        }, !1);\n        var a = (performance || Date).now(), l = a, c = 0, f = n(new t.Panel(\"FPS\", \"#0ff\", \"#002\")), u = n(new t.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var d = n(new t.Panel(\"MB\", \"#f08\", \"#201\"));\n        return s(0), { REVISION: 16, dom: o, addPanel: n, showPanel: s, begin: function() {\n          a = (performance || Date).now();\n        }, end: function() {\n          c++;\n          var h = (performance || Date).now();\n          if (u.update(h - a, 200), h > l + 1e3 && (f.update(1e3 * c / (h - l), 100), l = h, c = 0, d)) {\n            var m = performance.memory;\n            d.update(m.usedJSHeapSize / 1048576, m.jsHeapSizeLimit / 1048576);\n          }\n          return h;\n        }, update: function() {\n          a = this.end();\n        }, domElement: o, setMode: s };\n      };\n      return t.Panel = function(n, s, i) {\n        var o = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), f = 80 * c, u = 48 * c, d = 3 * c, h = 2 * c, m = 3 * c, g = 15 * c, v = 74 * c, p = 30 * c, b = document.createElement(\"canvas\");\n        b.width = f, b.height = u, b.style.cssText = \"width:80px;height:48px\";\n        var _ = b.getContext(\"2d\");\n        return _.font = \"bold \" + 9 * c + \"px Helvetica,Arial,sans-serif\", _.textBaseline = \"top\", _.fillStyle = i, _.fillRect(0, 0, f, u), _.fillStyle = s, _.fillText(n, d, h), _.fillRect(m, g, v, p), _.fillStyle = i, _.globalAlpha = 0.9, _.fillRect(m, g, v, p), { dom: b, update: function(M, R) {\n          o = Math.min(o, M), a = Math.max(a, M), _.fillStyle = i, _.globalAlpha = 1, _.fillRect(0, 0, f, g), _.fillStyle = s, _.fillText(l(M) + \" \" + n + \" (\" + l(o) + \"-\" + l(a) + \")\", d, h), _.drawImage(b, m + c, g, v - c, p, m, g, v - c, p), _.fillRect(m + v - c, g, c, p), _.fillStyle = i, _.globalAlpha = 0.9, _.fillRect(m + v - c, g, c, l((1 - M / R) * p));\n        } };\n      }, t;\n    });\n  }(Js)), Js.exports;\n}\nvar Qp = qp();\nconst Jp = /* @__PURE__ */ Ps(Qp), bv = ue({\n  name: \"Stats\",\n  props: {\n    showPanel: {\n      type: Number,\n      default: 0\n    }\n  },\n  setup(r, { expose: e }) {\n    const t = new Jp();\n    e({ instance: t });\n    const n = document.body;\n    t.showPanel(r.showPanel || 0), n == null || n.appendChild(t.dom);\n    const { onBeforeRender: s, onAfterRender: i } = Ve();\n    s(() => t.begin(), Number.NEGATIVE_INFINITY), i(() => t.end(), Number.POSITIVE_INFINITY), tt(() => {\n      n == null || n.removeChild(t.dom);\n    });\n  }\n});\nclass em {\n  constructor(e, t, n) {\n    this.name = e, this.fg = t, this.bg = n, this.gradient = null, this.PR = Math.round(window.devicePixelRatio || 1), this.WIDTH = 90 * this.PR, this.HEIGHT = 48 * this.PR, this.TEXT_X = 3 * this.PR, this.TEXT_Y = 2 * this.PR, this.GRAPH_X = 3 * this.PR, this.GRAPH_Y = 15 * this.PR, this.GRAPH_WIDTH = 84 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR, this.canvas = document.createElement(\"canvas\"), this.canvas.width = this.WIDTH, this.canvas.height = this.HEIGHT, this.canvas.style.width = \"90px\", this.canvas.style.height = \"48px\", this.canvas.style.position = \"absolute\", this.canvas.style.cssText = \"width:90px;height:48px\", this.context = this.canvas.getContext(\"2d\"), this.initializeCanvas();\n  }\n  createGradient() {\n    if (!this.context)\n      throw new Error(\"No context\");\n    const e = this.context.createLinearGradient(\n      0,\n      this.GRAPH_Y,\n      0,\n      this.GRAPH_Y + this.GRAPH_HEIGHT\n    );\n    let t;\n    const n = this.fg;\n    switch (this.fg.toLowerCase()) {\n      case \"#0ff\":\n        t = \"#006666\";\n        break;\n      case \"#0f0\":\n        t = \"#006600\";\n        break;\n      case \"#ff0\":\n        t = \"#666600\";\n        break;\n      case \"#e1e1e1\":\n        t = \"#666666\";\n        break;\n      default:\n        t = this.bg;\n        break;\n    }\n    return e.addColorStop(0, t), e.addColorStop(1, n), e;\n  }\n  initializeCanvas() {\n    this.context && (this.context.font = \"bold \" + 9 * this.PR + \"px Helvetica,Arial,sans-serif\", this.context.textBaseline = \"top\", this.gradient = this.createGradient(), this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT), this.context.fillStyle = this.fg, this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y), this.context.fillStyle = this.fg, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT));\n  }\n  update(e, t, n, s, i = 0) {\n    if (!this.context || !this.gradient)\n      return;\n    const o = Math.min(1 / 0, e), a = Math.max(n, e);\n    s = Math.max(s, t), this.context.globalAlpha = 1, this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y), this.context.fillStyle = this.fg, this.context.fillText(\n      `${e.toFixed(i)} ${this.name} (${o.toFixed(i)}-${parseFloat(\n        a.toFixed(i)\n      )})`,\n      this.TEXT_X,\n      this.TEXT_Y\n    ), this.context.drawImage(\n      this.canvas,\n      this.GRAPH_X + this.PR,\n      this.GRAPH_Y,\n      this.GRAPH_WIDTH - this.PR,\n      this.GRAPH_HEIGHT,\n      this.GRAPH_X,\n      this.GRAPH_Y,\n      this.GRAPH_WIDTH - this.PR,\n      this.GRAPH_HEIGHT\n    );\n    const l = this.GRAPH_HEIGHT - (1 - t / s) * this.GRAPH_HEIGHT;\n    l > 0 && (this.context.globalAlpha = 1, this.context.fillStyle = this.gradient, this.context.fillRect(\n      this.GRAPH_X + this.GRAPH_WIDTH - this.PR,\n      this.GRAPH_Y + this.GRAPH_HEIGHT - l,\n      this.PR,\n      l\n    ));\n  }\n}\nconst Tl = class Zn {\n  constructor({\n    trackGPU: e = !1,\n    logsPerSecond: t = 30,\n    samplesLog: n = 60,\n    samplesGraph: s = 10,\n    precision: i = 2,\n    minimal: o = !1,\n    horizontal: a = !0,\n    mode: l = 0\n  } = {}) {\n    this.gl = null, this.ext = null, this.activeQuery = null, this.gpuQueries = [], this.threeRendererPatched = !1, this.frames = 0, this.renderCount = 0, this.isRunningCPUProfiling = !1, this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalGpuDurationCompute = 0, this.totalFps = 0, this.gpuPanel = null, this.gpuPanelCompute = null, this.averageFps = { logs: [], graph: [] }, this.averageCpu = { logs: [], graph: [] }, this.averageGpu = { logs: [], graph: [] }, this.averageGpuCompute = { logs: [], graph: [] }, this.handleClick = (c) => {\n      c.preventDefault(), this.showPanel(++this.mode % this.dom.children.length);\n    }, this.handleResize = () => {\n      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2), this.gpuPanelCompute && this.resizePanel(this.gpuPanelCompute, 3);\n    }, this.mode = l, this.horizontal = a, this.minimal = o, this.trackGPU = e, this.samplesLog = n, this.samplesGraph = s, this.precision = i, this.logsPerSecond = t, this.dom = document.createElement(\"div\"), this.initializeDOM(), this.beginTime = performance.now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.fpsPanel = this.addPanel(new Zn.Panel(\"FPS\", \"#0ff\", \"#002\"), 0), this.msPanel = this.addPanel(new Zn.Panel(\"CPU\", \"#0f0\", \"#020\"), 1), this.setupEventListeners();\n  }\n  initializeDOM() {\n    this.dom.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      opacity: 0.9;\n      z-index: 10000;\n      ${this.minimal ? \"cursor: pointer;\" : \"\"}\n    `;\n  }\n  setupEventListeners() {\n    this.minimal ? (this.dom.addEventListener(\"click\", this.handleClick), this.showPanel(this.mode)) : window.addEventListener(\"resize\", this.handleResize);\n  }\n  async init(e) {\n    if (!e) {\n      console.error('Stats: The \"canvas\" parameter is undefined.');\n      return;\n    }\n    this.handleThreeRenderer(e) || await this.handleWebGPURenderer(e) || this.initializeWebGL(e);\n  }\n  handleThreeRenderer(e) {\n    return e.isWebGLRenderer && !this.threeRendererPatched ? (this.patchThreeRenderer(e), this.gl = e.getContext(), this.trackGPU && this.initializeGPUTracking(), !0) : !1;\n  }\n  async handleWebGPURenderer(e) {\n    return e.isWebGPURenderer ? (this.trackGPU && (e.backend.trackTimestamp = !0, await e.hasFeatureAsync(\"timestamp-query\") && this.initializeWebGPUPanels()), this.info = e.info, !0) : !1;\n  }\n  initializeWebGPUPanels() {\n    this.gpuPanel = this.addPanel(new Zn.Panel(\"GPU\", \"#ff0\", \"#220\"), 2), this.gpuPanelCompute = this.addPanel(\n      new Zn.Panel(\"CPT\", \"#e1e1e1\", \"#212121\"),\n      3\n    );\n  }\n  initializeWebGL(e) {\n    if (e instanceof WebGL2RenderingContext)\n      this.gl = e;\n    else if (e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {\n      if (this.gl = e.getContext(\"webgl2\"), !this.gl)\n        return console.error(\"Stats: Unable to obtain WebGL2 context.\"), !1;\n    } else\n      return console.error(\n        \"Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.\"\n      ), !1;\n    return !0;\n  }\n  initializeGPUTracking() {\n    this.gl && (this.ext = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\"), this.ext && (this.gpuPanel = this.addPanel(new Zn.Panel(\"GPU\", \"#ff0\", \"#220\"), 2)));\n  }\n  begin() {\n    this.isRunningCPUProfiling || this.beginProfiling(\"cpu-started\"), !(!this.gl || !this.ext) && (this.activeQuery && this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.activeQuery = this.gl.createQuery(), this.activeQuery && this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery));\n  }\n  end() {\n    this.renderCount++, this.gl && this.ext && this.activeQuery && (this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.gpuQueries.push({ query: this.activeQuery }), this.activeQuery = null);\n  }\n  update() {\n    this.info ? this.processWebGPUTimestamps() : this.processGpuQueries(), this.endProfiling(\"cpu-started\", \"cpu-finished\", \"cpu-duration\"), this.updateAverages(), this.resetCounters();\n  }\n  processWebGPUTimestamps() {\n    this.totalGpuDuration = this.info.render.timestamp, this.totalGpuDurationCompute = this.info.compute.timestamp, this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);\n  }\n  updateAverages() {\n    this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu);\n  }\n  resetCounters() {\n    this.renderCount = 0, this.totalCpuDuration === 0 && this.beginProfiling(\"cpu-started\"), this.totalCpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();\n  }\n  resizePanel(e, t) {\n    e.canvas.style.position = \"absolute\", this.minimal ? e.canvas.style.display = \"none\" : (e.canvas.style.display = \"block\", this.horizontal ? (e.canvas.style.top = \"0px\", e.canvas.style.left = t * e.WIDTH / e.PR + \"px\") : (e.canvas.style.left = \"0px\", e.canvas.style.top = t * e.HEIGHT / e.PR + \"px\"));\n  }\n  addPanel(e, t) {\n    return e.canvas && (this.dom.appendChild(e.canvas), this.resizePanel(e, t)), e;\n  }\n  showPanel(e) {\n    for (let t = 0; t < this.dom.children.length; t++) {\n      const n = this.dom.children[t];\n      n.style.display = t === e ? \"block\" : \"none\";\n    }\n    this.mode = e;\n  }\n  processGpuQueries() {\n    !this.gl || !this.ext || (this.totalGpuDuration = 0, this.gpuQueries.forEach((e, t) => {\n      if (this.gl) {\n        const n = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT_AVAILABLE), s = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);\n        if (n && !s) {\n          const o = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT) * 1e-6;\n          this.totalGpuDuration += o, this.gl.deleteQuery(e.query), this.gpuQueries.splice(t, 1);\n        }\n      }\n    }));\n  }\n  endInternal() {\n    this.frames++;\n    const e = (performance || Date).now(), t = e - this.prevTime;\n    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond) {\n      const n = Math.round(this.frames * 1e3 / t);\n      this.addToAverage(n, this.averageFps), this.updatePanel(this.fpsPanel, this.averageFps, 0), this.updatePanel(this.msPanel, this.averageCpu, this.precision), this.updatePanel(this.gpuPanel, this.averageGpu, this.precision), this.gpuPanelCompute && this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute), this.frames = 0, this.prevCpuTime = e, this.prevTime = e;\n    }\n    return e;\n  }\n  addToAverage(e, t) {\n    t.logs.push(e), t.logs.length > this.samplesLog && t.logs.shift(), t.graph.push(e), t.graph.length > this.samplesGraph && t.graph.shift();\n  }\n  beginProfiling(e) {\n    window.performance && (window.performance.mark(e), this.isRunningCPUProfiling = !0);\n  }\n  endProfiling(e, t, n) {\n    if (window.performance && t && this.isRunningCPUProfiling) {\n      window.performance.mark(t);\n      const s = performance.measure(n, e, t);\n      this.totalCpuDuration += s.duration, this.isRunningCPUProfiling = !1;\n    }\n  }\n  updatePanel(e, t, n = 2) {\n    if (t.logs.length > 0) {\n      let s = 0, i = 0.01;\n      for (let l = 0; l < t.logs.length; l++)\n        s += t.logs[l], t.logs[l] > i && (i = t.logs[l]);\n      let o = 0, a = 0.01;\n      for (let l = 0; l < t.graph.length; l++)\n        o += t.graph[l], t.graph[l] > a && (a = t.graph[l]);\n      e && e.update(s / Math.min(t.logs.length, this.samplesLog), o / Math.min(t.graph.length, this.samplesGraph), i, a, n);\n    }\n  }\n  get domElement() {\n    return this.dom;\n  }\n  patchThreeRenderer(e) {\n    const t = e.render, n = this;\n    e.render = function(s, i) {\n      n.begin(), t.call(this, s, i), n.end();\n    }, this.threeRendererPatched = !0;\n  }\n};\nTl.Panel = em;\nlet tm = Tl;\nconst Ev = ue({\n  name: \"StatsGl\",\n  props: [\n    \"logsPerSecond\",\n    \"samplesLog\",\n    \"samplesGraph\",\n    \"precision\",\n    \"horizontal\",\n    \"minimal\",\n    \"mode\"\n  ],\n  setup(r, { expose: e }) {\n    const t = new tm({\n      logsPerSecond: r.logsPerSecond,\n      samplesLog: r.samplesLog,\n      samplesGraph: r.samplesGraph,\n      precision: r.precision,\n      horizontal: r.horizontal,\n      minimal: r.minimal,\n      mode: r.mode\n    });\n    e({ instance: t });\n    const n = document.body, s = t.dom || t.container;\n    n == null || n.appendChild(s);\n    const { renderer: i } = xe(), { onAfterRender: o } = Ve();\n    t.init(i.value), o(() => t.update(), Number.POSITIVE_INFINITY), tt(() => {\n      n == null || n.removeChild(s);\n    });\n  }\n}), { logError: nm } = xt();\nasync function Mv(r, e) {\n  const t = new Uo(), n = (e == null ? void 0 : e.fileName) || \"scene\";\n  t.parse(\n    r,\n    (s) => {\n      if (s instanceof ArrayBuffer)\n        im(s, `${n}.glb`);\n      else {\n        const i = JSON.stringify(s, null, 2);\n        sm(i, `${n}.gltf`);\n      }\n    },\n    (s) => {\n      nm(\"An error happened while exporting the GLTF\", s);\n    },\n    e\n  );\n}\nfunction sm(r, e) {\n  bl(new Blob([r], { type: \"text/plain\" }), e);\n}\nfunction im(r, e) {\n  bl(new Blob([r], { type: \"application/octet-stream\" }), e);\n}\nfunction bl(r, e) {\n  const t = document.createElement(\"a\");\n  t.style.display = \"none\", document.body.appendChild(t), t.href = URL.createObjectURL(r), t.download = e, t.click(), t.remove();\n}\nconst om = [\"args\"], rm = [\"color\"], Sv = /* @__PURE__ */ ue({\n  __name: \"Box\",\n  props: {\n    args: { default: () => [1, 1, 1] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { invalidate: n } = xe(), { args: s, color: i } = Le(t);\n    J(s, () => n());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"boxRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresBoxGeometry\", { args: F(s) }, null, 8, om),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(i) }, null, 8, rm)\n      ])\n    ], 16));\n  }\n}), am = [\"object\"], lm = /* @__PURE__ */ ue({\n  __name: \"Line2\",\n  props: {\n    points: {},\n    vertexColors: { default: null },\n    color: { default: \"white\" },\n    lineWidth: { default: 1 },\n    worldUnits: { type: Boolean, default: !1 },\n    alphaToCoverage: { type: Boolean, default: !1 },\n    dashed: { type: Boolean, default: !1 },\n    dashSize: { default: 1 },\n    gapSize: { default: 1 },\n    dashScale: { default: 1 },\n    dashOffset: { default: 0 }\n  },\n  setup(r, { expose: e }) {\n    const t = r;\n    function n(h, m) {\n      if (!h || h.length === 0)\n        return Array.from({ length: m }).fill(tn(t.color));\n      if (h.length === 1)\n        return Array.from({ length: m }).fill(tn(h[0]));\n      if (h.length === m)\n        return h.map(tn);\n      const g = m - 1, v = h.map(tn);\n      closed && v.push(v[0].clone());\n      const p = [v[0]], b = g / (v.length - 1);\n      for (let _ = 1; _ < g; _++) {\n        const M = _ % b / b, R = Math.floor(_ / b);\n        p.push(v[R].clone().lerp(v[R + 1], M));\n      }\n      return p.push(v[v.length - 1]), p;\n    }\n    const s = new Ho(), i = new al(), o = new kf(i, s), { sizes: a, invalidate: l } = xe(), c = Pe(() => Array.isArray(t.vertexColors));\n    function f(h, m) {\n      h.color = tn(m.color), h.linewidth = m.lineWidth, h.alphaToCoverage = m.alphaToCoverage, h.worldUnits = m.worldUnits, h.vertexColors = Array.isArray(m.vertexColors), h.dashed = m.dashed, h.dashScale = m.dashScale, h.dashSize = m.dashSize, h.dashOffset = m.dashOffset, h.gapSize = m.gapSize, h.needsUpdate = !0;\n    }\n    function u(h, m, g) {\n      const v = m.map((b) => b instanceof $ ? [b.x, b.y, b.z] : b instanceof ve ? [b.x, b.y, 0] : Array.isArray(b) && b.length === 2 ? [b[0], b[1], 0] : b).flat();\n      h.setPositions(v.flat());\n      const p = n(g, m.length).map((b) => b.toArray()).flat();\n      h.setColors(p), o.computeLineDistances();\n    }\n    f(s, t), u(i, t.points, t.vertexColors), o.computeLineDistances(), J(() => [\n      t.color,\n      t.lineWidth,\n      t.alphaToCoverage,\n      t.worldUnits,\n      c,\n      t.dashed,\n      t.dashScale,\n      t.dashSize,\n      t.dashOffset\n    ], () => {\n      f(s, t), l();\n    }), J(() => [t.points, t.vertexColors], () => {\n      u(i, t.points, t.vertexColors), l();\n    }), J(() => [a.height, a.width], () => {\n      s.resolution = new ve(a.width.value, a.height.value), l();\n    }), tt(() => {\n      i.dispose(), s.dispose();\n    });\n    const d = re();\n    return e({ instance: d }), (h, m) => (ae(), ce(\"primitive\", {\n      ref: d.value,\n      object: F(o)\n    }, null, 8, am));\n  }\n}), Av = /* @__PURE__ */ ue({\n  __name: \"CatmullRomCurve3\",\n  props: {\n    segments: { default: 20 },\n    closed: { type: Boolean, default: !1 },\n    curveType: { default: \"centripetal\" },\n    tension: { default: 0.5 },\n    points: {},\n    vertexColors: {},\n    color: {},\n    lineWidth: {},\n    alphaToCoverage: { type: Boolean },\n    dashed: { type: Boolean },\n    dashSize: {},\n    dashScale: {},\n    dashOffset: {},\n    gapSize: {},\n    worldUnits: { type: Boolean }\n  },\n  setup(r, { expose: e }) {\n    const t = r;\n    function n(l, c, f, u) {\n      const d = l.map(\n        (h) => h instanceof $ ? h : new $(...h)\n      );\n      return new lc(d, c, f, u);\n    }\n    function s(l, c) {\n      return l.getPoints(c);\n    }\n    const i = Pe(() => n(t.points, t.closed, t.curveType, t.tension)), o = Pe(() => s(i.value, t.segments)), a = re();\n    return e({ instance: a }), (l, c) => (ae(), Oo(lm, {\n      ref: a.value,\n      points: o.value,\n      \"vertex-colors\": t.vertexColors,\n      color: t.color,\n      \"line-width\": t.lineWidth,\n      \"alpha-to-coverage\": t.alphaToCoverage,\n      dashed: t.dashed,\n      \"dash-size\": t.dashSize,\n      \"dash-scale\": t.dashScale,\n      \"dash-offset\": t.dashOffset,\n      \"gap-size\": t.gapSize,\n      \"world-units\": t.worldUnits\n    }, null, 8, [\"points\", \"vertex-colors\", \"color\", \"line-width\", \"alpha-to-coverage\", \"dashed\", \"dash-size\", \"dash-scale\", \"dash-offset\", \"gap-size\", \"world-units\"]));\n  }\n}), cm = [\"args\"], um = [\"color\"], Pv = /* @__PURE__ */ ue({\n  __name: \"Circle\",\n  props: {\n    args: { default: () => [1, 32, 0, Math.PI * 2] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"circleRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresCircleGeometry\", { args: F(n) }, null, 8, cm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, um)\n      ])\n    ], 16));\n  }\n}), hm = [\"args\"], fm = [\"color\"], Rv = /* @__PURE__ */ ue({\n  __name: \"Cone\",\n  props: {\n    args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"coneRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresConeGeometry\", { args: F(n) }, null, 8, hm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, fm)\n      ])\n    ], 16));\n  }\n}), dm = [\"args\"], pm = [\"color\"], Cv = /* @__PURE__ */ ue({\n  __name: \"Cylinder\",\n  props: {\n    args: { default: () => [1, 1, 1, 32, 1, !1, 0, Math.PI * 2] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"cylinderRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresCylinderGeometry\", { args: F(n) }, null, 8, dm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, pm)\n      ])\n    ], 16));\n  }\n}), mm = [\"args\"], gm = [\"color\"], Iv = /* @__PURE__ */ ue({\n  __name: \"Dodecahedron\",\n  props: {\n    args: { default: () => [1, 0] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), i = re(), { invalidate: o } = xe();\n    return J(n, () => o()), e({\n      instance: i\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"dodecahedronRef\",\n      ref: i\n    }, a.$attrs), [\n      ye(\"TresDodecahedronGeometry\", { args: F(n) }, null, 8, mm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, gm)\n      ])\n    ], 16));\n  }\n}), vm = [\"args\"], ym = [\"color\"], Ov = /* @__PURE__ */ ue({\n  __name: \"Icosahedron\",\n  props: {\n    args: { default: () => [1, 0] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"icosahedronRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresIcosahedronGeometry\", { args: F(n) }, null, 8, vm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, ym)\n      ])\n    ], 16));\n  }\n}), _m = [\"args\"], xm = [\"color\"], Dv = /* @__PURE__ */ ue({\n  __name: \"Octahedron\",\n  props: {\n    args: { default: () => [1, 0] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"octahedronRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresOctahedronGeometry\", { args: F(n) }, null, 8, _m),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, xm)\n      ])\n    ], 16));\n  }\n}), wm = [\"rotation\"], Tm = [\"args\"], bm = [\"color\"], Lv = /* @__PURE__ */ ue({\n  __name: \"Plane\",\n  props: {\n    args: { default: () => [1, 1] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"planeRef\",\n      ref: o,\n      rotation: [-Math.PI / 2, 0, 0]\n    }, a.$attrs), [\n      ye(\"TresPlaneGeometry\", { args: F(n) }, null, 8, Tm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, bm)\n      ])\n    ], 16, wm));\n  }\n}), Em = [\"args\"], Mm = [\"color\"], kv = /* @__PURE__ */ ue({\n  __name: \"Ring\",\n  props: {\n    args: { default: () => [0.5, 1, 32] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"ringRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresRingGeometry\", { args: F(n) }, null, 8, Em),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, Mm)\n      ])\n    ], 16));\n  }\n}), Sm = [\"args\"], Am = [\"color\"], Nv = /* @__PURE__ */ ue({\n  __name: \"RoundedBox\",\n  props: {\n    args: { default: () => [1, 1, 1, 2, 0.1] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i, extend: o } = xe();\n    o({ RoundedBoxGeometry: tf }), J(n, () => i());\n    const a = re();\n    return e({ instance: a }), (l, c) => (ae(), ce(\"TresMesh\", {\n      ref_key: \"roundedBoxRef\",\n      ref: a\n    }, [\n      ye(\"TresRoundedBoxGeometry\", { args: F(n) }, null, 8, Sm),\n      Ne(l.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, Am)\n      ])\n    ], 512));\n  }\n}), Pm = [\"args\"], Rm = [\"color\"], Bv = /* @__PURE__ */ ue({\n  __name: \"Sphere\",\n  props: {\n    args: { default: () => [2, 32, 16] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"sphereRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresSphereGeometry\", { args: F(n) }, null, 8, Pm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, Rm)\n      ])\n    ], 16));\n  }\n}), Cm = [\"geometry\"], Im = [\"color\"], Uv = /* @__PURE__ */ ue({\n  __name: \"Superformula\",\n  props: {\n    widthSegments: { default: 32 },\n    heightSegments: { default: 32 },\n    numArmsA: { default: 4 },\n    expA: { default: () => [40, 1.3, 0.9] },\n    numArmsB: { default: 4 },\n    expB: { default: () => [40, 1.3, 0.9] },\n    color: { default: \"white\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { invalidate: n } = xe(), { cos: s, sin: i, abs: o } = Math, a = re(), l = re(t.color);\n    function c(h, m) {\n      const g = new ht(), v = h * m, p = new Float32Array(Array.from({ length: 3 * v }).fill(0)), b = new Float32Array(Array.from({ length: 3 * v }).fill(0)), _ = [];\n      for (let M = 0; M < m - 1; M++) {\n        for (let T = 0; T < h - 1; T++) {\n          const y = M * h + T, A = y + 1, C = y + h, N = A + h;\n          _.push(y, C, A), _.push(C, N, A);\n        }\n        const R = M * h + h - 1, w = M * h, E = R + h, x = w + h;\n        _.push(R, E, w), _.push(E, x, w);\n      }\n      return g.setIndex(_), g.setAttribute(\"position\", new ut(p, 3)), g.setAttribute(\"normal\", new ut(b, 3)), g;\n    }\n    function f(h, m, g, v, p) {\n      return (o(s(m * h * 0.25)) ** v + o(i(m * h * 0.25)) ** p) ** (-1 / g);\n    }\n    function u(h, m, g, v, p, b, _, M, R, w, E) {\n      const x = 2 * Math.PI / w, T = -Math.PI, y = Math.PI / (E - 1), A = -0.5 * Math.PI, C = h.getAttribute(\"position\");\n      let N = 0, U = 0, Y = A;\n      for (let V = 0; V < E; V++) {\n        U = T;\n        for (let ne = 0; ne < w; ne++) {\n          const Z = f(U, m, g, v, p), ee = f(Y, b, _, M, R);\n          C.setXYZ(\n            N,\n            Z * s(U) * ee * s(Y),\n            ee * i(Y),\n            Z * i(U) * ee * s(Y)\n          ), N++, U += x;\n        }\n        Y += y;\n      }\n      C.needsUpdate = !0, h.computeVertexNormals();\n    }\n    J(() => t.color, () => l.value = t.color), J(() => [t.widthSegments, t.heightSegments], () => {\n      a.value && a.value.dispose(), a.value = c(t.widthSegments, t.heightSegments), n();\n    }, { immediate: !0 }), J(() => [\n      t.numArmsA,\n      t.expA[0],\n      t.expA[1],\n      t.expA[2],\n      t.numArmsB,\n      t.expB[0],\n      t.expB[1],\n      t.expB[2]\n    ], () => {\n      u(a.value, t.numArmsA, t.expA[0], t.expA[1], t.expA[2], t.numArmsB, t.expB[0], t.expB[1], t.expB[2], t.widthSegments, t.heightSegments), n();\n    }, { immediate: !0 }), tt(() => {\n      a.value && a.value.dispose();\n    });\n    const d = re();\n    return e({\n      instance: d\n    }), (h, m) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"superformulaRef\",\n      ref: d\n    }, h.$attrs, { geometry: a.value }), [\n      Ne(h.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: l.value }, null, 8, Im)\n      ])\n    ], 16, Cm));\n  }\n}), Om = [\"rotation\"], Dm = [\"args\"], Lm = [\"color\"], Fv = /* @__PURE__ */ ue({\n  __name: \"Tetrahedron\",\n  props: {\n    args: { default: () => [1, 0] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), i = re();\n    return e({\n      instance: i\n    }), (o, a) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"tetrahedronRef\",\n      ref: i,\n      rotation: [-Math.PI / 2, 0, 0]\n    }, o.$attrs), [\n      ye(\"TresTetrahedronGeometry\", { args: F(n) }, null, 8, Dm),\n      Ne(o.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, Lm)\n      ])\n    ], 16, Om));\n  }\n}), km = [\"args\"], Nm = [\"color\"], zv = /* @__PURE__ */ ue({\n  __name: \"Torus\",\n  props: {\n    args: { default: () => [1, 1, 16, 80] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"torusRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresTorusGeometry\", { args: F(n) }, null, 8, km),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, Nm)\n      ])\n    ], 16));\n  }\n}), Bm = [\"args\"], Um = [\"color\"], Gv = /* @__PURE__ */ ue({\n  __name: \"TorusKnot\",\n  props: {\n    args: { default: () => [1, 0.4, 64, 8] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"torusKnotRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresTorusKnotGeometry\", { args: F(n) }, null, 8, Bm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, Um)\n      ])\n    ], 16));\n  }\n}), Fm = [\"args\"], zm = [\"color\"], Hv = /* @__PURE__ */ ue({\n  __name: \"Tube\",\n  props: {\n    args: { default: () => [\n      new cc(new $(-1, 0, 0), new $(0, 1, 0), new $(1, 0, 0)),\n      20,\n      0.2,\n      8,\n      !1\n    ] },\n    color: { default: \"#ffffff\" }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();\n    J(n, () => i());\n    const o = re();\n    return e({\n      instance: o\n    }), (a, l) => (ae(), ce(\"TresMesh\", $e({\n      ref_key: \"tubeRef\",\n      ref: o\n    }, a.$attrs), [\n      ye(\"TresTubeGeometry\", { args: F(n) }, null, 8, Fm),\n      Ne(a.$slots, \"default\", {}, () => [\n        ye(\"TresMeshBasicMaterial\", { color: F(s) }, null, 8, zm)\n      ])\n    ], 16));\n  }\n}), jv = /* @__PURE__ */ ue({\n  __name: \"Align\",\n  props: {\n    top: { type: Boolean },\n    right: { type: Boolean },\n    bottom: { type: Boolean },\n    left: { type: Boolean },\n    front: { type: Boolean },\n    back: { type: Boolean },\n    disable: { type: Boolean },\n    disableX: { type: Boolean },\n    disableY: { type: Boolean },\n    disableZ: { type: Boolean },\n    precise: { type: Boolean, default: !0 },\n    onAlign: {},\n    cacheKey: { default: void 0 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = re(), s = re(), i = re(), o = new _t(), a = new $(), l = new Ms();\n    function c() {\n      if (!s.value || !i.value || !n.value)\n        return;\n      s.value.matrixWorld.identity(), o.setFromObject(i.value, t.precise);\n      const h = o.max.x - o.min.x, m = o.max.y - o.min.y, g = o.max.z - o.min.z;\n      o.getCenter(a), o.getBoundingSphere(l);\n      const v = t.top ? m / 2 : t.bottom ? -m / 2 : 0, p = t.left ? -h / 2 : t.right ? h / 2 : 0, b = t.front ? g / 2 : t.back ? -g / 2 : 0;\n      s.value.position.set(\n        t.disable || t.disableX ? 0 : -a.x + p,\n        t.disable || t.disableY ? 0 : -a.y + v,\n        t.disable || t.disableZ ? 0 : -a.z + b\n      ), typeof t.onAlign < \"u\" && t.onAlign({\n        parent: n.value.parent,\n        container: n.value,\n        width: h,\n        height: m,\n        depth: g,\n        boundingBox: o,\n        boundingSphere: l,\n        center: a,\n        verticalAlignment: v,\n        horizontalAlignment: p,\n        depthAlignment: b\n      });\n    }\n    let f = null, u = null;\n    const d = Ve();\n    return et(() => {\n      f == null || f(), f = null;\n      const h = ze(t.cacheKey);\n      h === u && u !== null && u !== void 0 || (u = h, t.cacheKey === null || t.cacheKey === void 0 ? f = d.onBeforeRender(() => {\n        c();\n      }).off : c());\n    }), e({ instance: n, update: c }), (h, m) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"ref\",\n      ref: n\n    }, [\n      ye(\"TresGroup\", {\n        ref_key: \"outer\",\n        ref: s\n      }, [\n        ye(\"TresGroup\", {\n          ref_key: \"inner\",\n          ref: i\n        }, [\n          Ne(h.$slots, \"default\")\n        ], 512)\n      ], 512)\n    ], 512));\n  }\n}), Gm = [\"receive-shadow\", \"rotation\"], Hm = [\"args\"], Vv = /* @__PURE__ */ ue({\n  __name: \"Backdrop\",\n  props: {\n    floor: { default: 0.25 },\n    segments: { default: 20 },\n    receiveShadow: { type: Boolean, default: !1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = (c) => c === 0 ? 0 : 2 ** (10 * c - 10), { floor: s, segments: i, receiveShadow: o } = Le(t), a = me(null);\n    J(\n      [i, s, a],\n      ([c, f, u]) => {\n        if (!u || c === null)\n          return;\n        let d = 0;\n        const h = c / c / 2, m = u.attributes.position;\n        for (let g = 0; g < c + 1; g++)\n          for (let v = 0; v < c + 1; v++)\n            m.setXYZ(\n              d++,\n              g / c - h + (g === 0 ? -f : 0),\n              v / c - h,\n              n(g / c)\n            );\n        m.needsUpdate = !0, u.computeVertexNormals();\n      }\n    );\n    const l = re();\n    return e({ instance: l }), (c, f) => (ae(), ce(\"TresGroup\", $e({\n      ref_key: \"backdropRef\",\n      ref: l\n    }, c.$attrs), [\n      ye(\"TresMesh\", {\n        \"receive-shadow\": F(o),\n        rotation: [-Math.PI / 2, 0, Math.PI / 2]\n      }, [\n        ye(\"TresPlaneGeometry\", {\n          ref_key: \"planeRef\",\n          ref: a,\n          args: [1, 1, F(i), F(i)]\n        }, null, 8, Hm),\n        Ne(c.$slots, \"default\", {}, () => [\n          f[0] || (f[0] = ye(\"TresMeshStandardMaterial\", {\n            color: 8421504,\n            side: 2\n          }, null, -1))\n        ])\n      ], 8, Gm)\n    ], 16));\n  }\n}), jm = [\"object\"], Yv = /* @__PURE__ */ ue({\n  __name: \"ContactShadows\",\n  props: {\n    opacity: { default: 1 },\n    blur: { default: 1 },\n    color: { default: \"#000000\" },\n    tint: { default: void 0 },\n    scale: { default: 10 },\n    width: { default: 1 },\n    height: { default: 1 },\n    far: { default: 10 },\n    smooth: { type: Boolean, default: !0 },\n    resolution: { default: 512 },\n    frames: { default: Number.POSITIVE_INFINITY },\n    depthWrite: { type: Boolean, default: !1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r;\n    function n(h, m, g) {\n      g.blurPlane.visible = !0, g.blurPlane.material = g.horizontalBlurMaterial, g.horizontalBlurMaterial.uniforms.tDiffuse.value = g.renderTarget.texture, g.horizontalBlurMaterial.uniforms.h.value = h / 256, m.setRenderTarget(g.renderTargetBlur), m.render(g.blurPlane, g.shadowCamera), g.blurPlane.material = g.verticalBlurMaterial, g.verticalBlurMaterial.uniforms.tDiffuse.value = g.renderTargetBlur.texture, g.verticalBlurMaterial.uniforms.v.value = h / 256, m.setRenderTarget(g.renderTarget), m.render(g.blurPlane, g.shadowCamera), g.blurPlane.visible = !1;\n    }\n    function s(h, m, g, v) {\n      const {\n        renderTarget: p,\n        shadowCamera: b,\n        depthMaterial: _\n      } = v, M = m.background;\n      m.background = null, m.overrideMaterial = _;\n      const R = g.getClearAlpha();\n      g.setClearAlpha(0), g.setRenderTarget(p), g.render(m, b), m.overrideMaterial = null, n(h.blur, g, v), h.smooth && n(h.blur * 0.4, g, v), g.setRenderTarget(null), g.setClearAlpha(R), m.background = M;\n    }\n    function i(h) {\n      const m = new Zt(), g = new Xt(h.resolution, h.resolution);\n      g.texture.generateMipmaps = !1;\n      const v = new Xt(h.resolution, h.resolution);\n      v.texture.generateMipmaps = !1;\n      const p = new jt(h.width, h.height).rotateX(Math.PI / 2), b = new $t({\n        map: g.texture,\n        opacity: h.opacity,\n        transparent: !0,\n        depthWrite: h.depthWrite,\n        color: new be(h.color ?? \"black\")\n      }), _ = new de(p, b);\n      m.add(_), _.scale.y = -1;\n      const M = new de(p);\n      M.visible = !1, m.add(M);\n      const R = new _n(-h.width / 2, h.width / 2, h.height / 2, -h.height / 2, 0, 0.3);\n      R.rotation.x = Math.PI / 2, m.add(R);\n      const w = new Ko(), E = new bt(nf);\n      E.depthTest = !1;\n      const x = new bt(sf);\n      return x.depthTest = !1, {\n        renderTarget: g,\n        renderTargetBlur: v,\n        shadowCamera: R,\n        depthMaterial: w,\n        horizontalBlurMaterial: E,\n        verticalBlurMaterial: x,\n        shadowGroup: m,\n        plane: _,\n        blurPlane: M\n      };\n    }\n    function o(h, m) {\n      const g = m.shadowCamera;\n      g.left = -h.width / 2, g.right = h.width / 2, g.top = h.height / 2, g.bottom = -h.height / 2, g.far = h.far;\n      const v = h.width * (Array.isArray(h.scale) ? h.scale[0] : h.scale || 1), p = h.height * (Array.isArray(h.scale) ? h.scale[1] : h.scale || 1);\n      m.shadowGroup.scale.set(v, h.far, p);\n    }\n    function a(h, m) {\n      m.renderTarget.dispose(), m.renderTargetBlur.dispose(), m.renderTarget = new Xt(h, h), m.renderTarget.texture.generateMipmaps = !1, m.renderTargetBlur = new Xt(h, h), m.renderTargetBlur.texture.generateMipmaps = !1, m.plane.material.map = m.renderTarget.texture;\n    }\n    function l(h, m) {\n      m.plane.material.color = new be(h.color ?? \"black\"), m.depthMaterial.dispose(), m.depthMaterial = new Ko(), m.depthMaterial.onBeforeCompile = function(g) {\n        const v = h.tint ? new be(h.tint) : new be(\"white\"), { r: p, g: b, b: _ } = v, M = g.fragmentShader.replace(\n          \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\",\n          `gl_FragColor = vec4( ${p}, ${b}, ${_}, ( 1.0 - fragCoordZ ) * opacity);`\n        );\n        g.fragmentShader = M;\n      };\n    }\n    const { onBeforeRender: c } = Ve(), f = i(t);\n    let u = 0;\n    const d = () => u = u >= t.frames ? t.frames - 1 : u;\n    return c(\n      ({ renderer: h, scene: m, invalidate: g }) => {\n        u < t.frames && (u++, s(t, m, h, f), g());\n      }\n    ), J(() => [t.opacity, t.depthWrite, t.blur, t.smooth], () => {\n      f.plane.material.opacity = t.opacity ?? 1, f.plane.material.depthWrite = t.depthWrite ?? !1, d();\n    }, { immediate: !0 }), J(() => [t.color, t.tint], () => {\n      l(t, f), d();\n    }, { immediate: !0 }), J(() => [t.resolution], () => {\n      a(t.resolution, f), d();\n    }), J(() => [t.width, t.height, t.scale, t.far], () => {\n      o(t, f), d();\n    }, { immediate: !0 }), tt(() => {\n      for (const h of Object.values(f))\n        h && \"dispose\" in h && typeof h.dispose == \"function\" && h.dispose();\n    }), e({ instance: f.shadowGroup }), (h, m) => (ae(), ce(\"primitive\", {\n      object: F(f).shadowGroup\n    }, null, 8, jm));\n  }\n}), Wv = /* @__PURE__ */ ue({\n  __name: \"Fit\",\n  props: {\n    into: { default: () => new _t(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)) },\n    precise: { type: Boolean, default: !1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { invalidate: n } = xe(), s = re(new Zt()), i = re(new Zt());\n    function o(c, f) {\n      if (s.value.position.set(0, 0, 0), s.value.updateMatrixWorld(), i.value.scale.set(1, 1, 1), i.value.updateMatrixWorld(), !i.value.children.length || c === null)\n        return;\n      const { box3: u, use: d } = a(c, f), h = new _t();\n      i.value.children.forEach((b) => h.expandByObject(b, f));\n      const m = h.getSize(new $()), g = u.getSize(new $()), v = Math.min(\n        g.x / m.x,\n        g.y / m.y,\n        g.z / m.z\n      );\n      i.value.scale.setScalar(v === Number.POSITIVE_INFINITY ? 1 : v), i.value.updateMatrixWorld();\n      const p = s.value.worldToLocal(h.getCenter(new $()));\n      if (d.position) {\n        const b = s.value.worldToLocal(u.getCenter(new $()));\n        s.value.position.copy(b.sub(p.multiplyScalar(v)));\n      } else\n        s.value.position.copy(p.sub(p.multiplyScalar(v)));\n      n();\n    }\n    function a(c, f) {\n      return typeof c == \"number\" ? c = new $(c, c, c) : Array.isArray(c) && (c = new $(...c)), c && \"isVector3\" in c && c.isVector3 ? { box3: new _t(new $(0, 0, 0), c), use: { position: !1 } } : c && \"isBox3\" in c && c.isBox3 ? { box3: c, use: { position: !0 } } : c && \"isObject3D\" in c && c.isObject3D ? { box3: new _t().setFromObject(c, f ?? !1), use: { position: !0 } } : {\n        box3: new _t(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)),\n        use: { position: !0 }\n      };\n    }\n    J(() => [t.into, t.precise], () => o(t.into, t.precise)), bn(() => {\n      o(t.into, t.precise), Ro().then(() => {\n        o(t.into, t.precise);\n      });\n    });\n    const l = re();\n    return e({\n      instance: l,\n      fit: (c = new _t(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)), f = !1) => {\n        o(c, f);\n      },\n      update: () => o(t.into, t.precise)\n    }), (c, f) => (ae(), ce(\"TresGroup\", {\n      ref_key: \"outer\",\n      ref: l\n    }, [\n      ye(\"TresGroup\", {\n        ref_key: \"middle\",\n        ref: s\n      }, [\n        ye(\"TresGroup\", {\n          ref_key: \"inner\",\n          ref: i\n        }, [\n          Ne(c.$slots, \"default\")\n        ], 512)\n      ], 512)\n    ], 512));\n  }\n}), Vm = [\"side\", \"cell-size\", \"section-size\", \"cell-color\", \"section-color\", \"cell-thickness\", \"section-thickness\", \"fade-distance\", \"fade-strength\", \"fade-from\", \"infinite-grid\", \"follow-camera\"], Ym = [\"args\"], Xv = /* @__PURE__ */ ue({\n  __name: \"Grid\",\n  props: {\n    cellSize: { default: 0.5 },\n    cellThickness: { default: 0.5 },\n    cellColor: { default: \"#000000\" },\n    sectionSize: { default: 1 },\n    sectionThickness: { default: 1 },\n    sectionColor: { default: \"#0000ff\" },\n    followCamera: { type: Boolean, default: !1 },\n    infiniteGrid: { type: Boolean, default: !1 },\n    fadeDistance: { default: 100 },\n    fadeStrength: { default: 1 },\n    fadeFrom: { default: 1 },\n    side: { default: li },\n    args: {}\n  },\n  setup(r) {\n    const e = r, t = No(\n      {\n        cellSize: 0.5,\n        sectionSize: 1,\n        fadeDistance: 100,\n        fadeStrength: 1,\n        fadeFrom: 1,\n        cellThickness: 0.5,\n        sectionThickness: 1,\n        cellColor: new be(),\n        sectionColor: new be(),\n        infiniteGrid: !1,\n        followCamera: !1,\n        worldCamProjPosition: new $(),\n        worldPlanePosition: new $()\n      },\n      /* glsl */\n      `\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform vec3 worldPlanePosition;\n    uniform float fadeDistance;\n    uniform bool infiniteGrid;\n    uniform bool followCamera;\n\n    void main() {\n      localPosition = position.xzy;\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n      \n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\n      if (followCamera) {\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n      }\n\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    }\n  `,\n      /* glsl */\n      `\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform float cellSize;\n    uniform float sectionSize;\n    uniform vec3 cellColor;\n    uniform vec3 sectionColor;\n    uniform float fadeDistance;\n    uniform float fadeStrength;\n    uniform float fadeFrom;\n    uniform float cellThickness;\n    uniform float sectionThickness;\n\n    float getGrid(float size, float thickness) {\n      vec2 r = localPosition.xz / size;\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\n      return 1.0 - min(line, 1.0);\n    }\n\n    void main() {\n      float g1 = getGrid(cellSize, cellThickness);\n      float g2 = getGrid(sectionSize, sectionThickness);\n\n      vec3 from = worldCamProjPosition*vec3(fadeFrom);\n      float dist = distance(from, worldPosition.xyz);\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n      if (gl_FragColor.a <= 0.0) discard;\n\n      #include <tonemapping_fragment>\n      #include <colorspace_fragment>\n    }\n  `\n    );\n    Oa({ GridMaterial: t });\n    const n = re(new de()), s = new bs(), i = new $(0, 1, 0), o = new $(0, 0, 0);\n    return Ve().onBeforeRender((a) => {\n      s.setFromNormalAndCoplanarPoint(i, o).applyMatrix4(n.value.matrixWorld);\n      const l = n.value.material, c = l.uniforms.worldCamProjPosition, f = l.uniforms.worldPlanePosition;\n      s.projectPoint(a.camera.position, c.value), f.value.set(0, 0, 0).applyMatrix4(n.value.matrixWorld);\n    }), (a, l) => (ae(), ce(\"TresMesh\", {\n      ref_key: \"ref\",\n      ref: n,\n      \"frustum-culled\": !1\n    }, [\n      ye(\"TresGridMaterial\", {\n        transparent: !0,\n        \"extensions-derivatives\": !0,\n        side: e.side,\n        \"cell-size\": e.cellSize,\n        \"section-size\": e.sectionSize,\n        \"cell-color\": e.cellColor,\n        \"section-color\": e.sectionColor,\n        \"cell-thickness\": e.cellThickness,\n        \"section-thickness\": e.sectionThickness,\n        \"fade-distance\": e.fadeDistance,\n        \"fade-strength\": e.fadeStrength,\n        \"fade-from\": e.fadeFrom,\n        \"infinite-grid\": e.infiniteGrid,\n        \"follow-camera\": e.followCamera\n      }, null, 8, Vm),\n      ye(\"TresPlaneGeometry\", {\n        args: e.args\n      }, null, 8, Ym)\n    ], 512));\n  }\n}), Wm = [\"rotation-x\", \"args\"], $v = /* @__PURE__ */ ue({\n  __name: \"Ocean\",\n  props: {\n    textureWidth: { default: 512 },\n    textureHeight: { default: 512 },\n    waterNormals: { default: \"https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg\" },\n    sunDirection: { default: () => new $() },\n    sunColor: { default: 16777215 },\n    waterColor: { default: 7695 },\n    distortionScale: { default: 3.7 },\n    size: { default: 1 },\n    clipBias: { default: 0 },\n    alpha: { default: 1 },\n    side: { default: ss }\n  },\n  async setup(r, { expose: e }) {\n    let t, n;\n    const s = r, { textureWidth: i, textureHeight: o, waterNormals: a, sunDirection: l, sunColor: c, waterColor: f, distortionScale: u, size: d, clipBias: h, alpha: m, side: g } = Le(s), { extend: v, scene: p } = xe();\n    v({ Water: th });\n    const b = re(), _ = re(), M = p.value.fog !== void 0;\n    e({\n      instance: b\n    }), p.value.traverse((E) => {\n      Object.prototype.hasOwnProperty.call(E, \"isSky\") && (_.value = E);\n    }), bn(async () => {\n      if (await Ro(), _.value) {\n        const E = _.value.material.uniforms.sunPosition.value;\n        b.value.material.uniforms.sunDirection.value.copy(E);\n      }\n    });\n    const { normalMap: R } = ([t, n] = Tn(() => Bn({ normalMap: a.value })), t = await t, n(), t);\n    R.wrapS = R.wrapT = Ln;\n    const { onBeforeRender: w } = Ve();\n    return w(({ delta: E, invalidate: x }) => {\n      b.value.material.uniforms.time.value += E, x();\n    }), (E, x) => (ae(), ce(\"TresWater\", {\n      ref_key: \"waterRef\",\n      ref: b,\n      \"rotation-x\": -Math.PI / 2,\n      args: [void 0, {\n        textureWidth: F(i),\n        textureHeight: F(o),\n        waterNormals: F(R),\n        sunDirection: F(l),\n        sunColor: F(c),\n        waterColor: F(f),\n        distortionScale: F(u),\n        fog: M,\n        size: F(d),\n        clipBias: F(h),\n        alpha: F(m),\n        side: F(g)\n      }]\n    }, [\n      Ne(E.$slots, \"default\", {}, () => [\n        x[0] || (x[0] = ye(\"TresPlaneGeometry\", { args: [1e4, 1e4] }, null, -1))\n      ])\n    ], 8, Wm));\n  }\n}), Xm = [\"size\", \"color\", \"alpha-map\", \"map\", \"opacity\", \"alpha-test\", \"depth-write\", \"transparent\", \"size-attenuation\"], $m = [\"position\", \"velocity\"], Zv = /* @__PURE__ */ ue({\n  __name: \"Precipitation\",\n  props: {\n    size: { default: 0.1 },\n    area: { default: () => [10, 10, 20] },\n    color: { default: 16777215 },\n    map: {},\n    alphaMap: {},\n    alphaTest: { default: 0.01 },\n    opacity: { default: 0.8 },\n    count: { default: 5e3 },\n    speed: { default: 0.1 },\n    randomness: { default: 0.5 },\n    depthWrite: { type: Boolean, default: !1 },\n    transparent: { type: Boolean, default: !0 },\n    sizeAttenuation: { type: Boolean, default: !0 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, {\n      size: n,\n      area: s,\n      color: i,\n      alphaMap: o,\n      map: a,\n      opacity: l,\n      alphaTest: c,\n      depthWrite: f,\n      transparent: u,\n      sizeAttenuation: d,\n      count: h,\n      speed: m,\n      randomness: g\n    } = Le(t), v = re();\n    let p = [], b = [];\n    const _ = () => {\n      p = new Float32Array(h.value * 3);\n      for (let T = 0; T < h.value; T++) {\n        const y = T * 3;\n        p[y] = (Math.random() - 0.5) * s.value[0], p[y + 1] = (Math.random() - 0.5) * s.value[1], p[y + 2] = (Math.random() - 0.5) * s.value[2];\n      }\n    }, M = () => {\n      b = new Float32Array(h.value * 2);\n      for (let T = 0; T < h.value * 2; T += 2)\n        b[T] = (Math.random() - 0.5) / 5 * m.value * g.value, b[T + 1] = Math.random() / 5 * m.value;\n    };\n    M(), _(), et(() => {\n      M(), _();\n    });\n    const R = re(null), w = re(null);\n    et(async () => {\n      et(async () => {\n        if (typeof o.value == \"string\") {\n          const T = await Bn({ alphaMap: o.value });\n          R.value = T.alphaMap;\n        } else\n          R.value = o.value ?? null;\n        if (typeof a.value == \"string\") {\n          const T = await Bn({ map: a.value });\n          w.value = T.map;\n        } else\n          w.value = a.value ?? null;\n      });\n    });\n    const { onBeforeRender: E } = Ve();\n    E(({ invalidate: T }) => {\n      var y, A;\n      if ((y = v.value) != null && y.attributes.position.array && ((A = v.value) != null && A.attributes.position.count)) {\n        const C = v.value.attributes.position.array;\n        for (let N = 0; N < v.value.attributes.position.count; N++) {\n          const U = b[N * 2], Y = b[N * 2 + 1];\n          C[N * 3] += U, C[N * 3 + 1] -= Y, (C[N * 3] <= -s.value[0] / 2 || C[N * 3] >= s.value[0] / 2) && (C[N * 3] = C[N * 3] * -1), (C[N * 3 + 1] <= -s.value[1] / 2 || C[N * 3 + 1] >= s.value[1] / 2) && (C[N * 3 + 1] = C[N * 3 + 1] * -1);\n        }\n        v.value.attributes.position.needsUpdate = !0, T();\n      }\n    });\n    const x = re();\n    return e({ instance: x }), (T, y) => (ae(), ce(\"TresPoints\", {\n      ref_key: \"pointsRef\",\n      ref: x\n    }, [\n      ye(\"TresPointsMaterial\", {\n        size: F(n),\n        color: F(i),\n        \"alpha-map\": R.value,\n        map: w.value,\n        opacity: F(l),\n        \"alpha-test\": F(c),\n        \"depth-write\": F(f),\n        transparent: F(u),\n        \"size-attenuation\": F(d)\n      }, null, 8, Xm),\n      ye(\"TresBufferGeometry\", {\n        ref_key: \"geometryRef\",\n        ref: v,\n        position: [F(p), 3],\n        velocity: [F(b)]\n      }, null, 8, $m)\n    ], 512));\n  }\n}), Zm = [\"object\", \"material-uniforms-turbidity-value\", \"material-uniforms-rayleigh-value\", \"material-uniforms-mieCoefficient-value\", \"material-uniforms-mieDirectionalG-value\", \"material-uniforms-sunPosition-value\", \"scale\"], Kv = /* @__PURE__ */ ue({\n  __name: \"Sky\",\n  props: {\n    turbidity: { default: 3.4 },\n    rayleigh: { default: 3 },\n    mieCoefficient: { default: 5e-3 },\n    mieDirectionalG: { default: 0.7 },\n    elevation: { default: 0.6 },\n    azimuth: { default: 180 },\n    distance: { default: 45e4 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, { invalidate: n } = xe();\n    J(t, () => n());\n    const s = re(), i = new Fo(), o = Pe(\n      () => a(t.azimuth, t.elevation)\n    );\n    function a(l, c) {\n      const f = Ye.degToRad(90 - c), u = Ye.degToRad(l);\n      return new $().setFromSphericalCoords(1, f, u);\n    }\n    return e({\n      instance: s,\n      sunPosition: o.value\n    }), (l, c) => (ae(), ce(\"primitive\", {\n      ref_key: \"skyRef\",\n      ref: s,\n      object: F(i),\n      \"material-uniforms-turbidity-value\": t.turbidity,\n      \"material-uniforms-rayleigh-value\": t.rayleigh,\n      \"material-uniforms-mieCoefficient-value\": t.mieCoefficient,\n      \"material-uniforms-mieDirectionalG-value\": t.mieDirectionalG,\n      \"material-uniforms-sunPosition-value\": o.value,\n      scale: t.distance\n    }, null, 8, Zm));\n  }\n}), Km = [\"position\"], qm = [\"position\"], Qm = [\"scale\"], Jm = [\"map\", \"depth-test\", \"color-space\", \"color\", \"opacity\"], qv = /* @__PURE__ */ ue({\n  __name: \"Smoke\",\n  props: {\n    color: { default: \"#ffffff\" },\n    opacity: { default: 0.5 },\n    speed: { default: 0.4 },\n    width: { default: 10 },\n    depth: { default: 1.5 },\n    segments: { default: 20 },\n    texture: { default: \"https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png\" },\n    depthTest: { type: Boolean, default: !0 }\n  },\n  async setup(r, { expose: e }) {\n    let t, n;\n    const s = r, { width: i, depth: o, segments: a, texture: l, color: c, depthTest: f, opacity: u, speed: d } = Le(s), h = re(), m = re();\n    e({\n      instance: h\n    });\n    const g = [a].map((w, E) => ({\n      x: i.value / 2 - Math.random() * i.value,\n      y: i.value / 2 - Math.random() * i.value,\n      scale: 0.4 + Math.sin((E + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),\n      density: Math.max(0.2, Math.random()),\n      rotation: Math.max(2e-3, 5e-3 * Math.random()) * d.value\n    })), v = (w, E) => w / 6 * E * u.value, { map: p } = ([t, n] = Tn(() => Bn({ map: l.value })), t = await t, n(), t), { renderer: b, camera: _ } = xe(), M = Pe(() => {\n      var w;\n      return (w = b.value) == null ? void 0 : w.outputColorSpace;\n    }), { onBeforeRender: R } = Ve();\n    return R(({ invalidate: w }) => {\n      var E, x;\n      h.value && _.value && m.value && ((E = m.value) == null || E.children.forEach((T, y) => {\n        T.rotation.z += g[y].rotation;\n      }), h.value.lookAt((x = _.value) == null ? void 0 : x.position), w());\n    }), (w, E) => (ae(), ce(\"TresGroup\", $e({\n      ref_key: \"smokeRef\",\n      ref: h\n    }, w.$attrs), [\n      ye(\"TresGroup\", {\n        ref_key: \"groupRef\",\n        ref: m,\n        position: [0, 0, F(a) / 2 * F(o)]\n      }, [\n        (ae(!0), ce(Ra, null, Ca(F(g), ({ scale: x, x: T, y, density: A }, C) => (ae(), ce(\"TresMesh\", {\n          key: `${C}`,\n          position: [T, y, -C * F(o)]\n        }, [\n          ye(\"TresPlaneGeometry\", {\n            scale: [x, x, x],\n            rotation: [0, 0, 0]\n          }, null, 8, Qm),\n          ye(\"TresMeshStandardMaterial\", {\n            map: F(p),\n            \"depth-test\": F(f),\n            \"color-space\": M.value,\n            color: F(c),\n            \"depth-write\": !1,\n            transparent: \"\",\n            opacity: v(x, A)\n          }, null, 8, Jm)\n        ], 8, qm))), 128))\n      ], 8, Km)\n    ], 16));\n  }\n}), eg = `\nreturn PCSS( shadowMap, shadowCoord );\n`, Qv = /* @__PURE__ */ ue({\n  __name: \"SoftShadows\",\n  props: {\n    size: { default: 25 },\n    samples: { default: 10 },\n    focus: { default: 0 }\n  },\n  setup(r) {\n    const e = r, t = ({ focus: c = 0, size: f = 25, samples: u = 10 } = {}) => `\n#define PENUMBRA_FILTER_SIZE float(${f})\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\nvec3 randRGB(vec2 uv) {\n  return vec3(\n    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n  );\n}\n\nvec3 lowPassRandRGB(vec2 uv) {\n  // 3x3 convolution (average)\n  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n  vec3 result = vec3(0);\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n  result *= 0.111111111; // 1.0 / 9.0\n  return result;\n}\nvec3 highPassRandRGB(vec2 uv) {\n  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n  // hp(x) = x - lp(x)\n  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n}\n\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n  return (zReceiver - zBlocker) / zBlocker;\n}\nfloat findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n  float blockerDepthSum = float(${c});\n  float blockers = 0.0;\n\n  int j = 0;\n  vec2 offset = vec2(0.);\n  float depth = 0.;\n\n  #pragma unroll_loop_start\n  for(int i = 0; i < ${u}; i ++) {\n    offset = (vogelDiskSample(j, ${u}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\n    if (depth < compare) {\n      blockerDepthSum += depth;\n      blockers++;\n    }\n    j++;\n  }\n  #pragma unroll_loop_end\n\n  if (blockers > 0.0) {\n    return blockerDepthSum / blockers;\n  }\n  return -1.0;\n}\n\n        \nfloat vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n  float shadow = 0.0f;\n  int j = 0;\n  vec2 vogelSample = vec2(0.0);\n  vec2 offset = vec2(0.0);\n  #pragma unroll_loop_start\n  for (int i = 0; i < ${u}; i++) {\n    vogelSample = vogelDiskSample(j, ${u}, angle) * texelSize;\n    offset = vogelSample * (1.0 + filterRadius * float(${f}));\n    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    j++;\n  }\n  #pragma unroll_loop_end\n  return shadow * 1.0 / ${u}.0;\n}\n\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\n  vec2 uv = coords.xy;\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\n  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\n  if (avgBlockerDepth == -1.0) {\n    return 1.0;\n  }\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\n}`, n = Ti.shadowmap_pars_fragment, { renderer: s, scene: i, camera: o } = xn();\n    function a(c, f) {\n      let u = n;\n      u = u.replace(\n        \"#ifdef USE_SHADOWMAP\",\n        `#ifdef USE_SHADOWMAP\n    ${t(f)}`\n      ), u = u.replace(\n        \"#if defined( SHADOWMAP_TYPE_PCF )\",\n        `${eg} \n    #if defined( SHADOWMAP_TYPE_PCF )`\n      ), Ti.shadowmap_pars_fragment = u, c.shadowMap.enabled = !0;\n    }\n    function l(c, f, u) {\n      f.traverse((d) => {\n        var h, m;\n        \"material\" in d && d.material && (c.properties.remove(d.material), typeof d.material == \"object\" && \"dispose\" in d.material && typeof d.material.dispose == \"function\" && ((m = (h = d.material).dispose) == null || m.call(h)));\n      }), c.info.programs && (c.info.programs.length = 0), c.compile(f, u);\n    }\n    return tt(() => {\n      o.value && (Ti.shadowmap_pars_fragment = n, l(s.value, i.value, o.value));\n    }), J(e, () => {\n      o.value && (a(s.value, e), l(s.value, i.value, o.value));\n    }, { immediate: !0 }), (c, f) => (ae(), ce(\"TresGroup\"));\n  }\n});\nfunction tg(r) {\n  return Yo(r, {\n    normalizeValue: (e) => tn(e),\n    getDefaultValue: () => new be(0, 0, 0),\n    isSingleValue: (e) => !Array.isArray(e),\n    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),\n    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),\n    isEmpty: (e) => Array.isArray(e) && e.length === 0\n  });\n}\nfunction so(r) {\n  return \"isVector3\" in r || Array.isArray(r) && r.length > 0 && r.every((e) => typeof e == \"number\");\n}\nfunction ng(r) {\n  return Yo(r, {\n    normalizeValue: (e) => Ia(e),\n    getDefaultValue: () => [0, 0, 0],\n    isSingleValue: (e) => so(e),\n    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && so(e[0]),\n    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && so(e[0][1]),\n    isEmpty: (e) => Array.isArray(e) && e.length === 0\n  });\n}\nfunction sg(r) {\n  return Yo(r, {\n    normalizeValue: (e) => e,\n    getDefaultValue: () => 1,\n    isSingleValue: (e) => !Array.isArray(e) && typeof e < \"u\",\n    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),\n    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),\n    isEmpty: (e) => Array.isArray(e) && e.length === 0\n  });\n}\nfunction Yo(r, e) {\n  const { normalizeValue: t, getDefaultValue: n, isEmpty: s } = e, i = (l) => e.isSingleValue(l), o = (l) => e.isMultipleValues(l), a = (l) => e.isMultipleValuesWithStops(l);\n  if (s(r))\n    return [[0, n()]];\n  if (i(r))\n    return [[0, t(r)]];\n  if (o(r)) {\n    const l = r.length > 1 ? 1 / (r.length - 1) : 1;\n    return r.map((c, f) => [l * f, t(c)]);\n  } else if (a(r))\n    return r.map(([l, c], f) => [l, t(c)]);\n  return [[0, n()]];\n}\nclass ig {\n  constructor(e, t) {\n    pe(this, \"entries\");\n    pe(this, \"resolution\");\n    this.entries = e, this.resolution = t;\n  }\n  useTexture() {\n    return new ag(this.entries, this.resolution).use();\n  }\n}\nclass Wo {\n  constructor(e, t, n, s, i, o) {\n    pe(this, \"data\");\n    pe(this, \"ref\");\n    pe(this, \"name\");\n    pe(this, \"valueMin\");\n    pe(this, \"valueMax\");\n    pe(this, \"suffix\");\n    pe(this, \"renderToCanvasGradient\");\n    this.data = ii(e) ? e.value : e, this.ref = ii(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = o;\n  }\n}\nclass og extends Wo {\n  constructor(e, t = \"color\", n = 0, s = 1, i = \"rgba\", o = lg) {\n    super(e, t, n, s, i, o);\n  }\n}\nclass oa extends Wo {\n  constructor(e, t = \"scalar\", n = 0, s = 1, i = \"x\", o = cg) {\n    super(e, t, n, s, i, o);\n  }\n}\nclass rg extends Wo {\n  constructor(e, t = \"scalar3\", n = 0, s = 1, i = \"xyz\", o = ug) {\n    super(e, t, n, s, i, o);\n  }\n}\nclass ag {\n  constructor(e, t) {\n    pe(this, \"entries\");\n    pe(this, \"size\");\n    pe(this, \"dirty\", re(0));\n    pe(this, \"context\");\n    this.entries = e, this.size = Math.max(t, e.length);\n    const n = document.createElement(\"canvas\");\n    n.height = this.size, n.width = this.size, this.context = n.getContext(\"2d\");\n  }\n  use() {\n    const e = this.build(), t = re(e);\n    for (const n of this.entries)\n      n.ref && J(n.ref, () => {\n        var s;\n        n.data = (s = n.ref) == null ? void 0 : s.value, vc(this.dirty);\n      });\n    return Xc(\n      this.dirty,\n      () => {\n        this.build(e), t.value = e;\n      },\n      { throttle: 1e3 / 60 }\n    ), {\n      texture: t,\n      dispose: () => e.dispose(),\n      yFor: this.entries.reduce((n, s, i) => (n[s.name] = (i + 0.5) / this.size, n), {})\n    };\n  }\n  build(e) {\n    this.entries.forEach((n, s) => {\n      const i = this.context.createLinearGradient(0, s, this.size, s);\n      n.renderToCanvasGradient(i, n), this.context.fillStyle = i, this.context.fillRect(0, s, this.size, 1);\n    }), e && (e.source.data = this.context.getImageData(\n      0,\n      0,\n      this.size,\n      this.size\n    ));\n    const t = e ?? new ti(\n      this.context.getImageData(0, 0, this.size, this.size).data,\n      this.size,\n      this.size,\n      ei,\n      uc,\n      hc,\n      Wt,\n      Wt\n    );\n    return t.needsUpdate = !0, t;\n  }\n}\nfunction El(r, e, t, n, s) {\n  return Ye.mapLinear(Ye.clamp(r, e, t), e, t, n, s);\n}\nfunction lg(r, e) {\n  return tg(e.data).forEach(\n    ([t, n]) => r.addColorStop(\n      t,\n      `rgb(${n.r * 255}, ${n.g * 255}, ${n.b * 255})`\n    )\n  );\n}\nfunction cg(r, e) {\n  return sg(e.data).forEach(([t, n]) => {\n    r.addColorStop(\n      t,\n      `rgb(${El(\n        n,\n        e.valueMin,\n        e.valueMax,\n        0,\n        255\n      )}, 0, 0)`\n    );\n  });\n}\nfunction ug(r, e) {\n  return ng(e.data).forEach(\n    ([t, n]) => r.addColorStop(\n      t,\n      `rgb(${n.map(\n        (s) => El(s, e.valueMin, e.valueMax, 0, 255)\n      )})`\n    )\n  );\n}\nclass hg {\n  constructor(e = 256) {\n    pe(this, \"entries\");\n    pe(this, \"resolution\");\n    this.resolution = e, this.entries = [];\n  }\n  withResolution(e) {\n    return this.resolution = e, this;\n  }\n  get add() {\n    return new dg(\n      (e) => this.onAdd(e)\n    );\n  }\n  build() {\n    return new ig(this.entries, this.resolution);\n  }\n  onAdd(e) {\n    return this.entries.push(e), new fg(e, this);\n  }\n}\nclass fg {\n  constructor(e, t) {\n    pe(this, \"entry\");\n    pe(this, \"parent\");\n    this.entry = e, this.parent = t;\n  }\n  id(e) {\n    return this.entry.name = e, this;\n  }\n  range(e, t) {\n    return this.entry.valueMin = e, this.entry.valueMax = t, this;\n  }\n  suffix(e) {\n    return this.entry.suffix = e, this;\n  }\n  canvasGradientRenderer(e) {\n    return this.entry.renderToCanvasGradient = e, this;\n  }\n  /**\n   * Add another entry to the ShaderDataBuilder\n   */\n  get add() {\n    return this.parent.add;\n  }\n  /**\n   * Finalize the ShaderDataBuilder\n   * @returns ShaderData\n   */\n  build() {\n    return this.parent.build();\n  }\n}\nclass dg {\n  constructor(e) {\n    pe(this, \"onAdd\");\n    this.onAdd = e;\n  }\n  GradientTresColor(e) {\n    return this.onAdd(new og(e));\n  }\n  Gradient01(e) {\n    return this.onAdd(new oa(e, \"zeroOne\", 0, 1));\n  }\n  GradientScalar(e, t, n) {\n    return this.onAdd(\n      new oa(e, \"scalar\", t, n)\n    );\n  }\n  GradientXyz(e, t, n) {\n    return this.onAdd(\n      new rg(e, \"position\", t, n)\n    );\n  }\n}\nlet io = null;\nfunction pg() {\n  return io === null && (io = new ti(new Uint8Array([0, 0, 0, 0]), 1, 1)), io;\n}\nconst mg = [\"object\"], Jv = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    map: { default: \"https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png\" },\n    geometry: { default: void 0 },\n    directionalLight: { default: void 0 },\n    lifetimeSec: { default: 0.4 },\n    cooldownSec: { default: 2 },\n    normalThreshold: { default: 0.7 },\n    noiseScale: { default: 3 },\n    scaleNoise: { default: 1 },\n    offsetNoise: { default: 0.1 },\n    lifetimeNoise: { default: 0 },\n    size: { default: 1 },\n    alpha: { default: 1 },\n    offset: { default: 1 },\n    surfaceDistance: { default: 1 },\n    sequenceColor: { default: () => [[0.7, \"#82dbc5\"], [0.8, \"#fbb03b\"]] },\n    sequenceAlpha: { default: () => [[0, 0], [0.1, 1], [0.5, 1], [0.9, 0]] },\n    sequenceOffset: { default: () => [0, 0, 0] },\n    sequenceNoise: { default: () => [0.1, 0.1, 0.1] },\n    sequenceSize: { default: () => [0, 1] },\n    sequenceSurfaceDistance: { default: () => [0.05, 0.08, 0.1] },\n    mixColor: { default: 0.5 },\n    mixAlpha: { default: 1 },\n    mixOffset: { default: 1 },\n    mixSize: { default: 0 },\n    mixSurfaceDistance: { default: 1 },\n    mixNoise: { default: 1 },\n    blending: { default: So },\n    transparent: { type: Boolean, default: !0 },\n    depthWrite: { type: Boolean, default: !1 }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = Number.parseInt(Ts.replace(/\\D+/g, \"\")), s = Le(t), i = typeof t.map == \"string\" ? pg() : t.map, { texture: o, yFor: a } = new hg(256).add.GradientTresColor(s.sequenceColor).id(\"sequenceColor\").add.Gradient01(s.sequenceAlpha).id(\"sequenceAlpha\").add.Gradient01(s.sequenceSurfaceDistance).id(\"sequenceSurfaceDistance\").add.Gradient01(s.sequenceSize).id(\"sequenceSize\").add.GradientXyz(s.sequenceOffset, -1, 1).id(\"sequenceOffset\").add.GradientXyz(s.sequenceNoise, 0, 1).id(\"sequenceNoise\").build().useTexture(), l = {\n      blending: t.blending,\n      transparent: t.transparent,\n      depthWrite: t.depthWrite,\n      uniforms: {\n        uMap: new Se(i),\n        uPixelRatio: new Se(1),\n        uNormal: new Se(Rt.DEFAULT_UP),\n        uNormalThreshold: new Se(t.normalThreshold),\n        uTime: new Se(0),\n        uCooldownRatio: new Se(1),\n        uSize: new Se(t.size),\n        uAlpha: new Se(t.alpha),\n        uOffset: new Se(t.offset),\n        uSurfaceDistance: new Se(t.surfaceDistance),\n        uNoiseScale: new Se(t.noiseScale),\n        uScaleNoise: new Se(t.scaleNoise),\n        uOffsetNoise: new Se(t.offsetNoise),\n        uLifetimeNoise: new Se(t.lifetimeNoise),\n        uMixColor: new Se(t.mixColor),\n        uMixAlpha: new Se(t.mixAlpha),\n        uMixOffset: new Se(t.mixOffset),\n        uMixSize: new Se(t.mixSize),\n        uMixSurfaceDistance: new Se(t.mixSurfaceDistance),\n        uMixNoise: new Se(t.mixNoise),\n        uInfoTexture: new Se(o.value)\n      },\n      vertexShader: `\n    uniform float uPixelRatio;\n    uniform vec3 uNormal;\n    uniform float uNormalThreshold;\n    uniform float uTime;\n    uniform float uCooldownRatio;\n    uniform float uSize;\n    uniform float uAlpha;\n    uniform float uOffset;\n    uniform float uSurfaceDistance;\n    uniform float uNoiseScale;\n    uniform float uScaleNoise;\n    uniform float uOffsetNoise;\n    uniform float uLifetimeNoise;\n    uniform float uMixColor;\n    uniform float uMixAlpha;\n    uniform float uMixOffset;\n    uniform float uMixSize;\n    uniform float uMixSurfaceDistance;\n    uniform float uMixNoise;\n    uniform sampler2D uInfoTexture;\n\n    varying vec4 vColor;\n\n    void main() {\n      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;\n      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);\n      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);\n\n      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + \n      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;\n\n      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));\n      float surfaceDistance = texture2D(uInfoTexture, vec2(\n        mix(normalP, lifetimeP, uMixSurfaceDistance),\n        ${a.sequenceSurfaceDistance})).x * uSurfaceDistance;\n\n      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));\n      vec3 noise = texture2D(uInfoTexture, vec2(\n        mix(normalP, lifetimeP, uMixNoise),\n        ${a.sequenceNoise})).xyz;\n      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(\n        mix(normalP, lifetimeP, uMixOffset),\n        ${a.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));\n      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;\n      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;\n      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;\n\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectionPostion = projectionMatrix * viewPosition;\n      gl_Position = projectionPostion;\n\n      gl_PointSize = 2.\n      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${a.sequenceSize})).x\n      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)\n      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;\n\n      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }\n\n      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${a.sequenceColor}))\n      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${a.sequenceAlpha})).x * uAlpha;\n    }`,\n      fragmentShader: `\n    varying vec4 vColor;\n\n    uniform sampler2D uMap;\n    uniform sampler2D uInfoTexture;\n\n    void main() {\n      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);\n      #include <tonemapping_fragment>\n      #include <${n >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n    }`\n    }, c = new bt(l), f = new ba(void 0, c), u = c.uniforms, d = { immediate: !0 };\n    [\n      [u.uPixelRatio, xe().sizes.aspectRatio],\n      [u.uSize, s.size],\n      [u.uNormalThreshold, s.normalThreshold],\n      [u.uAlpha, s.alpha],\n      [u.uOffset, s.offset],\n      [u.uOffsetNoise, s.offsetNoise],\n      [u.uMixColor, s.mixColor],\n      [u.uMixAlpha, s.mixAlpha],\n      [u.uMixOffset, s.mixOffset],\n      [u.uMixSize, s.mixSize],\n      [u.uMixSurfaceDistance, s.mixSurfaceDistance],\n      [u.uMixNoise, s.mixNoise],\n      [u.uInfoTexture, o]\n    ].forEach(\n      ([_, M]) => J(\n        M,\n        () => {\n          _.value = M.value;\n        },\n        d\n      )\n    ), J([s.noiseScale, s.lifetimeSec], () => {\n      u.uNoiseScale.value = s.noiseScale.value * s.lifetimeSec.value;\n    }, d), J([s.lifetimeSec, s.cooldownSec], () => {\n      u.uCooldownRatio.value = s.cooldownSec.value / s.lifetimeSec.value;\n    }, d), J(s.map, () => {\n      typeof s.map.value == \"string\" ? Bn([s.map.value]).then((_) => c.uniforms.uMap.value = _) : c.uniforms.uMap.value = s.map.value;\n    });\n    const m = new je(), g = new $();\n    Ve().onBeforeRender(({ elapsed: _, invalidate: M }) => {\n      f.getWorldQuaternion(m), g.copy(t.directionalLight ? t.directionalLight.position : Rt.DEFAULT_UP).normalize(), g.applyQuaternion(m.invert()), c.uniforms.uNormal.value = g, c.uniforms.uTime.value = _ / (t.cooldownSec + t.lifetimeSec), M();\n    });\n    function v(_) {\n      return _ && \"isObject3D\" in _;\n    }\n    function p(_) {\n      return _ && \"isBufferGeometry\" in _;\n    }\n    bn(() => {\n      t.geometry ? p(t.geometry) ? f.geometry.copy(t.geometry) : v(t.geometry) && \"geometry\" in t.geometry && p(t.geometry.geometry) && f.geometry.copy(t.geometry.geometry) : v(f.parent) && \"geometry\" in f.parent && p(f.parent.geometry) ? f.geometry.copy(f.parent.geometry) : f.geometry = new fc(1, 16), typeof t.map == \"string\" && Bn([t.map]).then((_) => c.uniforms.uMap.value = _);\n    }), tt(() => {\n      var _;\n      (_ = c.uniforms.uMap.value) == null || _.dispose(), o.value.dispose(), c.dispose();\n    });\n    const b = re();\n    return e({ instance: f }), (_, M) => (ae(), ce(\"primitive\", {\n      ref_key: \"sparkleRef\",\n      ref: b,\n      object: F(f)\n    }, null, 8, mg));\n  }\n}), gg = [\"position\", \"a-scale\"], vg = [\"size\", \"size-attenuation\", \"transparent\", \"alpha-test\", \"alpha-map\"], e0 = /* @__PURE__ */ ue({\n  __name: \"Stars\",\n  props: {\n    size: { default: 0.1 },\n    sizeAttenuation: { type: Boolean, default: !0 },\n    transparent: { type: Boolean, default: !0 },\n    alphaTest: { default: 0.01 },\n    count: { default: 5e3 },\n    depth: { default: 50 },\n    radius: { default: 100 },\n    alphaMap: { default: null }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = me(), s = me(), { radius: i, depth: o, count: a, size: l, sizeAttenuation: c, transparent: f, alphaMap: u, alphaTest: d } = Le(t), { invalidate: h } = xe();\n    J(t, () => {\n      h();\n    });\n    const m = () => {\n      let v = i.value + o.value;\n      const p = Pe(() => o.value / a.value), b = [], _ = Array.from(\n        { length: a.value },\n        () => (0.5 + 0.5 * Math.random()) * 4\n      ), M = (R) => new $().setFromSpherical(new si(R, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();\n      for (let R = 0; R < a.value; R++)\n        v -= p.value * Math.random(), b.push(...M(v));\n      n.value = new Float32Array(b), s.value = new Float32Array(_);\n    };\n    et(() => {\n      m();\n    });\n    const g = re();\n    return e({\n      instance: g\n    }), (v, p) => (ae(), ce(\"TresPoints\", {\n      ref_key: \"starsRef\",\n      ref: g\n    }, [\n      ye(\"TresBufferGeometry\", {\n        position: [n.value, 3],\n        \"a-scale\": [s.value, 1]\n      }, null, 8, gg),\n      ye(\"TresPointsMaterial\", {\n        size: F(l),\n        \"size-attenuation\": F(c),\n        transparent: F(f),\n        \"alpha-test\": F(d),\n        \"alpha-map\": F(u)\n      }, null, 8, vg)\n    ], 512));\n  }\n});\nclass ra extends Rt {\n  constructor() {\n    super();\n    pe(this, \"virtualScene\", null);\n    this.virtualScene = new xs();\n  }\n  add(...t) {\n    return this.virtualScene.add(...t), this;\n  }\n  dispose() {\n    this.virtualScene.traverse((t) => {\n      t instanceof de && (t.geometry.dispose(), t.material.dispose(), t.material.map && t.material.map.dispose(), this.virtualScene.remove(t));\n    }), this.virtualScene = null;\n  }\n}\nconst t0 = /* @__PURE__ */ ue({\n  __name: \"component\",\n  props: {\n    background: { type: [Boolean, String], default: !1 },\n    blur: { default: 0 },\n    files: { default: () => [] },\n    path: { default: \"\" },\n    preset: { default: void 0 },\n    resolution: { default: 256 },\n    near: { default: 1 },\n    far: { default: 1e3 },\n    frames: { default: Number.POSITIVE_INFINITY },\n    backgroundIntensity: { default: 1 },\n    backgroundRotation: {},\n    environmentIntensity: { default: 1 },\n    environmentRotation: {},\n    syncMaterials: { type: Boolean }\n  },\n  async setup(r, { expose: e }) {\n    let t, n;\n    const s = r, i = me(null);\n    e({ texture: i });\n    const { extend: o, renderer: a, scene: l } = xe();\n    o({ EnvironmentScene: ra });\n    let c = null;\n    const f = me(null);\n    let u = null;\n    const d = me(null), h = ([t, n] = Tn(() => vd(s, f)), t = await t, n(), t), { onBeforeRender: m } = Ve();\n    let g = 1;\n    m(() => {\n      if (u && d.value && f.value && (s.frames === Number.POSITIVE_INFINITY || g < s.frames)) {\n        const p = a.value.autoClear;\n        a.value.autoClear = !0;\n        const b = qo(d.value).virtualScene;\n        u.update(a.value, b), a.value.autoClear = p, g++;\n      }\n    }, -1), J([h, d], ([p, b]) => {\n      if (p && (b != null && b.virtualScene)) {\n        const _ = qo(b).virtualScene;\n        let M = _.children.find(\n          (R) => R instanceof de && R.userData.isEnvironment\n        );\n        M || (M = new de(\n          new Ht(1, 1, 1),\n          new $t({ side: li })\n        ), M.userData.isEnvironment = !0, _.add(M)), _.background = p, _.backgroundBlurriness = s.blur;\n      }\n    }, { immediate: !0 });\n    const v = (p) => {\n      p && (c != null && c.length) ? (l.value.environment = p.texture, s.background && (l.value.background = p.texture)) : h.value && (l.value.environment = h.value, s.background && (l.value.background = h.value));\n    };\n    return J(h, () => {\n      f.value && v(f.value);\n    }, { immediate: !0, deep: !0 }), J(() => Io().default, (p) => {\n      var b;\n      if (p && (c = p(), Array.isArray(c) && c.length > 0)) {\n        o({ EnvironmentScene: ra }), f.value = new aa(s.resolution), f.value.texture.type = Lt, u = new la(s.near, s.far, f.value), v(f.value);\n        return;\n      }\n      (b = f.value) == null || b.dispose(), f.value = null, v();\n    }, { immediate: !0, deep: !0 }), i.value = h.value, tt(() => {\n      var p, b;\n      (p = d.value) == null || p.dispose(), (b = f.value) == null || b.dispose();\n    }), (p, b) => f.value ? (ae(), ce(\"TresEnvironmentScene\", {\n      key: 0,\n      ref_key: \"environmentScene\",\n      ref: d\n    }, [\n      Ne(p.$slots, \"default\")\n    ], 512)) : an(\"\", !0);\n  }\n}), yg = {\n  key: 0,\n  args: [0, 1, 64]\n}, _g = {\n  key: 1,\n  args: [0.5, 1, 64]\n}, xg = { key: 2 }, wg = [\"tone-mapped\", \"map\", \"side\", \"color\"], n0 = /* @__PURE__ */ ue({\n  __name: \"index\",\n  props: {\n    args: { default: null },\n    form: { default: \"rect\" },\n    toneMapped: { type: Boolean, default: !1 },\n    map: { default: null },\n    intensity: { default: 1 },\n    color: { default: new be(16777215) }\n  },\n  setup(r, { expose: e }) {\n    const t = r, n = me(), s = me();\n    return et(() => {\n      n.value && (n.value.color.copy(new be(t.color)), n.value.color.multiplyScalar(t.intensity), n.value.needsUpdate = !0);\n    }), e({ mesh: s }), (i, o) => (ae(), ce(\"TresMesh\", {\n      ref_key: \"mesh\",\n      ref: s\n    }, [\n      i.form === \"circle\" ? (ae(), ce(\"TresRingGeometry\", yg)) : i.form === \"ring\" ? (ae(), ce(\"TresRingGeometry\", _g)) : i.form === \"rect\" ? (ae(), ce(\"TresPlaneGeometry\", xg)) : (ae(), Oo(t.form, {\n        key: 3,\n        args: i.args\n      }, null, 8, [\"args\"])),\n      ye(\"TresMeshBasicMaterial\", {\n        ref_key: \"material\",\n        ref: n,\n        \"tone-mapped\": i.toneMapped,\n        map: i.map,\n        side: F(on),\n        color: i.color\n      }, null, 8, wg)\n    ], 512));\n  }\n});\nfunction s0(r, e) {\n  const t = {};\n  for (const n of e)\n    Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n  return t;\n}\nfunction i0(r, e) {\n  const t = `set${e[0].toUpperCase()}${e.slice(1)}`;\n  return r[t] !== void 0;\n}\nfunction o0(r) {\n  var t, n;\n  let e = r.value;\n  return r.value && ((n = (t = r.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = r.value.value.position), Array.isArray(r.value) && (e = new $(...e)), e;\n}\nexport {\n  jv as Align,\n  Ag as AnimatedSprite,\n  Vv as Backdrop,\n  wv as BakeShadows,\n  lt as BaseCameraControls,\n  Rg as Billboard,\n  Sv as Box,\n  iv as CameraControls,\n  Av as CatmullRomCurve3,\n  Pv as Circle,\n  Rv as Cone,\n  Yv as ContactShadows,\n  Pg as CubeCamera,\n  mv as CustomShaderMaterial,\n  Cv as Cylinder,\n  Iv as Dodecahedron,\n  sv as Edges,\n  t0 as Environment,\n  hv as FBXModel,\n  ev as Fbo,\n  Wv as Fit,\n  fv as GLTFModel,\n  Cg as GlobalAudio,\n  Ig as GradientTexture,\n  Xv as Grid,\n  gv as HolographicMaterial,\n  Tv as Html,\n  Ov as Icosahedron,\n  Og as Image,\n  ov as KeyboardControls,\n  jg as Lensflare,\n  Vg as Levioso,\n  n0 as Lightformer,\n  lm as Line2,\n  rv as MapControls,\n  Yg as Mask,\n  vv as MeshDiscardMaterial,\n  yv as MeshGlassMaterial,\n  _v as MeshReflectionMaterial,\n  xv as MeshWobbleMaterial,\n  Wg as MouseParallax,\n  $v as Ocean,\n  Dv as Octahedron,\n  av as OrbitControls,\n  Xg as Outline,\n  Lv as Plane,\n  Md as PointerLockControls,\n  $g as PositionalAudio,\n  Zv as Precipitation,\n  Zg as Reflector,\n  kv as Ring,\n  Nv as RoundedBox,\n  uv as SVG,\n  tv as Sampler,\n  nv as ScreenSizer,\n  Kg as ScreenSpace,\n  lv as ScrollControls,\n  Kv as Sky,\n  qv as Smoke,\n  Qv as SoftShadows,\n  Jv as Sparkles,\n  Bv as Sphere,\n  e0 as Stars,\n  bv as Stats,\n  Ev as StatsGl,\n  Uv as Superformula,\n  Fv as Tetrahedron,\n  qg as Text3D,\n  zv as Torus,\n  Gv as TorusKnot,\n  cv as TransformControls,\n  Hv as Tube,\n  o0 as extractBindingPosition,\n  i0 as hasSetter,\n  s0 as pick,\n  Qg as useAnimations,\n  vd as useEnvironment,\n  ad as useFBO,\n  Cd as useFBX,\n  kd as useGLTF,\n  Mv as useGLTFExporter,\n  Jg as useMask,\n  dv as useProgress,\n  ld as useSurfaceSampler,\n  pv as useVideoTexture\n};\n","<script setup lang=\"ts\">\r\nimport { useGLTF } from \"@tresjs/cientos\";\r\nimport * as THREE from \"three\";\r\n\r\nconst path = \"/models/precast_concrete_box_texture.glb\";\r\nconst { scene } = await useGLTF(path, { draco: true });\r\n\r\nscene.traverse((child) => {\r\n  if (child instanceof THREE.Mesh) {\r\n    const materialName = child.material.name;\r\n\r\n    // Black ë¨¸í‹°ë¦¬ì–¼ì¸ ê²½ìš°\r\n    if (materialName === \"Black\") {\r\n      child.material = child.material.clone();\r\n      child.material.color.set(\"#353535\"); // ì§„íšŒìƒ‰\r\n      child.material.roughness = 1.0;\r\n    }\r\n\r\n    // Black ì´ì™¸ ë¨¸í‹°ë¦¬ì–¼\r\n    if (materialName !== \"Black\") {\r\n      child.material.color.set(\"#e4e4e4\"); // ì—°í•œ íšŒìƒ‰\r\n      child.material.roughness = 0.7;\r\n    }\r\n\r\n    child.material.needsUpdate = true;\r\n  }\r\n});\r\n</script>\r\n\r\n<template>\r\n  <primitive\r\n    :object=\"scene\"\r\n    :scale=\"[0.8, 1.8, 0.8]\"\r\n    :position=\"[0, 0, 0]\"\r\n    :rotation=\"[-Math.PI / 2, -Math.PI / 2, 0]\"\r\n  >\r\n  </primitive>\r\n</template>\r\n","<script setup lang=\"ts\">\r\nimport { ref, onMounted, onBeforeUnmount, watch } from \"vue\";\r\nimport { useRoute, useRouter } from \"vue-router\";\r\nimport BackgroundPaths from \"@/components/BackgroundPaths.vue\";\r\nimport CubeScene from \"@/components/scene/CubeScene.vue\";\r\n\r\nconst showScene = ref(true);\r\n// ì„¸ì…˜ë§ˆë‹¤ ë‹¤ë¥¸ íƒ€ìž„ìŠ¤íƒ¬í”„ë¥¼ í‚¤ë¡œ ì‚¬ìš©\r\nconst sceneKey = ref(Date.now());\r\nconst route = useRoute();\r\nconst router = useRouter();\r\n\r\n// ë¼ìš°í„° ê²½ë¡œê°€ ë°”ë€” ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ í‚¤ í• ë‹¹\r\nwatch(\r\n  () => route.fullPath,\r\n  () => {\r\n    sceneKey.value = Date.now();\r\n  }\r\n);\r\nconst sections = [\"intro\", \"history\", \"projects\"];\r\nconst labels = [\"ì†Œê°œ\", \"ì—°í˜\", \"ì‹œê³µ ì‚¬ë¡€\"];\r\nconst projects = [\r\n  {\r\n    image: \"/img/main1.png\",\r\n    title: \"ì˜ê´‘ ì¤‘ì ê´€ë¦¬ì§€ì—­ ì‹œê³µ\",\r\n    date: \"2024ë…„ ~ ì§„í–‰ì¤‘\",\r\n  },\r\n  {\r\n    image: \"/img/main2.png\",\r\n    title: \"ìž¥ì„± ì£¼ê±° ë‹¨ì§€ ì‹œê³µ\",\r\n    date: \"2022ë…„ 11ì›”\",\r\n  },\r\n  { image: \"/img/main3.png\", title: \"ë‹´ì–‘ ê³µê³µ ê±´ì¶•ë¬¼\", date: \"2021ë…„ 8ì›”\" },\r\n  {\r\n    image: \"/img/main4.png\",\r\n    title: \"í•´ìˆ˜ì†Œí†µë¡œ\",\r\n    date: \"2024ë…„ 1ì›”\",\r\n  },\r\n  { image: \"/img/main3.png\", title: \"ë¶€ì‚° ê³µê³µ ê±´ì¶•ë¬¼\", date: \"2021ë…„ 8ì›”\" },\r\n  { image: \"/img/main4.png\", title: \"ì¸ì²œ ì‚°ì—… ë‹¨ì§€\", date: \"2024ë…„ 1ì›”\" },\r\n];\r\n\r\nconst history = [\r\n  { year: \"1994\", event: \"ëŒ€ê´‘ PC ì„¤ë¦½\" },\r\n  { year: \"2017\", event: \"ê´‘ì£¼ í•˜ë‚¨3ì§€êµ¬ ì˜¤ìˆ˜ê´€ë¡œ ì„¤ì¹˜\" },\r\n  { year: \"2025\", event: \"ì˜ê´‘ ì¤‘ì ê´€ë¦¬ì§€ì—­ PC ì•”ê±°ì„¤ì¹˜\" },\r\n  { year: \"2025\", event: \"ì˜ê´‘ ì¤‘ì ê´€ë¦¬ì§€ì—­ PC ì•”ê±°ì„¤ì¹˜\" },\r\n];\r\n\r\nconst currentSection = ref(0);\r\nconst indicatorY = ref(0);\r\n\r\nfunction scrollTo(index: number) {\r\n  const el = document.getElementById(sections[index]);\r\n  if (el) el.scrollIntoView({ behavior: \"smooth\" });\r\n}\r\n\r\nonMounted(() => {\r\n  const observer = new IntersectionObserver(\r\n    (entries) => {\r\n      entries.forEach((entry) => {\r\n        if (entry.isIntersecting) {\r\n          const id = entry.target.id;\r\n          const index = sections.findIndex((s) => s === id);\r\n          if (index !== -1) {\r\n            currentSection.value = index;\r\n\r\n            const rect = entry.target.getBoundingClientRect();\r\n            indicatorY.value = rect.height / 2 - 12;\r\n          }\r\n        }\r\n      });\r\n    },\r\n    { threshold: 0.5 }\r\n  );\r\n\r\n  sections.forEach((id) => {\r\n    const el = document.getElementById(id);\r\n    if (el) observer.observe(el);\r\n  });\r\n});\r\n</script>\r\n\r\n<template>\r\n  <div class=\"index-page relative\">\r\n    <!-- ë°±ê·¸ë¼ìš´ë“œ -->\r\n    <section id=\"paths\" class=\"scene-paths relative\">\r\n      <div\r\n        class=\"scene-overlay absolute top-0 left-0 w-full h-full flex flex-col items-center justify-center z-10\"\r\n      >\r\n        <div class=\"flex\">\r\n          <img src=\"/logo.svg\" alt=\"ë¡œê³ \" class=\"logo mr-2\" />\r\n          <h1 class=\"title text-primary\">ëŒ€ê´‘ PC</h1>\r\n        </div>\r\n        <p class=\"subtitle\">PC BOX ì„¤ì¹˜ ì „ë¬¸ê¸°ì—…</p>\r\n      </div>\r\n      <BackgroundPaths />\r\n    </section>\r\n\r\n    <!-- âœ… í•­ìƒ í‘œì‹œë˜ëŠ” ì¸ë””ì¼€ì´í„° -->\r\n    <div\r\n      class=\"section-indicator fixed left-6 z-50 top-1/2 -translate-y-1/2 transition-transform duration-300\"\r\n    >\r\n      <ul class=\"flex flex-col gap-4\">\r\n        <li v-for=\"(label, i) in labels\" :key=\"i\">\r\n          <button\r\n            class=\"text-xl font-bold px-4 py-2 rounded-lg transition-all duration-300\"\r\n            :class=\"\r\n              currentSection === i\r\n                ? 'bg-black text-white'\r\n                : 'bg-gray-200 text-gray-600'\r\n            \"\r\n            @click=\"scrollTo(i)\"\r\n          >\r\n            {{ label }}\r\n          </button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n\r\n    <!-- ì„¹ì…˜ ë‚´ìš© -->\r\n    <section id=\"intro\" class=\"scene-wrapper section-dark\">\r\n      <div class=\"scene-intro text-center space-y-6\">\r\n        <div class=\"flex justify-center items-center\">\r\n          <img src=\"/logo.svg\" alt=\"ë¡œê³ \" class=\"logo mr-3\" />\r\n          <h1 class=\"title text-white\">ëŒ€ê´‘ PC</h1>\r\n        </div>\r\n        <p class=\"subtitle text-xl text-white leading-relaxed max-w-xl mx-auto\">\r\n          <strong class=\"text-accent\">PC ë°•ìŠ¤</strong>ëŠ”\r\n          <strong>ë¯¸ë¦¬ ì œìž‘ëœ ì½˜í¬ë¦¬íŠ¸ êµ¬ì¡°ë¬¼</strong>ë¡œ,<br />\r\n          <strong>ë°°ìˆ˜ë¡œ</strong> ë° <strong>ì§€í•˜ êµ¬ì¡°ë¬¼ ì‹œê³µ</strong>ì—\r\n          ì‚¬ìš©ë©ë‹ˆë‹¤.<br /><br />\r\n\r\n          <strong>ì •ë°€í•œ ì‹œê³µ</strong>ê³¼ <strong>ì „ë¬¸ ì„¤ì¹˜ ê¸°ìˆ </strong>ì„\r\n          ë°”íƒ•ìœ¼ë¡œ,<br />\r\n          ì¸í”„ë¼ì˜ ë“ ë“ í•œ ê¸°ë°˜ì„ ë§Œë“¤ì–´ ê°‘ë‹ˆë‹¤.\r\n        </p>\r\n      </div>\r\n      <section class=\"three-section\">\r\n        <CubeScene :key=\"sceneKey\" />\r\n      </section>\r\n    </section>\r\n\r\n    <section id=\"history\" class=\"history-section section-light\">\r\n      <h2 class=\"section-heading\">ðŸ—ï¸ ì£¼ìš” ì´ë ¥</h2>\r\n      <ul class=\"history-list\">\r\n        <li v-for=\"item in history\" :key=\"item.year\" class=\"history-item\">\r\n          <span class=\"year\">{{ item.year }}</span>\r\n          <span class=\"event\">{{ item.event }}</span>\r\n        </li>\r\n      </ul>\r\n    </section>\r\n\r\n    <section id=\"projects\" class=\"projects section-muted\">\r\n      <h2 class=\"projects-title\">ì‹œê³µ ì‚¬ë¡€</h2>\r\n      <div class=\"projects-grid\">\r\n        <div\r\n          v-for=\"project in projects\"\r\n          @click=\"router.push('/works')\"\r\n          :key=\"project.title\"\r\n          class=\"project-card\"\r\n        >\r\n          <img\r\n            :src=\"project.image\"\r\n            :alt=\"project.title\"\r\n            class=\"project-image\"\r\n          />\r\n          <div class=\"project-info\">\r\n            <h3 class=\"project-title\">{{ project.title }}</h3>\r\n            <p class=\"project-date\">{{ project.date }}</p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </section>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.three-section {\r\n  position: relative;\r\n  width: 70%;\r\n  margin: 0 auto;\r\n  height: 100vh;\r\n}\r\n.scene-paths {\r\n  position: sticky;\r\n  top: 0;\r\n  height: 100vh;\r\n  z-index: 0;\r\n}\r\n\r\n.index-page {\r\n  background: var(--background-base);\r\n  color: var(--text-primary);\r\n  scroll-behavior: smooth;\r\n}\r\n\r\n.logo {\r\n  width: 90px;\r\n  margin-bottom: 1rem;\r\n}\r\n\r\n.title {\r\n  font-size: 5rem;\r\n  font-weight: bold;\r\n  color: var(--text-primary);\r\n  margin-bottom: 0.5rem;\r\n  margin-left: 1rem;\r\n}\r\n\r\n.subtitle {\r\n  font-size: 2rem;\r\n  font-weight: bold;\r\n  color: var(--text-secondary);\r\n  margin-top: 0.5rem;\r\n  text-align: center;\r\n}\r\n.section-dark {\r\n  background-color: #0f172a;\r\n  color: #f8fafc;\r\n}\r\n\r\n.section-light {\r\n  background-color: #f8fafc;\r\n  color: #1e293b;\r\n}\r\n\r\n.section-muted {\r\n  background-color: #e2e8f0;\r\n  color: #1e293b;\r\n}\r\n\r\n.scene-wrapper,\r\n.history-section,\r\n.projects {\r\n  min-height: 100vh;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  padding: 4rem 2rem;\r\n  position: relative;\r\n  overflow: hidden;\r\n  z-index: 2;\r\n}\r\n\r\n.scene-intro {\r\n  text-align: center;\r\n  min-height: 100vh;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.section-heading {\r\n  font-size: 2rem;\r\n  margin-bottom: 2rem;\r\n  text-align: center;\r\n}\r\n\r\n.history-list {\r\n  list-style: none;\r\n  padding: 0;\r\n  max-width: 600px;\r\n  width: 100%;\r\n}\r\n\r\n.history-item {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  background: var(--background-soft);\r\n  padding: 1rem;\r\n  margin-bottom: 1rem;\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 10px var(--shadow-color);\r\n}\r\n\r\n.year {\r\n  font-weight: bold;\r\n  color: var(--accent-color);\r\n  margin-right: 1rem;\r\n  min-width: 60px;\r\n}\r\n\r\n.event {\r\n  color: var(--text-primary);\r\n  flex: 1;\r\n}\r\n\r\n.projects-title {\r\n  font-size: 1.75rem;\r\n  font-weight: bold;\r\n  margin-bottom: 2rem;\r\n  text-align: center;\r\n}\r\n\r\n.projects-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n  gap: 2rem;\r\n  width: 100%;\r\n  max-width: 1200px;\r\n}\r\n\r\n.project-card {\r\n  background: var(--background-soft);\r\n  border: 1px solid var(--border-color);\r\n  border-radius: 8px;\r\n  overflow: hidden;\r\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\r\n}\r\n\r\n.project-card:hover {\r\n  transform: translateY(-5px);\r\n  box-shadow: 0 8px 16px var(--shadow-color);\r\n}\r\n\r\n.project-image {\r\n  width: 100%;\r\n  height: 180px;\r\n  object-fit: cover;\r\n}\r\n\r\n.project-info {\r\n  padding: 1rem;\r\n}\r\n\r\n.project-title {\r\n  font-size: 1.1rem;\r\n  font-weight: 600;\r\n  color: var(--text-primary);\r\n}\r\n\r\n.project-date {\r\n  font-size: 0.9rem;\r\n  color: var(--text-secondary);\r\n  margin-top: 0.5rem;\r\n}\r\n</style>\r\n"],"names":["z","invoke","keys","events","el","window","timestamp","dn","gn","vn","yn","wn","An","Me","In","$n","Fn","dt","Ge","pt","er","st","tr","nr","rr","or","it","sr","ar","I","K","Ht","xe","be","J","pe","cr","ur","fr","nn","dr","lt","h","W","mr","Ut","hr","Z","Ft","ct","Wt","Nt","x","rn","$","ge","ae","on","sn","an","we","Ne","ln","cn","ve","D","Ae","Oe","De","_e","zt","le","un","fn","ut","St","Xr","Zr","Xe","Ze","xt","Gt","Vt","Se","$r","fe","At","He","ot","Ue","Bt","jt","kt","Lt","Rt","Ot","Dt","dc","pc","F","ue","ca","Al","ua","tt","bt","Dn","Ye","Ts","Pl","oo","ha","de","xs","Rl","es","Mo","Kn","da","pa","wt","ma","Eo","Ln","ga","mi","ei","N","V","fa","Ie","bs","at","Xt","Cl","ht","Ao","$t","ti","gi","So","va","li","Il","vt","Dl","_a","Ee","je","hn","_n","En","Ke","si","ee","te","H","se","G","oe","yt","Un","qn","kn","wa","ro","xa","Kt","Ta","Ll","Fl","Es","ss","ai","kl","Nl","vi","ws","Po","Bl","ke","Ul","ba","Zt","Ea","Ma","ao","co","uo","lo","_t","Ms","pn","Kl","re","Le","ce","ye","Ve","Nn","et","Io","mc","me","Pe","ii","ms","gc","Ko","Ti","xn","Oo","_withAsyncContext","useGLTF","THREE"],"mappings":";;;;;;;;;;;;;;;;;;;;AAEA,MAAM,KAAK;AAAA,EAKT,YAAY,GAAW,GAAWA,IAAW;AAJ7C;AACA;AACA;AAGE,SAAK,IAAI;AACT,SAAK,IAAI;AACT,SAAK,IAAIA;AAAA,EAAA;AAAA,EAGX,KAAK,GAAW,GAAmB;AACjC,WAAO,KAAK,IAAI,IAAI,KAAK,IAAI;AAAA,EAAA;AAEjC;AAEO,MAAM,MAAM;AAAA,EAMjB,YAAY,OAAO,GAAG;AALd;AACA;AACA;AACA;AAGN,SAAK,QAAQ;AAAA,MACX,IAAI,KAAK,GAAG,GAAG,CAAC;AAAA,MAChB,IAAI,KAAK,IAAI,GAAG,CAAC;AAAA,MACjB,IAAI,KAAK,GAAG,IAAI,CAAC;AAAA,MACjB,IAAI,KAAK,IAAI,IAAI,CAAC;AAAA,MAClB,IAAI,KAAK,GAAG,GAAG,CAAC;AAAA,MAChB,IAAI,KAAK,IAAI,GAAG,CAAC;AAAA,MACjB,IAAI,KAAK,GAAG,GAAG,EAAE;AAAA,MACjB,IAAI,KAAK,IAAI,GAAG,EAAE;AAAA,MAClB,IAAI,KAAK,GAAG,GAAG,CAAC;AAAA,MAChB,IAAI,KAAK,GAAG,IAAI,CAAC;AAAA,MACjB,IAAI,KAAK,GAAG,GAAG,EAAE;AAAA,MACjB,IAAI,KAAK,GAAG,IAAI,EAAE;AAAA,IACpB;AAEA,SAAK,IAAI;AAAA,MACP;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAG;AAAA,MAClE;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAG;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAG;AAAA,MAAK;AAAA,MACpE;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAG;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MACtE;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MACpE;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MACrE;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MACpE;AAAA,MAAI;AAAA,MAAK;AAAA,MAAG;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MACnE;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAG;AAAA,MAAI;AAAA,MAAI;AAAA,MACtE;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAG;AAAA,MAAK;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MACtE;AAAA,MAAI;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAI;AAAA,MAAI;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MAAK;AAAA,MACpE;AAAA,MAAK;A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GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,QAAQ,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS,GAAG,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,QAAQ,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,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AAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACE,IAAA;AACN;AACA,IAAI,IAAI;AACR,SAAS,KAAK;AACL,SAAA,OAAO,KAAK,GAAG,KAAK;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACE,IAAA;AACN;AACA,IAAI,IAAI;AACR,SAAS,KAAK;AACL,SAAA,OAAO,KAAK,GAAG,KAAK;AAAA;AAAA,IAEzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACE,IAAA;AACN;AACA,IAAI,IAAI;AACR,SAAS,KAAK;AACZ,MAAI,GAAW,QAAA;AACV,OAAA;AACL,MAAI,IAAI,GAAG;AACX,SAAO,KAAK,EAAE,MAAM,EAAE,OAAO;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAC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","x_google_ignoreList":[2,3,4,5]}